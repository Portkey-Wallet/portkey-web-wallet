/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/web3-providers-ws";
exports.ids = ["vendor-chunks/web3-providers-ws"];
exports.modules = {

/***/ "(ssr)/./node_modules/web3-providers-ws/lib/helpers.js":
/*!*******************************************************!*\
  !*** ./node_modules/web3-providers-ws/lib/helpers.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var isNode = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';\nvar isRN = typeof navigator !== 'undefined' && navigator.product === 'ReactNative';\nvar _btoa = null;\nvar helpers = null;\nif (isNode || isRN) {\n    _btoa = function (str) {\n        return Buffer.from(str).toString('base64');\n    };\n    var url = __webpack_require__(/*! url */ \"url\");\n    if (url.URL) {\n        // Use the new Node 6+ API for parsing URLs that supports username/password\n        var newURL = url.URL;\n        helpers = function (url) {\n            return new newURL(url);\n        };\n    }\n    else {\n        // Web3 supports Node.js 5, so fall back to the legacy URL API if necessary\n        helpers = (__webpack_require__(/*! url */ \"url\").parse);\n    }\n}\nelse {\n    _btoa = btoa.bind(typeof globalThis === 'object' ? globalThis : self);\n    helpers = function (url) {\n        return new URL(url);\n    };\n}\nmodule.exports = {\n    parseURL: helpers,\n    btoa: _btoa\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlcnMtd3MvbGliL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNkNBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0Bwb3J0a2V5L25leHQtZXhhbXBsZS8uL25vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVycy13cy9saWIvaGVscGVycy5qcz9jNjcwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBpc05vZGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnID8gcHJvY2VzcyA6IDApID09PSAnW29iamVjdCBwcm9jZXNzXSc7XG52YXIgaXNSTiA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnO1xudmFyIF9idG9hID0gbnVsbDtcbnZhciBoZWxwZXJzID0gbnVsbDtcbmlmIChpc05vZGUgfHwgaXNSTikge1xuICAgIF9idG9hID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oc3RyKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfTtcbiAgICB2YXIgdXJsID0gcmVxdWlyZSgndXJsJyk7XG4gICAgaWYgKHVybC5VUkwpIHtcbiAgICAgICAgLy8gVXNlIHRoZSBuZXcgTm9kZSA2KyBBUEkgZm9yIHBhcnNpbmcgVVJMcyB0aGF0IHN1cHBvcnRzIHVzZXJuYW1lL3Bhc3N3b3JkXG4gICAgICAgIHZhciBuZXdVUkwgPSB1cmwuVVJMO1xuICAgICAgICBoZWxwZXJzID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBuZXdVUkwodXJsKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFdlYjMgc3VwcG9ydHMgTm9kZS5qcyA1LCBzbyBmYWxsIGJhY2sgdG8gdGhlIGxlZ2FjeSBVUkwgQVBJIGlmIG5lY2Vzc2FyeVxuICAgICAgICBoZWxwZXJzID0gcmVxdWlyZSgndXJsJykucGFyc2U7XG4gICAgfVxufVxuZWxzZSB7XG4gICAgX2J0b2EgPSBidG9hLmJpbmQodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnID8gZ2xvYmFsVGhpcyA6IHNlbGYpO1xuICAgIGhlbHBlcnMgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHJldHVybiBuZXcgVVJMKHVybCk7XG4gICAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHBhcnNlVVJMOiBoZWxwZXJzLFxuICAgIGJ0b2E6IF9idG9hXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/web3-providers-ws/lib/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/web3-providers-ws/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/web3-providers-ws/lib/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * @file WebsocketProvider.js\n * @authors: Samuel Furter <samuel@ethereum.org>, Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2019\n */\n\nvar EventEmitter = __webpack_require__(/*! eventemitter3 */ \"(ssr)/./node_modules/eventemitter3/index.js\");\nvar helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/web3-providers-ws/lib/helpers.js\");\nvar errors = (__webpack_require__(/*! web3-core-helpers */ \"(ssr)/./node_modules/web3-core-helpers/lib/index.js\").errors);\nvar Ws = (__webpack_require__(/*! websocket */ \"websocket\").w3cwebsocket);\n/**\n * @param {string} url\n * @param {Object} options\n *\n * @constructor\n */\nvar WebsocketProvider = function WebsocketProvider(url, options) {\n    EventEmitter.call(this);\n    options = options || {};\n    this.url = url;\n    this._customTimeout = options.timeout || 1000 * 15;\n    this.headers = options.headers || {};\n    this.protocol = options.protocol || undefined;\n    this.reconnectOptions = Object.assign({\n        auto: false,\n        delay: 5000,\n        maxAttempts: false,\n        onTimeout: false\n    }, options.reconnect);\n    this.clientConfig = options.clientConfig || undefined; // Allow a custom client configuration\n    this.requestOptions = options.requestOptions || undefined; // Allow a custom request options (https://github.com/theturtle32/WebSocket-Node/blob/master/docs/WebSocketClient.md#connectrequesturl-requestedprotocols-origin-headers-requestoptions)\n    this.DATA = 'data';\n    this.CLOSE = 'close';\n    this.ERROR = 'error';\n    this.CONNECT = 'connect';\n    this.RECONNECT = 'reconnect';\n    this.connection = null;\n    this.requestQueue = new Map();\n    this.responseQueue = new Map();\n    this.reconnectAttempts = 0;\n    this.reconnecting = false;\n    this.connectFailedDescription = null;\n    // The w3cwebsocket implementation does not support Basic Auth\n    // username/password in the URL. So generate the basic auth header, and\n    // pass through with any additional headers supplied in constructor\n    var parsedURL = helpers.parseURL(url);\n    if (parsedURL.username && parsedURL.password) {\n        this.headers.authorization = 'Basic ' + helpers.btoa(parsedURL.username + ':' + parsedURL.password);\n    }\n    // When all node core implementations that do not have the\n    // WHATWG compatible URL parser go out of service this line can be removed.\n    if (parsedURL.auth) {\n        this.headers.authorization = 'Basic ' + helpers.btoa(parsedURL.auth);\n    }\n    // make property `connected` which will return the current connection status\n    Object.defineProperty(this, 'connected', {\n        get: function () {\n            return this.connection && this.connection.readyState === this.connection.OPEN;\n        },\n        enumerable: true\n    });\n    this.connect();\n};\n// Inherit from EventEmitter\nWebsocketProvider.prototype = Object.create(EventEmitter.prototype);\nWebsocketProvider.prototype.constructor = WebsocketProvider;\n/**\n * Connects to the configured node\n *\n * @method connect\n *\n * @returns {void}\n */\nWebsocketProvider.prototype.connect = function () {\n    this.connection = new Ws(this.url, this.protocol, undefined, this.headers, this.requestOptions, this.clientConfig);\n    this._addSocketListeners();\n};\n/**\n * Listener for the `data` event of the underlying WebSocket object\n *\n * @method _onMessage\n *\n * @returns {void}\n */\nWebsocketProvider.prototype._onMessage = function (e) {\n    var _this = this;\n    this._parseResponse((typeof e.data === 'string') ? e.data : '').forEach(function (result) {\n        if (result.method && result.method.indexOf('_subscription') !== -1) {\n            _this.emit(_this.DATA, result);\n            return;\n        }\n        var id = result.id;\n        // get the id which matches the returned id\n        if (Array.isArray(result)) {\n            id = result[0].id;\n        }\n        if (_this.responseQueue.has(id)) {\n            if (_this.responseQueue.get(id).callback !== undefined) {\n                _this.responseQueue.get(id).callback(false, result);\n            }\n            _this.responseQueue.delete(id);\n        }\n    });\n};\n/**\n * Listener for the `open` event of the underlying WebSocket object\n *\n * @method _onConnect\n *\n * @returns {void}\n */\nWebsocketProvider.prototype._onConnect = function () {\n    this.emit(this.CONNECT);\n    this.reconnectAttempts = 0;\n    this.reconnecting = false;\n    if (this.requestQueue.size > 0) {\n        var _this = this;\n        this.requestQueue.forEach(function (request, key) {\n            _this.send(request.payload, request.callback);\n            _this.requestQueue.delete(key);\n        });\n    }\n};\nWebsocketProvider.prototype._onConnectFailed = function (event) {\n    this.connectFailedDescription = event.toString().split('\\n')[0];\n    var _this = this;\n    if (this.connectFailedDescription) {\n        event.description = this.connectFailedDescription;\n        this.connectFailedDescription = null; // clean the message, so it won't be used in the next connection\n    }\n    event.code = 1006;\n    event.reason = 'connection failed';\n    if (this.reconnectOptions.auto && (![1000, 1001].includes(event.code) || event.wasClean === false)) {\n        this.reconnect();\n        return;\n    }\n    this.emit(this.ERROR, event);\n    if (this.requestQueue.size > 0) {\n        this.requestQueue.forEach(function (request, key) {\n            request.callback(errors.ConnectionNotOpenError(event));\n            _this.requestQueue.delete(key);\n        });\n    }\n    if (this.responseQueue.size > 0) {\n        this.responseQueue.forEach(function (request, key) {\n            request.callback(errors.InvalidConnection('on WS', event));\n            _this.responseQueue.delete(key);\n        });\n    }\n    //clean connection on our own\n    if (this.connection._connection) {\n        this.connection._connection.removeAllListeners();\n    }\n    this.connection._client.removeAllListeners();\n    this.connection._readyState = 3; // set readyState to CLOSED\n    this.emit(this.CLOSE, event);\n};\n/**\n * Listener for the `close` event of the underlying WebSocket object\n *\n * @method _onClose\n *\n * @returns {void}\n */\nWebsocketProvider.prototype._onClose = function (event) {\n    var _this = this;\n    if (this.reconnectOptions.auto && (![1000, 1001].includes(event.code) || event.wasClean === false)) {\n        this.reconnect();\n        return;\n    }\n    this.emit(this.CLOSE, event);\n    if (this.requestQueue.size > 0) {\n        this.requestQueue.forEach(function (request, key) {\n            request.callback(errors.ConnectionNotOpenError(event));\n            _this.requestQueue.delete(key);\n        });\n    }\n    if (this.responseQueue.size > 0) {\n        this.responseQueue.forEach(function (request, key) {\n            request.callback(errors.InvalidConnection('on WS', event));\n            _this.responseQueue.delete(key);\n        });\n    }\n    this._removeSocketListeners();\n    this.removeAllListeners();\n};\n/**\n * Will add the required socket listeners\n *\n * @method _addSocketListeners\n *\n * @returns {void}\n */\nWebsocketProvider.prototype._addSocketListeners = function () {\n    this.connection.addEventListener('message', this._onMessage.bind(this));\n    this.connection.addEventListener('open', this._onConnect.bind(this));\n    this.connection.addEventListener('close', this._onClose.bind(this));\n    if (this.connection._client) {\n        this.connection._client.removeAllListeners('connectFailed'); //Override the internal listeners, so they don't trigger a `close` event. We want to trigger `_onClose` manually with a description.\n        this.connection._client.on('connectFailed', this._onConnectFailed.bind(this));\n    }\n};\n/**\n * Will remove all socket listeners\n *\n * @method _removeSocketListeners\n *\n * @returns {void}\n */\nWebsocketProvider.prototype._removeSocketListeners = function () {\n    this.connection.removeEventListener('message', this._onMessage);\n    this.connection.removeEventListener('open', this._onConnect);\n    this.connection.removeEventListener('close', this._onClose);\n    if (this.connection._connection)\n        this.connection._client.removeListener('connectFailed', this._onConnectFailed);\n};\n/**\n * Will parse the response and make an array out of it.\n *\n * @method _parseResponse\n *\n * @param {String} data\n *\n * @returns {Array}\n */\nWebsocketProvider.prototype._parseResponse = function (data) {\n    var _this = this, returnValues = [];\n    // DE-CHUNKER\n    var dechunkedData = data\n        .replace(/\\}[\\n\\r]?\\{/g, '}|--|{') // }{\n        .replace(/\\}\\][\\n\\r]?\\[\\{/g, '}]|--|[{') // }][{\n        .replace(/\\}[\\n\\r]?\\[\\{/g, '}|--|[{') // }[{\n        .replace(/\\}\\][\\n\\r]?\\{/g, '}]|--|{') // }]{\n        .split('|--|');\n    dechunkedData.forEach(function (data) {\n        // prepend the last chunk\n        if (_this.lastChunk)\n            data = _this.lastChunk + data;\n        var result = null;\n        try {\n            result = JSON.parse(data);\n        }\n        catch (e) {\n            _this.lastChunk = data;\n            // start timeout to cancel all requests\n            clearTimeout(_this.lastChunkTimeout);\n            _this.lastChunkTimeout = setTimeout(function () {\n                if (_this.reconnectOptions.auto && _this.reconnectOptions.onTimeout) {\n                    _this.reconnect();\n                    return;\n                }\n                _this.emit(_this.ERROR, errors.ConnectionTimeout(_this._customTimeout));\n                if (_this.requestQueue.size > 0) {\n                    _this.requestQueue.forEach(function (request, key) {\n                        request.callback(errors.ConnectionTimeout(_this._customTimeout));\n                        _this.requestQueue.delete(key);\n                    });\n                }\n            }, _this._customTimeout);\n            return;\n        }\n        // cancel timeout and set chunk to null\n        clearTimeout(_this.lastChunkTimeout);\n        _this.lastChunk = null;\n        if (result)\n            returnValues.push(result);\n    });\n    return returnValues;\n};\n/**\n * Does check if the provider is connecting and will add it to the queue or will send it directly\n *\n * @method send\n *\n * @param {Object} payload\n * @param {Function} callback\n *\n * @returns {void}\n */\nWebsocketProvider.prototype.send = function (payload, callback) {\n    var _this = this;\n    var id = payload.id;\n    var request = { payload: payload, callback: callback };\n    if (Array.isArray(payload)) {\n        id = payload[0].id;\n    }\n    if (this.connection.readyState === this.connection.CONNECTING || this.reconnecting) {\n        this.requestQueue.set(id, request);\n        return;\n    }\n    if (this.connection.readyState !== this.connection.OPEN) {\n        this.requestQueue.delete(id);\n        this.emit(this.ERROR, errors.ConnectionNotOpenError());\n        request.callback(errors.ConnectionNotOpenError());\n        return;\n    }\n    this.responseQueue.set(id, request);\n    this.requestQueue.delete(id);\n    try {\n        this.connection.send(JSON.stringify(request.payload));\n    }\n    catch (error) {\n        request.callback(error);\n        _this.responseQueue.delete(id);\n    }\n};\n/**\n * Resets the providers, clears all callbacks\n *\n * @method reset\n *\n * @returns {void}\n */\nWebsocketProvider.prototype.reset = function () {\n    this.responseQueue.clear();\n    this.requestQueue.clear();\n    this.removeAllListeners();\n    this._removeSocketListeners();\n    this._addSocketListeners();\n};\n/**\n * Closes the current connection with the given code and reason arguments\n *\n * @method disconnect\n *\n * @param {number} code\n * @param {string} reason\n *\n * @returns {void}\n */\nWebsocketProvider.prototype.disconnect = function (code, reason) {\n    this._removeSocketListeners();\n    this.connection.close(code || 1000, reason);\n};\n/**\n * Returns the desired boolean.\n *\n * @method supportsSubscriptions\n *\n * @returns {boolean}\n */\nWebsocketProvider.prototype.supportsSubscriptions = function () {\n    return true;\n};\n/**\n * Removes the listeners and reconnects to the socket.\n *\n * @method reconnect\n *\n * @returns {void}\n */\nWebsocketProvider.prototype.reconnect = function () {\n    var _this = this;\n    this.reconnecting = true;\n    if (this.responseQueue.size > 0) {\n        this.responseQueue.forEach(function (request, key) {\n            try {\n                _this.responseQueue.delete(key);\n                request.callback(errors.PendingRequestsOnReconnectingError());\n            }\n            catch (e) {\n                console.error(\"Error encountered in reconnect: \", e);\n            }\n        });\n    }\n    if (!this.reconnectOptions.maxAttempts ||\n        this.reconnectAttempts < this.reconnectOptions.maxAttempts) {\n        setTimeout(function () {\n            _this.reconnectAttempts++;\n            _this._removeSocketListeners();\n            _this.emit(_this.RECONNECT, _this.reconnectAttempts);\n            _this.connect();\n        }, this.reconnectOptions.delay);\n        return;\n    }\n    this.emit(this.ERROR, errors.MaxAttemptsReachedOnReconnectingError());\n    this.reconnecting = false;\n    if (this.requestQueue.size > 0) {\n        this.requestQueue.forEach(function (request, key) {\n            request.callback(errors.MaxAttemptsReachedOnReconnectingError());\n            _this.requestQueue.delete(key);\n        });\n    }\n};\nmodule.exports = WebsocketProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlcnMtd3MvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYixtQkFBbUIsbUJBQU8sQ0FBQyxrRUFBZTtBQUMxQyxjQUFjLG1CQUFPLENBQUMsMkVBQWM7QUFDcEMsYUFBYSw0R0FBbUM7QUFDaEQsU0FBUyxnRUFBaUM7QUFDMUM7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwyREFBMkQ7QUFDM0QsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVMsTUFBTSxLQUFLO0FBQ3hDLG9CQUFvQixhQUFhLE1BQU0sT0FBTyxPQUFPO0FBQ3JELG9CQUFvQixXQUFXLE1BQU0sTUFBTSxPQUFPO0FBQ2xELG9CQUFvQixXQUFXLE1BQU0sTUFBTSxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0Bwb3J0a2V5L25leHQtZXhhbXBsZS8uL25vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVycy13cy9saWIvaW5kZXguanM/NWJiOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4gKi9cbi8qKlxuICogQGZpbGUgV2Vic29ja2V0UHJvdmlkZXIuanNcbiAqIEBhdXRob3JzOiBTYW11ZWwgRnVydGVyIDxzYW11ZWxAZXRoZXJldW0ub3JnPiwgRmFiaWFuIFZvZ2Vsc3RlbGxlciA8ZmFiaWFuQGV0aGVyZXVtLm9yZz5cbiAqIEBkYXRlIDIwMTlcbiAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50ZW1pdHRlcjMnKTtcbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzLmpzJyk7XG52YXIgZXJyb3JzID0gcmVxdWlyZSgnd2ViMy1jb3JlLWhlbHBlcnMnKS5lcnJvcnM7XG52YXIgV3MgPSByZXF1aXJlKCd3ZWJzb2NrZXQnKS53M2N3ZWJzb2NrZXQ7XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBXZWJzb2NrZXRQcm92aWRlciA9IGZ1bmN0aW9uIFdlYnNvY2tldFByb3ZpZGVyKHVybCwgb3B0aW9ucykge1xuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMuX2N1c3RvbVRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQgfHwgMTAwMCAqIDE1O1xuICAgIHRoaXMuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fTtcbiAgICB0aGlzLnByb3RvY29sID0gb3B0aW9ucy5wcm90b2NvbCB8fCB1bmRlZmluZWQ7XG4gICAgdGhpcy5yZWNvbm5lY3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGF1dG86IGZhbHNlLFxuICAgICAgICBkZWxheTogNTAwMCxcbiAgICAgICAgbWF4QXR0ZW1wdHM6IGZhbHNlLFxuICAgICAgICBvblRpbWVvdXQ6IGZhbHNlXG4gICAgfSwgb3B0aW9ucy5yZWNvbm5lY3QpO1xuICAgIHRoaXMuY2xpZW50Q29uZmlnID0gb3B0aW9ucy5jbGllbnRDb25maWcgfHwgdW5kZWZpbmVkOyAvLyBBbGxvdyBhIGN1c3RvbSBjbGllbnQgY29uZmlndXJhdGlvblxuICAgIHRoaXMucmVxdWVzdE9wdGlvbnMgPSBvcHRpb25zLnJlcXVlc3RPcHRpb25zIHx8IHVuZGVmaW5lZDsgLy8gQWxsb3cgYSBjdXN0b20gcmVxdWVzdCBvcHRpb25zIChodHRwczovL2dpdGh1Yi5jb20vdGhldHVydGxlMzIvV2ViU29ja2V0LU5vZGUvYmxvYi9tYXN0ZXIvZG9jcy9XZWJTb2NrZXRDbGllbnQubWQjY29ubmVjdHJlcXVlc3R1cmwtcmVxdWVzdGVkcHJvdG9jb2xzLW9yaWdpbi1oZWFkZXJzLXJlcXVlc3RvcHRpb25zKVxuICAgIHRoaXMuREFUQSA9ICdkYXRhJztcbiAgICB0aGlzLkNMT1NFID0gJ2Nsb3NlJztcbiAgICB0aGlzLkVSUk9SID0gJ2Vycm9yJztcbiAgICB0aGlzLkNPTk5FQ1QgPSAnY29ubmVjdCc7XG4gICAgdGhpcy5SRUNPTk5FQ1QgPSAncmVjb25uZWN0JztcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSBudWxsO1xuICAgIHRoaXMucmVxdWVzdFF1ZXVlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMucmVzcG9uc2VRdWV1ZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzID0gMDtcbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgIHRoaXMuY29ubmVjdEZhaWxlZERlc2NyaXB0aW9uID0gbnVsbDtcbiAgICAvLyBUaGUgdzNjd2Vic29ja2V0IGltcGxlbWVudGF0aW9uIGRvZXMgbm90IHN1cHBvcnQgQmFzaWMgQXV0aFxuICAgIC8vIHVzZXJuYW1lL3Bhc3N3b3JkIGluIHRoZSBVUkwuIFNvIGdlbmVyYXRlIHRoZSBiYXNpYyBhdXRoIGhlYWRlciwgYW5kXG4gICAgLy8gcGFzcyB0aHJvdWdoIHdpdGggYW55IGFkZGl0aW9uYWwgaGVhZGVycyBzdXBwbGllZCBpbiBjb25zdHJ1Y3RvclxuICAgIHZhciBwYXJzZWRVUkwgPSBoZWxwZXJzLnBhcnNlVVJMKHVybCk7XG4gICAgaWYgKHBhcnNlZFVSTC51c2VybmFtZSAmJiBwYXJzZWRVUkwucGFzc3dvcmQpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLmF1dGhvcml6YXRpb24gPSAnQmFzaWMgJyArIGhlbHBlcnMuYnRvYShwYXJzZWRVUkwudXNlcm5hbWUgKyAnOicgKyBwYXJzZWRVUkwucGFzc3dvcmQpO1xuICAgIH1cbiAgICAvLyBXaGVuIGFsbCBub2RlIGNvcmUgaW1wbGVtZW50YXRpb25zIHRoYXQgZG8gbm90IGhhdmUgdGhlXG4gICAgLy8gV0hBVFdHIGNvbXBhdGlibGUgVVJMIHBhcnNlciBnbyBvdXQgb2Ygc2VydmljZSB0aGlzIGxpbmUgY2FuIGJlIHJlbW92ZWQuXG4gICAgaWYgKHBhcnNlZFVSTC5hdXRoKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5hdXRob3JpemF0aW9uID0gJ0Jhc2ljICcgKyBoZWxwZXJzLmJ0b2EocGFyc2VkVVJMLmF1dGgpO1xuICAgIH1cbiAgICAvLyBtYWtlIHByb3BlcnR5IGBjb25uZWN0ZWRgIHdoaWNoIHdpbGwgcmV0dXJuIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24gc3RhdHVzXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb25uZWN0ZWQnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbiAmJiB0aGlzLmNvbm5lY3Rpb24ucmVhZHlTdGF0ZSA9PT0gdGhpcy5jb25uZWN0aW9uLk9QRU47XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmNvbm5lY3QoKTtcbn07XG4vLyBJbmhlcml0IGZyb20gRXZlbnRFbWl0dGVyXG5XZWJzb2NrZXRQcm92aWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuV2Vic29ja2V0UHJvdmlkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gV2Vic29ja2V0UHJvdmlkZXI7XG4vKipcbiAqIENvbm5lY3RzIHRvIHRoZSBjb25maWd1cmVkIG5vZGVcbiAqXG4gKiBAbWV0aG9kIGNvbm5lY3RcbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuV2Vic29ja2V0UHJvdmlkZXIucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jb25uZWN0aW9uID0gbmV3IFdzKHRoaXMudXJsLCB0aGlzLnByb3RvY29sLCB1bmRlZmluZWQsIHRoaXMuaGVhZGVycywgdGhpcy5yZXF1ZXN0T3B0aW9ucywgdGhpcy5jbGllbnRDb25maWcpO1xuICAgIHRoaXMuX2FkZFNvY2tldExpc3RlbmVycygpO1xufTtcbi8qKlxuICogTGlzdGVuZXIgZm9yIHRoZSBgZGF0YWAgZXZlbnQgb2YgdGhlIHVuZGVybHlpbmcgV2ViU29ja2V0IG9iamVjdFxuICpcbiAqIEBtZXRob2QgX29uTWVzc2FnZVxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5XZWJzb2NrZXRQcm92aWRlci5wcm90b3R5cGUuX29uTWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLl9wYXJzZVJlc3BvbnNlKCh0eXBlb2YgZS5kYXRhID09PSAnc3RyaW5nJykgPyBlLmRhdGEgOiAnJykuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXN1bHQubWV0aG9kICYmIHJlc3VsdC5tZXRob2QuaW5kZXhPZignX3N1YnNjcmlwdGlvbicpICE9PSAtMSkge1xuICAgICAgICAgICAgX3RoaXMuZW1pdChfdGhpcy5EQVRBLCByZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpZCA9IHJlc3VsdC5pZDtcbiAgICAgICAgLy8gZ2V0IHRoZSBpZCB3aGljaCBtYXRjaGVzIHRoZSByZXR1cm5lZCBpZFxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICAgICAgICBpZCA9IHJlc3VsdFswXS5pZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3RoaXMucmVzcG9uc2VRdWV1ZS5oYXMoaWQpKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucmVzcG9uc2VRdWV1ZS5nZXQoaWQpLmNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZXNwb25zZVF1ZXVlLmdldChpZCkuY2FsbGJhY2soZmFsc2UsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5yZXNwb25zZVF1ZXVlLmRlbGV0ZShpZCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG4vKipcbiAqIExpc3RlbmVyIGZvciB0aGUgYG9wZW5gIGV2ZW50IG9mIHRoZSB1bmRlcmx5aW5nIFdlYlNvY2tldCBvYmplY3RcbiAqXG4gKiBAbWV0aG9kIF9vbkNvbm5lY3RcbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuV2Vic29ja2V0UHJvdmlkZXIucHJvdG90eXBlLl9vbkNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbWl0KHRoaXMuQ09OTkVDVCk7XG4gICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9IDA7XG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5yZXF1ZXN0UXVldWUuc2l6ZSA+IDApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5yZXF1ZXN0UXVldWUuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVzdCwga2V5KSB7XG4gICAgICAgICAgICBfdGhpcy5zZW5kKHJlcXVlc3QucGF5bG9hZCwgcmVxdWVzdC5jYWxsYmFjayk7XG4gICAgICAgICAgICBfdGhpcy5yZXF1ZXN0UXVldWUuZGVsZXRlKGtleSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5XZWJzb2NrZXRQcm92aWRlci5wcm90b3R5cGUuX29uQ29ubmVjdEZhaWxlZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMuY29ubmVjdEZhaWxlZERlc2NyaXB0aW9uID0gZXZlbnQudG9TdHJpbmcoKS5zcGxpdCgnXFxuJylbMF07XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAodGhpcy5jb25uZWN0RmFpbGVkRGVzY3JpcHRpb24pIHtcbiAgICAgICAgZXZlbnQuZGVzY3JpcHRpb24gPSB0aGlzLmNvbm5lY3RGYWlsZWREZXNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5jb25uZWN0RmFpbGVkRGVzY3JpcHRpb24gPSBudWxsOyAvLyBjbGVhbiB0aGUgbWVzc2FnZSwgc28gaXQgd29uJ3QgYmUgdXNlZCBpbiB0aGUgbmV4dCBjb25uZWN0aW9uXG4gICAgfVxuICAgIGV2ZW50LmNvZGUgPSAxMDA2O1xuICAgIGV2ZW50LnJlYXNvbiA9ICdjb25uZWN0aW9uIGZhaWxlZCc7XG4gICAgaWYgKHRoaXMucmVjb25uZWN0T3B0aW9ucy5hdXRvICYmICghWzEwMDAsIDEwMDFdLmluY2x1ZGVzKGV2ZW50LmNvZGUpIHx8IGV2ZW50Lndhc0NsZWFuID09PSBmYWxzZSkpIHtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVtaXQodGhpcy5FUlJPUiwgZXZlbnQpO1xuICAgIGlmICh0aGlzLnJlcXVlc3RRdWV1ZS5zaXplID4gMCkge1xuICAgICAgICB0aGlzLnJlcXVlc3RRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXN0LCBrZXkpIHtcbiAgICAgICAgICAgIHJlcXVlc3QuY2FsbGJhY2soZXJyb3JzLkNvbm5lY3Rpb25Ob3RPcGVuRXJyb3IoZXZlbnQpKTtcbiAgICAgICAgICAgIF90aGlzLnJlcXVlc3RRdWV1ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnJlc3BvbnNlUXVldWUuc2l6ZSA+IDApIHtcbiAgICAgICAgdGhpcy5yZXNwb25zZVF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlc3QsIGtleSkge1xuICAgICAgICAgICAgcmVxdWVzdC5jYWxsYmFjayhlcnJvcnMuSW52YWxpZENvbm5lY3Rpb24oJ29uIFdTJywgZXZlbnQpKTtcbiAgICAgICAgICAgIF90aGlzLnJlc3BvbnNlUXVldWUuZGVsZXRlKGtleSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvL2NsZWFuIGNvbm5lY3Rpb24gb24gb3VyIG93blxuICAgIGlmICh0aGlzLmNvbm5lY3Rpb24uX2Nvbm5lY3Rpb24pIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLl9jb25uZWN0aW9uLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIH1cbiAgICB0aGlzLmNvbm5lY3Rpb24uX2NsaWVudC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmNvbm5lY3Rpb24uX3JlYWR5U3RhdGUgPSAzOyAvLyBzZXQgcmVhZHlTdGF0ZSB0byBDTE9TRURcbiAgICB0aGlzLmVtaXQodGhpcy5DTE9TRSwgZXZlbnQpO1xufTtcbi8qKlxuICogTGlzdGVuZXIgZm9yIHRoZSBgY2xvc2VgIGV2ZW50IG9mIHRoZSB1bmRlcmx5aW5nIFdlYlNvY2tldCBvYmplY3RcbiAqXG4gKiBAbWV0aG9kIF9vbkNsb3NlXG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbldlYnNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5fb25DbG9zZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKHRoaXMucmVjb25uZWN0T3B0aW9ucy5hdXRvICYmICghWzEwMDAsIDEwMDFdLmluY2x1ZGVzKGV2ZW50LmNvZGUpIHx8IGV2ZW50Lndhc0NsZWFuID09PSBmYWxzZSkpIHtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVtaXQodGhpcy5DTE9TRSwgZXZlbnQpO1xuICAgIGlmICh0aGlzLnJlcXVlc3RRdWV1ZS5zaXplID4gMCkge1xuICAgICAgICB0aGlzLnJlcXVlc3RRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXN0LCBrZXkpIHtcbiAgICAgICAgICAgIHJlcXVlc3QuY2FsbGJhY2soZXJyb3JzLkNvbm5lY3Rpb25Ob3RPcGVuRXJyb3IoZXZlbnQpKTtcbiAgICAgICAgICAgIF90aGlzLnJlcXVlc3RRdWV1ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnJlc3BvbnNlUXVldWUuc2l6ZSA+IDApIHtcbiAgICAgICAgdGhpcy5yZXNwb25zZVF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlc3QsIGtleSkge1xuICAgICAgICAgICAgcmVxdWVzdC5jYWxsYmFjayhlcnJvcnMuSW52YWxpZENvbm5lY3Rpb24oJ29uIFdTJywgZXZlbnQpKTtcbiAgICAgICAgICAgIF90aGlzLnJlc3BvbnNlUXVldWUuZGVsZXRlKGtleSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yZW1vdmVTb2NrZXRMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcbi8qKlxuICogV2lsbCBhZGQgdGhlIHJlcXVpcmVkIHNvY2tldCBsaXN0ZW5lcnNcbiAqXG4gKiBAbWV0aG9kIF9hZGRTb2NrZXRMaXN0ZW5lcnNcbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuV2Vic29ja2V0UHJvdmlkZXIucHJvdG90eXBlLl9hZGRTb2NrZXRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jb25uZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLl9vbk1lc3NhZ2UuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5jb25uZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoJ29wZW4nLCB0aGlzLl9vbkNvbm5lY3QuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5jb25uZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgdGhpcy5fb25DbG9zZS5iaW5kKHRoaXMpKTtcbiAgICBpZiAodGhpcy5jb25uZWN0aW9uLl9jbGllbnQpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLl9jbGllbnQucmVtb3ZlQWxsTGlzdGVuZXJzKCdjb25uZWN0RmFpbGVkJyk7IC8vT3ZlcnJpZGUgdGhlIGludGVybmFsIGxpc3RlbmVycywgc28gdGhleSBkb24ndCB0cmlnZ2VyIGEgYGNsb3NlYCBldmVudC4gV2Ugd2FudCB0byB0cmlnZ2VyIGBfb25DbG9zZWAgbWFudWFsbHkgd2l0aCBhIGRlc2NyaXB0aW9uLlxuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uX2NsaWVudC5vbignY29ubmVjdEZhaWxlZCcsIHRoaXMuX29uQ29ubmVjdEZhaWxlZC5iaW5kKHRoaXMpKTtcbiAgICB9XG59O1xuLyoqXG4gKiBXaWxsIHJlbW92ZSBhbGwgc29ja2V0IGxpc3RlbmVyc1xuICpcbiAqIEBtZXRob2QgX3JlbW92ZVNvY2tldExpc3RlbmVyc1xuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5XZWJzb2NrZXRQcm92aWRlci5wcm90b3R5cGUuX3JlbW92ZVNvY2tldExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNvbm5lY3Rpb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuX29uTWVzc2FnZSk7XG4gICAgdGhpcy5jb25uZWN0aW9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29wZW4nLCB0aGlzLl9vbkNvbm5lY3QpO1xuICAgIHRoaXMuY29ubmVjdGlvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjbG9zZScsIHRoaXMuX29uQ2xvc2UpO1xuICAgIGlmICh0aGlzLmNvbm5lY3Rpb24uX2Nvbm5lY3Rpb24pXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5fY2xpZW50LnJlbW92ZUxpc3RlbmVyKCdjb25uZWN0RmFpbGVkJywgdGhpcy5fb25Db25uZWN0RmFpbGVkKTtcbn07XG4vKipcbiAqIFdpbGwgcGFyc2UgdGhlIHJlc3BvbnNlIGFuZCBtYWtlIGFuIGFycmF5IG91dCBvZiBpdC5cbiAqXG4gKiBAbWV0aG9kIF9wYXJzZVJlc3BvbnNlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbldlYnNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5fcGFyc2VSZXNwb25zZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcywgcmV0dXJuVmFsdWVzID0gW107XG4gICAgLy8gREUtQ0hVTktFUlxuICAgIHZhciBkZWNodW5rZWREYXRhID0gZGF0YVxuICAgICAgICAucmVwbGFjZSgvXFx9W1xcblxccl0/XFx7L2csICd9fC0tfHsnKSAvLyB9e1xuICAgICAgICAucmVwbGFjZSgvXFx9XFxdW1xcblxccl0/XFxbXFx7L2csICd9XXwtLXxbeycpIC8vIH1dW3tcbiAgICAgICAgLnJlcGxhY2UoL1xcfVtcXG5cXHJdP1xcW1xcey9nLCAnfXwtLXxbeycpIC8vIH1be1xuICAgICAgICAucmVwbGFjZSgvXFx9XFxdW1xcblxccl0/XFx7L2csICd9XXwtLXx7JykgLy8gfV17XG4gICAgICAgIC5zcGxpdCgnfC0tfCcpO1xuICAgIGRlY2h1bmtlZERhdGEuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAvLyBwcmVwZW5kIHRoZSBsYXN0IGNodW5rXG4gICAgICAgIGlmIChfdGhpcy5sYXN0Q2h1bmspXG4gICAgICAgICAgICBkYXRhID0gX3RoaXMubGFzdENodW5rICsgZGF0YTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBfdGhpcy5sYXN0Q2h1bmsgPSBkYXRhO1xuICAgICAgICAgICAgLy8gc3RhcnQgdGltZW91dCB0byBjYW5jZWwgYWxsIHJlcXVlc3RzXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMubGFzdENodW5rVGltZW91dCk7XG4gICAgICAgICAgICBfdGhpcy5sYXN0Q2h1bmtUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnJlY29ubmVjdE9wdGlvbnMuYXV0byAmJiBfdGhpcy5yZWNvbm5lY3RPcHRpb25zLm9uVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KF90aGlzLkVSUk9SLCBlcnJvcnMuQ29ubmVjdGlvblRpbWVvdXQoX3RoaXMuX2N1c3RvbVRpbWVvdXQpKTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucmVxdWVzdFF1ZXVlLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlcXVlc3RRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXN0LCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuY2FsbGJhY2soZXJyb3JzLkNvbm5lY3Rpb25UaW1lb3V0KF90aGlzLl9jdXN0b21UaW1lb3V0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXF1ZXN0UXVldWUuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF90aGlzLl9jdXN0b21UaW1lb3V0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBjYW5jZWwgdGltZW91dCBhbmQgc2V0IGNodW5rIHRvIG51bGxcbiAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLmxhc3RDaHVua1RpbWVvdXQpO1xuICAgICAgICBfdGhpcy5sYXN0Q2h1bmsgPSBudWxsO1xuICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgcmV0dXJuVmFsdWVzLnB1c2gocmVzdWx0KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xufTtcbi8qKlxuICogRG9lcyBjaGVjayBpZiB0aGUgcHJvdmlkZXIgaXMgY29ubmVjdGluZyBhbmQgd2lsbCBhZGQgaXQgdG8gdGhlIHF1ZXVlIG9yIHdpbGwgc2VuZCBpdCBkaXJlY3RseVxuICpcbiAqIEBtZXRob2Qgc2VuZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5XZWJzb2NrZXRQcm92aWRlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGlkID0gcGF5bG9hZC5pZDtcbiAgICB2YXIgcmVxdWVzdCA9IHsgcGF5bG9hZDogcGF5bG9hZCwgY2FsbGJhY2s6IGNhbGxiYWNrIH07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGF5bG9hZCkpIHtcbiAgICAgICAgaWQgPSBwYXlsb2FkWzBdLmlkO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb25uZWN0aW9uLnJlYWR5U3RhdGUgPT09IHRoaXMuY29ubmVjdGlvbi5DT05ORUNUSU5HIHx8IHRoaXMucmVjb25uZWN0aW5nKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdFF1ZXVlLnNldChpZCwgcmVxdWVzdCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29ubmVjdGlvbi5yZWFkeVN0YXRlICE9PSB0aGlzLmNvbm5lY3Rpb24uT1BFTikge1xuICAgICAgICB0aGlzLnJlcXVlc3RRdWV1ZS5kZWxldGUoaWQpO1xuICAgICAgICB0aGlzLmVtaXQodGhpcy5FUlJPUiwgZXJyb3JzLkNvbm5lY3Rpb25Ob3RPcGVuRXJyb3IoKSk7XG4gICAgICAgIHJlcXVlc3QuY2FsbGJhY2soZXJyb3JzLkNvbm5lY3Rpb25Ob3RPcGVuRXJyb3IoKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZXNwb25zZVF1ZXVlLnNldChpZCwgcmVxdWVzdCk7XG4gICAgdGhpcy5yZXF1ZXN0UXVldWUuZGVsZXRlKGlkKTtcbiAgICB0cnkge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uc2VuZChKU09OLnN0cmluZ2lmeShyZXF1ZXN0LnBheWxvYWQpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlcXVlc3QuY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICBfdGhpcy5yZXNwb25zZVF1ZXVlLmRlbGV0ZShpZCk7XG4gICAgfVxufTtcbi8qKlxuICogUmVzZXRzIHRoZSBwcm92aWRlcnMsIGNsZWFycyBhbGwgY2FsbGJhY2tzXG4gKlxuICogQG1ldGhvZCByZXNldFxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5XZWJzb2NrZXRQcm92aWRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZXNwb25zZVF1ZXVlLmNsZWFyKCk7XG4gICAgdGhpcy5yZXF1ZXN0UXVldWUuY2xlYXIoKTtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHRoaXMuX3JlbW92ZVNvY2tldExpc3RlbmVycygpO1xuICAgIHRoaXMuX2FkZFNvY2tldExpc3RlbmVycygpO1xufTtcbi8qKlxuICogQ2xvc2VzIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24gd2l0aCB0aGUgZ2l2ZW4gY29kZSBhbmQgcmVhc29uIGFyZ3VtZW50c1xuICpcbiAqIEBtZXRob2QgZGlzY29ubmVjdFxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uXG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbldlYnNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKGNvZGUsIHJlYXNvbikge1xuICAgIHRoaXMuX3JlbW92ZVNvY2tldExpc3RlbmVycygpO1xuICAgIHRoaXMuY29ubmVjdGlvbi5jbG9zZShjb2RlIHx8IDEwMDAsIHJlYXNvbik7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBkZXNpcmVkIGJvb2xlYW4uXG4gKlxuICogQG1ldGhvZCBzdXBwb3J0c1N1YnNjcmlwdGlvbnNcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuV2Vic29ja2V0UHJvdmlkZXIucHJvdG90eXBlLnN1cHBvcnRzU3Vic2NyaXB0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbiAqIFJlbW92ZXMgdGhlIGxpc3RlbmVycyBhbmQgcmVjb25uZWN0cyB0byB0aGUgc29ja2V0LlxuICpcbiAqIEBtZXRob2QgcmVjb25uZWN0XG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbldlYnNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IHRydWU7XG4gICAgaWYgKHRoaXMucmVzcG9uc2VRdWV1ZS5zaXplID4gMCkge1xuICAgICAgICB0aGlzLnJlc3BvbnNlUXVldWUuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVzdCwga2V5KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlc3BvbnNlUXVldWUuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5jYWxsYmFjayhlcnJvcnMuUGVuZGluZ1JlcXVlc3RzT25SZWNvbm5lY3RpbmdFcnJvcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGVuY291bnRlcmVkIGluIHJlY29ubmVjdDogXCIsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnJlY29ubmVjdE9wdGlvbnMubWF4QXR0ZW1wdHMgfHxcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA8IHRoaXMucmVjb25uZWN0T3B0aW9ucy5tYXhBdHRlbXB0cykge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnJlY29ubmVjdEF0dGVtcHRzKys7XG4gICAgICAgICAgICBfdGhpcy5fcmVtb3ZlU29ja2V0TGlzdGVuZXJzKCk7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KF90aGlzLlJFQ09OTkVDVCwgX3RoaXMucmVjb25uZWN0QXR0ZW1wdHMpO1xuICAgICAgICAgICAgX3RoaXMuY29ubmVjdCgpO1xuICAgICAgICB9LCB0aGlzLnJlY29ubmVjdE9wdGlvbnMuZGVsYXkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW1pdCh0aGlzLkVSUk9SLCBlcnJvcnMuTWF4QXR0ZW1wdHNSZWFjaGVkT25SZWNvbm5lY3RpbmdFcnJvcigpKTtcbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgIGlmICh0aGlzLnJlcXVlc3RRdWV1ZS5zaXplID4gMCkge1xuICAgICAgICB0aGlzLnJlcXVlc3RRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXN0LCBrZXkpIHtcbiAgICAgICAgICAgIHJlcXVlc3QuY2FsbGJhY2soZXJyb3JzLk1heEF0dGVtcHRzUmVhY2hlZE9uUmVjb25uZWN0aW5nRXJyb3IoKSk7XG4gICAgICAgICAgICBfdGhpcy5yZXF1ZXN0UXVldWUuZGVsZXRlKGtleSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IFdlYnNvY2tldFByb3ZpZGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/web3-providers-ws/lib/index.js\n");

/***/ })

};
;