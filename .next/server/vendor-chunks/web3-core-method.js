"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/web3-core-method";
exports.ids = ["vendor-chunks/web3-core-method"];
exports.modules = {

/***/ "(ssr)/./node_modules/web3-core-method/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/web3-core-method/lib/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n/**\n * @file index.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @author Marek Kotewicz <marek@parity.io>\n * @date 2017\n */\n\nvar errors = (__webpack_require__(/*! web3-core-helpers */ \"(ssr)/./node_modules/web3-core-helpers/lib/index.js\").errors);\nvar formatters = (__webpack_require__(/*! web3-core-helpers */ \"(ssr)/./node_modules/web3-core-helpers/lib/index.js\").formatters);\nvar utils = __webpack_require__(/*! web3-utils */ \"(ssr)/./node_modules/web3-utils/lib/index.js\");\nvar promiEvent = __webpack_require__(/*! web3-core-promievent */ \"(ssr)/./node_modules/web3-core-promievent/lib/index.js\");\nvar Subscriptions = (__webpack_require__(/*! web3-core-subscriptions */ \"(ssr)/./node_modules/web3-core-subscriptions/lib/index.js\").subscriptions);\nvar EthersTransactionUtils = __webpack_require__(/*! @ethersproject/transactions */ \"(ssr)/./node_modules/@ethersproject/transactions/lib.esm/index.js\");\nvar Method = function Method(options) {\n    if (!options.call || !options.name) {\n        throw new Error('When creating a method you need to provide at least the \"name\" and \"call\" property.');\n    }\n    this.name = options.name;\n    this.call = options.call;\n    this.params = options.params || 0;\n    this.inputFormatter = options.inputFormatter;\n    this.outputFormatter = options.outputFormatter;\n    this.transformPayload = options.transformPayload;\n    this.extraFormatters = options.extraFormatters;\n    this.abiCoder = options.abiCoder; // Will be used to encode the revert reason string\n    this.requestManager = options.requestManager;\n    // reference to eth.accounts\n    this.accounts = options.accounts;\n    this.defaultBlock = options.defaultBlock || 'latest';\n    this.defaultAccount = options.defaultAccount || null;\n    this.transactionBlockTimeout = options.transactionBlockTimeout || 50;\n    this.transactionConfirmationBlocks = options.transactionConfirmationBlocks || 24;\n    this.transactionPollingTimeout = options.transactionPollingTimeout || 750;\n    this.transactionPollingInterval = options.transactionPollingInterval || 1000;\n    this.blockHeaderTimeout = options.blockHeaderTimeout || 10; // 10 seconds\n    this.defaultCommon = options.defaultCommon;\n    this.defaultChain = options.defaultChain;\n    this.defaultHardfork = options.defaultHardfork;\n    this.handleRevert = options.handleRevert;\n};\nMethod.prototype.setRequestManager = function (requestManager, accounts) {\n    this.requestManager = requestManager;\n    // reference to eth.accounts\n    if (accounts) {\n        this.accounts = accounts;\n    }\n};\nMethod.prototype.createFunction = function (requestManager, accounts) {\n    var func = this.buildCall();\n    Object.defineProperty(func, 'call', { configurable: true, writable: true, value: this.call });\n    this.setRequestManager(requestManager || this.requestManager, accounts || this.accounts);\n    return func;\n};\nMethod.prototype.attachToObject = function (obj) {\n    var func = this.buildCall();\n    Object.defineProperty(func, 'call', { configurable: true, writable: true, value: this.call });\n    var name = this.name.split('.');\n    if (name.length > 1) {\n        obj[name[0]] = obj[name[0]] || {};\n        obj[name[0]][name[1]] = func;\n    }\n    else {\n        obj[name[0]] = func;\n    }\n};\n/**\n * Should be used to determine name of the jsonrpc method based on arguments\n *\n * @method getCall\n * @param {Array} arguments\n * @return {String} name of jsonrpc method\n */\nMethod.prototype.getCall = function (args) {\n    return typeof this.call === 'function' ? this.call(args) : this.call;\n};\n/**\n * Should be used to extract callback from array of arguments. Modifies input param\n *\n * @method extractCallback\n * @param {Array} arguments\n * @return {Function|Null} callback, if exists\n */\nMethod.prototype.extractCallback = function (args) {\n    if (typeof (args[args.length - 1]) === 'function') {\n        return args.pop(); // modify the args array!\n    }\n};\n/**\n * Should be called to check if the number of arguments is correct\n *\n * @method validateArgs\n * @param {Array} arguments\n * @throws {Error} if it is not\n */\nMethod.prototype.validateArgs = function (args) {\n    if (args.length !== this.params) {\n        throw errors.InvalidNumberOfParams(args.length, this.params, this.name);\n    }\n};\n/**\n * Should be called to format input args of method\n *\n * @method formatInput\n * @param {Array}\n * @return {Array}\n */\nMethod.prototype.formatInput = function (args) {\n    var _this = this;\n    if (!this.inputFormatter) {\n        return args;\n    }\n    return this.inputFormatter.map(function (formatter, index) {\n        // bind this for defaultBlock, and defaultAccount\n        return formatter ? formatter.call(_this, args[index]) : args[index];\n    });\n};\n/**\n * Should be called to format output(result) of method\n *\n * @method formatOutput\n * @param {Object}\n * @return {Object}\n */\nMethod.prototype.formatOutput = function (result) {\n    var _this = this;\n    if (Array.isArray(result)) {\n        return result.map(function (res) {\n            return _this.outputFormatter && res ? _this.outputFormatter(res, this?.hexFormat) : res;\n        });\n    }\n    else {\n        return this.outputFormatter && result ? this.outputFormatter(result, this?.hexFormat) : result;\n    }\n};\n/**\n * Should create payload from given input args\n *\n * @method toPayload\n * @param {Array} args\n * @return {Object}\n */\nMethod.prototype.toPayload = function (args) {\n    var call = this.getCall(args);\n    var callback = this.extractCallback(args);\n    var params = this.formatInput(args);\n    this.validateArgs(params);\n    var payload = {\n        method: call,\n        params: params,\n        callback: callback\n    };\n    if (this.transformPayload) {\n        payload = this.transformPayload(payload);\n    }\n    return payload;\n};\nMethod.prototype._confirmTransaction = function (defer, result, payload) {\n    var method = this, promiseResolved = false, canUnsubscribe = true, timeoutCount = 0, confirmationCount = 0, intervalId = null, blockHeaderTimeoutId = null, lastBlock = null, receiptJSON = '', gasProvided = ((!!payload.params[0] && typeof payload.params[0] === 'object') && payload.params[0].gas) ? payload.params[0].gas : null, isContractDeployment = (!!payload.params[0] && typeof payload.params[0] === 'object') &&\n        payload.params[0].data &&\n        payload.params[0].from &&\n        !payload.params[0].to, hasBytecode = isContractDeployment && payload.params[0].data.length > 2;\n    // add custom send Methods\n    var _ethereumCalls = [\n        new Method({\n            name: 'getBlockByNumber',\n            call: 'eth_getBlockByNumber',\n            params: 2,\n            inputFormatter: [formatters.inputBlockNumberFormatter, function (val) {\n                    return !!val;\n                }],\n            outputFormatter: formatters.outputBlockFormatter\n        }),\n        new Method({\n            name: 'getTransactionReceipt',\n            call: 'eth_getTransactionReceipt',\n            params: 1,\n            inputFormatter: [null],\n            outputFormatter: formatters.outputTransactionReceiptFormatter\n        }),\n        new Method({\n            name: 'getCode',\n            call: 'eth_getCode',\n            params: 2,\n            inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]\n        }),\n        new Method({\n            name: 'getTransactionByHash',\n            call: 'eth_getTransactionByHash',\n            params: 1,\n            inputFormatter: [null],\n            outputFormatter: formatters.outputTransactionFormatter\n        }),\n        new Subscriptions({\n            name: 'subscribe',\n            type: 'eth',\n            subscriptions: {\n                'newBlockHeaders': {\n                    subscriptionName: 'newHeads',\n                    params: 0,\n                    outputFormatter: formatters.outputBlockFormatter\n                }\n            }\n        })\n    ];\n    // attach methods to this._ethereumCall\n    var _ethereumCall = {};\n    _ethereumCalls.forEach(mthd => {\n        mthd.attachToObject(_ethereumCall);\n        mthd.requestManager = method.requestManager; // assign rather than call setRequestManager()\n    });\n    // fire \"receipt\" and confirmation events and resolve after\n    var checkConfirmation = function (existingReceipt, isPolling, err, blockHeader, sub) {\n        if (!err) {\n            // create fake unsubscribe\n            if (!sub) {\n                sub = {\n                    unsubscribe: function () {\n                        clearInterval(intervalId);\n                        clearTimeout(blockHeaderTimeoutId);\n                    }\n                };\n            }\n            // if we have a valid receipt we don't need to send a request\n            return (existingReceipt ? promiEvent.resolve(existingReceipt) : _ethereumCall.getTransactionReceipt(result))\n                // catch error from requesting receipt\n                .catch(function (err) {\n                sub.unsubscribe();\n                promiseResolved = true;\n                utils._fireError({\n                    message: 'Failed to check for transaction receipt:',\n                    data: err\n                }, defer.eventEmitter, defer.reject);\n            })\n                // if CONFIRMATION listener exists check for confirmations, by setting canUnsubscribe = false\n                .then(async function (receipt) {\n                if (!receipt || !receipt.blockHash) {\n                    throw new Error('Receipt missing or blockHash null');\n                }\n                // apply extra formatters\n                if (method.extraFormatters && method.extraFormatters.receiptFormatter) {\n                    receipt = method.extraFormatters.receiptFormatter(receipt);\n                }\n                // check if confirmation listener exists\n                if (defer.eventEmitter.listeners('confirmation').length > 0) {\n                    var block;\n                    // If there was an immediately retrieved receipt, it's already\n                    // been confirmed by the direct call to checkConfirmation needed\n                    // for parity instant-seal\n                    if (existingReceipt === undefined || confirmationCount !== 0) {\n                        // Get latest block to emit with confirmation\n                        var latestBlock = await _ethereumCall.getBlockByNumber('latest');\n                        var latestBlockHash = latestBlock ? latestBlock.hash : null;\n                        if (isPolling) { // Check if actually a new block is existing on polling\n                            if (lastBlock) {\n                                block = await _ethereumCall.getBlockByNumber(lastBlock.number + 1);\n                                if (block) {\n                                    lastBlock = block;\n                                    defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n                                }\n                            }\n                            else {\n                                block = await _ethereumCall.getBlockByNumber(receipt.blockNumber);\n                                lastBlock = block;\n                                defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n                            }\n                        }\n                        else {\n                            defer.eventEmitter.emit('confirmation', confirmationCount, receipt, latestBlockHash);\n                        }\n                    }\n                    if ((isPolling && block) || !isPolling) {\n                        confirmationCount++;\n                    }\n                    canUnsubscribe = false;\n                    if (confirmationCount === method.transactionConfirmationBlocks + 1) { // add 1 so we account for conf 0\n                        sub.unsubscribe();\n                        defer.eventEmitter.removeAllListeners();\n                    }\n                }\n                return receipt;\n            })\n                // CHECK for CONTRACT DEPLOYMENT\n                .then(async function (receipt) {\n                if (isContractDeployment && !promiseResolved) {\n                    if (!receipt.contractAddress) {\n                        if (canUnsubscribe) {\n                            sub.unsubscribe();\n                            promiseResolved = true;\n                        }\n                        utils._fireError(errors.NoContractAddressFoundError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                        return;\n                    }\n                    var code;\n                    try {\n                        code = await _ethereumCall.getCode(receipt.contractAddress);\n                    }\n                    catch (err) {\n                        // ignore;\n                    }\n                    if (!code) {\n                        return;\n                    }\n                    // If deployment is status.true and there was a real\n                    // bytecode string, assume it was successful.\n                    var deploymentSuccess = receipt.status === true && hasBytecode;\n                    if (deploymentSuccess || code.length > 2) {\n                        defer.eventEmitter.emit('receipt', receipt);\n                        // if contract, return instance instead of receipt\n                        if (method.extraFormatters && method.extraFormatters.contractDeployFormatter) {\n                            defer.resolve(method.extraFormatters.contractDeployFormatter(receipt));\n                        }\n                        else {\n                            defer.resolve(receipt);\n                        }\n                        // need to remove listeners, as they aren't removed automatically when succesfull\n                        if (canUnsubscribe) {\n                            defer.eventEmitter.removeAllListeners();\n                        }\n                    }\n                    else {\n                        utils._fireError(errors.ContractCodeNotStoredError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                    }\n                    if (canUnsubscribe) {\n                        sub.unsubscribe();\n                    }\n                    promiseResolved = true;\n                }\n                return receipt;\n            })\n                // CHECK for normal tx check for receipt only\n                .then(async function (receipt) {\n                if (!isContractDeployment && !promiseResolved) {\n                    if (!receipt.outOfGas &&\n                        (!gasProvided || gasProvided !== receipt.gasUsed) &&\n                        (receipt.status === true || receipt.status === '0x1' || typeof receipt.status === 'undefined')) {\n                        defer.eventEmitter.emit('receipt', receipt);\n                        defer.resolve(receipt);\n                        // need to remove listeners, as they aren't removed automatically when succesfull\n                        if (canUnsubscribe) {\n                            defer.eventEmitter.removeAllListeners();\n                        }\n                    }\n                    else {\n                        receiptJSON = JSON.stringify(receipt, null, 2);\n                        if (receipt.status === false || receipt.status === '0x0') {\n                            try {\n                                var revertMessage = null;\n                                if (method.handleRevert &&\n                                    (method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction')) {\n                                    var txReplayOptions = payload.params[0];\n                                    // If send was raw, fetch the transaction and reconstitute the\n                                    // original params so they can be replayed with `eth_call`\n                                    if (method.call === 'eth_sendRawTransaction') {\n                                        var rawTransactionHex = payload.params[0];\n                                        var parsedTx = EthersTransactionUtils.parse(rawTransactionHex);\n                                        txReplayOptions = formatters.inputTransactionFormatter({\n                                            data: parsedTx.data,\n                                            to: parsedTx.to,\n                                            from: parsedTx.from,\n                                            gas: parsedTx.gasLimit.toHexString(),\n                                            gasPrice: parsedTx.gasPrice ? parsedTx.gasPrice.toHexString() : undefined,\n                                            value: parsedTx.value.toHexString()\n                                        });\n                                    }\n                                    // Get revert reason string with eth_call\n                                    revertMessage = await method.getRevertReason(txReplayOptions, receipt.blockNumber);\n                                    if (revertMessage) { // Only throw a revert error if a revert reason is existing\n                                        utils._fireError(errors.TransactionRevertInstructionError(revertMessage.reason, revertMessage.signature, receipt), defer.eventEmitter, defer.reject, null, receipt);\n                                    }\n                                    else {\n                                        throw false; // Throw false and let the try/catch statement handle the error correctly after\n                                    }\n                                }\n                                else {\n                                    throw false; // Throw false and let the try/catch statement handle the error correctly after\n                                }\n                            }\n                            catch (error) {\n                                // Throw an normal revert error if no revert reason is given or the detection of it is disabled\n                                utils._fireError(errors.TransactionRevertedWithoutReasonError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                            }\n                        }\n                        else {\n                            // Throw OOG if status is not existing and provided gas and used gas are equal\n                            utils._fireError(errors.TransactionOutOfGasError(receipt), defer.eventEmitter, defer.reject, null, receipt);\n                        }\n                    }\n                    if (canUnsubscribe) {\n                        sub.unsubscribe();\n                    }\n                    promiseResolved = true;\n                }\n            })\n                // time out the transaction if not mined after 50 blocks\n                .catch(function () {\n                timeoutCount++;\n                // check to see if we are http polling\n                if (!!isPolling) {\n                    // polling timeout is different than transactionBlockTimeout blocks since we are triggering every second\n                    if (timeoutCount - 1 >= method.transactionPollingTimeout) {\n                        sub.unsubscribe();\n                        promiseResolved = true;\n                        utils._fireError(errors.TransactionError('Transaction was not mined within ' + method.transactionPollingTimeout + ' seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n                    }\n                }\n                else {\n                    if (timeoutCount - 1 >= method.transactionBlockTimeout) {\n                        sub.unsubscribe();\n                        promiseResolved = true;\n                        utils._fireError(errors.TransactionError('Transaction was not mined within ' + method.transactionBlockTimeout + ' blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!'), defer.eventEmitter, defer.reject);\n                    }\n                }\n            });\n        }\n        else {\n            sub.unsubscribe();\n            promiseResolved = true;\n            utils._fireError({\n                message: 'Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.',\n                data: err\n            }, defer.eventEmitter, defer.reject);\n        }\n    };\n    // start watching for confirmation depending on the support features of the provider\n    var startWatching = function (existingReceipt) {\n        let blockHeaderArrived = false;\n        const startInterval = () => {\n            intervalId = setInterval(checkConfirmation.bind(null, existingReceipt, true), method.transactionPollingInterval);\n        };\n        // If provider do not support event subscription use polling\n        if (!this.requestManager.provider.on) {\n            return startInterval();\n        }\n        // Subscribe to new block headers to look for tx receipt\n        _ethereumCall.subscribe('newBlockHeaders', function (err, blockHeader, sub) {\n            blockHeaderArrived = true;\n            if (err || !blockHeader) {\n                // fall back to polling\n                return startInterval();\n            }\n            checkConfirmation(existingReceipt, false, err, blockHeader, sub);\n        });\n        // Fallback to polling if tx receipt didn't arrived in \"blockHeaderTimeout\" [10 seconds]\n        blockHeaderTimeoutId = setTimeout(() => {\n            if (!blockHeaderArrived) {\n                startInterval();\n            }\n        }, this.blockHeaderTimeout * 1000);\n    }.bind(this);\n    // first check if we already have a confirmed transaction\n    _ethereumCall.getTransactionReceipt(result)\n        .then(function (receipt) {\n        if (receipt && receipt.blockHash) {\n            if (defer.eventEmitter.listeners('confirmation').length > 0) {\n                // We must keep on watching for new Blocks, if a confirmation listener is present\n                startWatching(receipt);\n            }\n            checkConfirmation(receipt, false);\n        }\n        else if (!promiseResolved) {\n            startWatching();\n        }\n    })\n        .catch(function () {\n        if (!promiseResolved)\n            startWatching();\n    });\n};\nvar getWallet = function (from, accounts) {\n    var wallet = null;\n    // is index given\n    if (typeof from === 'number') {\n        wallet = accounts.wallet[from];\n        // is account given\n    }\n    else if (!!from && typeof from === 'object' && from.address && from.privateKey) {\n        wallet = from;\n        // search in wallet for address\n    }\n    else {\n        wallet = accounts.wallet[from.toLowerCase()];\n    }\n    return wallet;\n};\nMethod.prototype.buildCall = function () {\n    var method = this, isSendTx = (method.call === 'eth_sendTransaction' || method.call === 'eth_sendRawTransaction'), // || method.call === 'personal_sendTransaction'\n    isCall = (method.call === 'eth_call');\n    // actual send function\n    var send = function () {\n        let args = Array.prototype.slice.call(arguments);\n        var defer = promiEvent(!isSendTx), payload = method.toPayload(args);\n        method.hexFormat = false;\n        if (method.call === 'eth_getTransactionReceipt'\n            || method.call === 'eth_getTransactionByHash'\n            || method.name === 'getBlock') {\n            method.hexFormat = (payload.params.length < args.length && args[args.length - 1] === 'hex');\n        }\n        // CALLBACK function\n        var sendTxCallback = function (err, result) {\n            if (method.handleRevert && isCall && method.abiCoder) {\n                var reasonData;\n                // Ganache / Geth <= 1.9.13 return the reason data as a successful eth_call response\n                // Geth >= 1.9.15 attaches the reason data to an error object.\n                // Geth 1.9.14 is missing revert reason (https://github.com/ethereum/web3.js/issues/3520)\n                if (!err && method.isRevertReasonString(result)) {\n                    reasonData = result.substring(10);\n                }\n                else if (err && err.data) {\n                    // workaround embedded error details got from some providers like MetaMask\n                    if (typeof err.data === 'object') {\n                        // Ganache has no `originalError` sub-object unlike others\n                        var originalError = err.data.originalError ?? err.data;\n                        reasonData = originalError.data.substring(10);\n                    }\n                    else {\n                        reasonData = err.data.substring(10);\n                    }\n                }\n                if (reasonData) {\n                    var reason = method.abiCoder.decodeParameter('string', '0x' + reasonData);\n                    var signature = 'Error(String)';\n                    utils._fireError(errors.RevertInstructionError(reason, signature), defer.eventEmitter, defer.reject, payload.callback, {\n                        reason: reason,\n                        signature: signature\n                    });\n                    return;\n                }\n            }\n            try {\n                result = method.formatOutput(result);\n            }\n            catch (e) {\n                err = e;\n            }\n            if (result instanceof Error) {\n                err = result;\n            }\n            if (!err) {\n                if (payload.callback) {\n                    payload.callback(null, result);\n                }\n            }\n            else {\n                if (err.error) {\n                    err = err.error;\n                }\n                return utils._fireError(err, defer.eventEmitter, defer.reject, payload.callback);\n            }\n            // return PROMISE\n            if (!isSendTx) {\n                if (!err) {\n                    defer.resolve(result);\n                }\n                // return PROMIEVENT\n            }\n            else {\n                defer.eventEmitter.emit('transactionHash', result);\n                method._confirmTransaction(defer, result, payload);\n            }\n        };\n        // SENDS the SIGNED SIGNATURE\n        var sendSignedTx = function (sign) {\n            var signedPayload = { ...payload,\n                method: 'eth_sendRawTransaction',\n                params: [sign.rawTransaction]\n            };\n            method.requestManager.send(signedPayload, sendTxCallback);\n        };\n        var sendRequest = function (payload, method) {\n            if (method && method.accounts && method.accounts.wallet && method.accounts.wallet.length) {\n                var wallet;\n                // ETH_SENDTRANSACTION\n                if (payload.method === 'eth_sendTransaction') {\n                    var tx = payload.params[0];\n                    wallet = getWallet((!!tx && typeof tx === 'object') ? tx.from : null, method.accounts);\n                    // If wallet was found, sign tx, and send using sendRawTransaction\n                    if (wallet && wallet.privateKey) {\n                        var tx = JSON.parse(JSON.stringify(tx));\n                        delete tx.from;\n                        if (method.defaultChain && !tx.chain) {\n                            tx.chain = method.defaultChain;\n                        }\n                        if (method.defaultHardfork && !tx.hardfork) {\n                            tx.hardfork = method.defaultHardfork;\n                        }\n                        if (method.defaultCommon && !tx.common) {\n                            tx.common = method.defaultCommon;\n                        }\n                        method.accounts.signTransaction(tx, wallet.privateKey)\n                            .then(sendSignedTx)\n                            .catch(function (err) {\n                            if (typeof defer.eventEmitter.listeners === 'function' && defer.eventEmitter.listeners('error').length) {\n                                try {\n                                    defer.eventEmitter.emit('error', err);\n                                }\n                                catch (err) {\n                                    // Ignore userland error prevent it to bubble up within web3.\n                                }\n                                defer.eventEmitter.removeAllListeners();\n                                defer.eventEmitter.catch(function () {\n                                });\n                            }\n                            defer.reject(err);\n                        });\n                        return;\n                    }\n                    // ETH_SIGN\n                }\n                else if (payload.method === 'eth_sign') {\n                    var data = payload.params[1];\n                    wallet = getWallet(payload.params[0], method.accounts);\n                    // If wallet was found, sign tx, and send using sendRawTransaction\n                    if (wallet && wallet.privateKey) {\n                        var sign = method.accounts.sign(data, wallet.privateKey);\n                        if (payload.callback) {\n                            payload.callback(null, sign.signature);\n                        }\n                        defer.resolve(sign.signature);\n                        return;\n                    }\n                }\n            }\n            return method.requestManager.send(payload, sendTxCallback);\n        };\n        const hasSendTxObject = isSendTx\n            && !!payload.params[0]\n            && typeof payload.params[0] === 'object';\n        if (hasSendTxObject &&\n            payload.params[0].type === '0x1'\n            && typeof payload.params[0].accessList === 'undefined') {\n            payload.params[0].accessList = [];\n        }\n        // Send the actual transaction\n        if (hasSendTxObject\n            && (typeof payload.params[0].gasPrice === 'undefined'\n                && (typeof payload.params[0].maxPriorityFeePerGas === 'undefined'\n                    || typeof payload.params[0].maxFeePerGas === 'undefined'))) {\n            _handleTxPricing(method, payload.params[0]).then(txPricing => {\n                if (txPricing.gasPrice !== undefined) {\n                    payload.params[0].gasPrice = txPricing.gasPrice;\n                }\n                else if (txPricing.maxPriorityFeePerGas !== undefined\n                    && txPricing.maxFeePerGas !== undefined) {\n                    payload.params[0].maxPriorityFeePerGas = txPricing.maxPriorityFeePerGas;\n                    payload.params[0].maxFeePerGas = txPricing.maxFeePerGas;\n                }\n                if (isSendTx) {\n                    setTimeout(() => {\n                        defer.eventEmitter.emit('sending', payload);\n                    }, 0);\n                }\n                sendRequest(payload, method);\n            });\n        }\n        else {\n            if (isSendTx) {\n                setTimeout(() => {\n                    defer.eventEmitter.emit('sending', payload);\n                }, 0);\n            }\n            sendRequest(payload, method);\n        }\n        if (isSendTx) {\n            setTimeout(() => {\n                defer.eventEmitter.emit('sent', payload);\n            }, 0);\n        }\n        return defer.eventEmitter;\n    };\n    // necessary to attach things to the method\n    send.method = method;\n    // necessary for batch requests\n    send.request = this.request.bind(this);\n    return send;\n};\nfunction _handleTxPricing(method, tx) {\n    return new Promise((resolve, reject) => {\n        try {\n            var getBlockByNumber = (new Method({\n                name: 'getBlockByNumber',\n                call: 'eth_getBlockByNumber',\n                params: 2,\n                inputFormatter: [function (blockNumber) {\n                        return blockNumber ? utils.toHex(blockNumber) : 'latest';\n                    }, function () {\n                        return false;\n                    }]\n            })).createFunction(method.requestManager);\n            var getGasPrice = (new Method({\n                name: 'getGasPrice',\n                call: 'eth_gasPrice',\n                params: 0\n            })).createFunction(method.requestManager);\n            Promise.all([\n                getBlockByNumber(),\n                getGasPrice()\n            ]).then(responses => {\n                const [block, gasPrice] = responses;\n                if ((tx.type === '0x2' || tx.type === undefined) &&\n                    (block && block.baseFeePerGas)) {\n                    // The network supports EIP-1559\n                    // Taken from https://github.com/ethers-io/ethers.js/blob/ba6854bdd5a912fe873d5da494cb5c62c190adde/packages/abstract-provider/src.ts/index.ts#L230\n                    let maxPriorityFeePerGas, maxFeePerGas;\n                    if (tx.gasPrice) {\n                        // Using legacy gasPrice property on an eip-1559 network,\n                        // so use gasPrice as both fee properties\n                        maxPriorityFeePerGas = tx.gasPrice;\n                        maxFeePerGas = tx.gasPrice;\n                        delete tx.gasPrice;\n                    }\n                    else {\n                        maxPriorityFeePerGas = tx.maxPriorityFeePerGas || '0x9502F900'; // 2.5 Gwei\n                        maxFeePerGas = tx.maxFeePerGas ||\n                            utils.toHex(utils.toBN(block.baseFeePerGas)\n                                .mul(utils.toBN(2))\n                                .add(utils.toBN(maxPriorityFeePerGas)));\n                    }\n                    resolve({ maxFeePerGas, maxPriorityFeePerGas });\n                }\n                else {\n                    if (tx.maxPriorityFeePerGas || tx.maxFeePerGas)\n                        throw Error(\"Network doesn't support eip-1559\");\n                    resolve({ gasPrice });\n                }\n            });\n        }\n        catch (error) {\n            reject(error);\n        }\n    });\n}\n/**\n * Returns the revert reason string if existing or otherwise false.\n *\n * @method getRevertReason\n *\n * @param {Object} txOptions\n * @param {Number} blockNumber\n *\n * @returns {Promise<Boolean|String>}\n */\nMethod.prototype.getRevertReason = function (txOptions, blockNumber) {\n    var self = this;\n    return new Promise(function (resolve, reject) {\n        (new Method({\n            name: 'call',\n            call: 'eth_call',\n            params: 2,\n            abiCoder: self.abiCoder,\n            handleRevert: true\n        }))\n            .createFunction(self.requestManager)(txOptions, utils.numberToHex(blockNumber))\n            .then(function () {\n            resolve(false);\n        })\n            .catch(function (error) {\n            if (error.reason) {\n                resolve({\n                    reason: error.reason,\n                    signature: error.signature\n                });\n            }\n            else {\n                reject(error);\n            }\n        });\n    });\n};\n/**\n * Checks if the given hex string is a revert message from the EVM\n *\n * @method isRevertReasonString\n *\n * @param {String} data - Hex string prefixed with 0x\n *\n * @returns {Boolean}\n */\nMethod.prototype.isRevertReasonString = function (data) {\n    return typeof data === 'string' && ((data.length - 2) / 2) % 32 === 4 && data.substring(0, 10) === '0x08c379a0';\n};\n/**\n * Should be called to create the pure JSONRPC request which can be used in a batch request\n *\n * @method request\n * @return {Object} jsonrpc request\n */\nMethod.prototype.request = function () {\n    var payload = this.toPayload(Array.prototype.slice.call(arguments));\n    payload.format = this.formatOutput.bind(this);\n    return payload;\n};\nmodule.exports = Method;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViMy1jb3JlLW1ldGhvZC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhO0FBQ2IsYUFBYSw0R0FBbUM7QUFDaEQsaUJBQWlCLGdIQUF1QztBQUN4RCxZQUFZLG1CQUFPLENBQUMsZ0VBQVk7QUFDaEMsaUJBQWlCLG1CQUFPLENBQUMsb0ZBQXNCO0FBQy9DLG9CQUFvQiwrSEFBZ0Q7QUFDcEUsNkJBQTZCLG1CQUFPLENBQUMsc0dBQTZCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsc0RBQXNEO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsc0RBQXNEO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9DQUFvQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixVQUFVO0FBQ3hDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHBvcnRrZXkvbmV4dC1leGFtcGxlLy4vbm9kZV9tb2R1bGVzL3dlYjMtY29yZS1tZXRob2QvbGliL2luZGV4LmpzPzRiZjciXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKlxuICogQGZpbGUgaW5kZXguanNcbiAqIEBhdXRob3IgRmFiaWFuIFZvZ2Vsc3RlbGxlciA8ZmFiaWFuQGV0aGVyZXVtLm9yZz5cbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQHBhcml0eS5pbz5cbiAqIEBkYXRlIDIwMTdcbiAqL1xuJ3VzZSBzdHJpY3QnO1xudmFyIGVycm9ycyA9IHJlcXVpcmUoJ3dlYjMtY29yZS1oZWxwZXJzJykuZXJyb3JzO1xudmFyIGZvcm1hdHRlcnMgPSByZXF1aXJlKCd3ZWIzLWNvcmUtaGVscGVycycpLmZvcm1hdHRlcnM7XG52YXIgdXRpbHMgPSByZXF1aXJlKCd3ZWIzLXV0aWxzJyk7XG52YXIgcHJvbWlFdmVudCA9IHJlcXVpcmUoJ3dlYjMtY29yZS1wcm9taWV2ZW50Jyk7XG52YXIgU3Vic2NyaXB0aW9ucyA9IHJlcXVpcmUoJ3dlYjMtY29yZS1zdWJzY3JpcHRpb25zJykuc3Vic2NyaXB0aW9ucztcbnZhciBFdGhlcnNUcmFuc2FjdGlvblV0aWxzID0gcmVxdWlyZSgnQGV0aGVyc3Byb2plY3QvdHJhbnNhY3Rpb25zJyk7XG52YXIgTWV0aG9kID0gZnVuY3Rpb24gTWV0aG9kKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuY2FsbCB8fCAhb3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV2hlbiBjcmVhdGluZyBhIG1ldGhvZCB5b3UgbmVlZCB0byBwcm92aWRlIGF0IGxlYXN0IHRoZSBcIm5hbWVcIiBhbmQgXCJjYWxsXCIgcHJvcGVydHkuJyk7XG4gICAgfVxuICAgIHRoaXMubmFtZSA9IG9wdGlvbnMubmFtZTtcbiAgICB0aGlzLmNhbGwgPSBvcHRpb25zLmNhbGw7XG4gICAgdGhpcy5wYXJhbXMgPSBvcHRpb25zLnBhcmFtcyB8fCAwO1xuICAgIHRoaXMuaW5wdXRGb3JtYXR0ZXIgPSBvcHRpb25zLmlucHV0Rm9ybWF0dGVyO1xuICAgIHRoaXMub3V0cHV0Rm9ybWF0dGVyID0gb3B0aW9ucy5vdXRwdXRGb3JtYXR0ZXI7XG4gICAgdGhpcy50cmFuc2Zvcm1QYXlsb2FkID0gb3B0aW9ucy50cmFuc2Zvcm1QYXlsb2FkO1xuICAgIHRoaXMuZXh0cmFGb3JtYXR0ZXJzID0gb3B0aW9ucy5leHRyYUZvcm1hdHRlcnM7XG4gICAgdGhpcy5hYmlDb2RlciA9IG9wdGlvbnMuYWJpQ29kZXI7IC8vIFdpbGwgYmUgdXNlZCB0byBlbmNvZGUgdGhlIHJldmVydCByZWFzb24gc3RyaW5nXG4gICAgdGhpcy5yZXF1ZXN0TWFuYWdlciA9IG9wdGlvbnMucmVxdWVzdE1hbmFnZXI7XG4gICAgLy8gcmVmZXJlbmNlIHRvIGV0aC5hY2NvdW50c1xuICAgIHRoaXMuYWNjb3VudHMgPSBvcHRpb25zLmFjY291bnRzO1xuICAgIHRoaXMuZGVmYXVsdEJsb2NrID0gb3B0aW9ucy5kZWZhdWx0QmxvY2sgfHwgJ2xhdGVzdCc7XG4gICAgdGhpcy5kZWZhdWx0QWNjb3VudCA9IG9wdGlvbnMuZGVmYXVsdEFjY291bnQgfHwgbnVsbDtcbiAgICB0aGlzLnRyYW5zYWN0aW9uQmxvY2tUaW1lb3V0ID0gb3B0aW9ucy50cmFuc2FjdGlvbkJsb2NrVGltZW91dCB8fCA1MDtcbiAgICB0aGlzLnRyYW5zYWN0aW9uQ29uZmlybWF0aW9uQmxvY2tzID0gb3B0aW9ucy50cmFuc2FjdGlvbkNvbmZpcm1hdGlvbkJsb2NrcyB8fCAyNDtcbiAgICB0aGlzLnRyYW5zYWN0aW9uUG9sbGluZ1RpbWVvdXQgPSBvcHRpb25zLnRyYW5zYWN0aW9uUG9sbGluZ1RpbWVvdXQgfHwgNzUwO1xuICAgIHRoaXMudHJhbnNhY3Rpb25Qb2xsaW5nSW50ZXJ2YWwgPSBvcHRpb25zLnRyYW5zYWN0aW9uUG9sbGluZ0ludGVydmFsIHx8IDEwMDA7XG4gICAgdGhpcy5ibG9ja0hlYWRlclRpbWVvdXQgPSBvcHRpb25zLmJsb2NrSGVhZGVyVGltZW91dCB8fCAxMDsgLy8gMTAgc2Vjb25kc1xuICAgIHRoaXMuZGVmYXVsdENvbW1vbiA9IG9wdGlvbnMuZGVmYXVsdENvbW1vbjtcbiAgICB0aGlzLmRlZmF1bHRDaGFpbiA9IG9wdGlvbnMuZGVmYXVsdENoYWluO1xuICAgIHRoaXMuZGVmYXVsdEhhcmRmb3JrID0gb3B0aW9ucy5kZWZhdWx0SGFyZGZvcms7XG4gICAgdGhpcy5oYW5kbGVSZXZlcnQgPSBvcHRpb25zLmhhbmRsZVJldmVydDtcbn07XG5NZXRob2QucHJvdG90eXBlLnNldFJlcXVlc3RNYW5hZ2VyID0gZnVuY3Rpb24gKHJlcXVlc3RNYW5hZ2VyLCBhY2NvdW50cykge1xuICAgIHRoaXMucmVxdWVzdE1hbmFnZXIgPSByZXF1ZXN0TWFuYWdlcjtcbiAgICAvLyByZWZlcmVuY2UgdG8gZXRoLmFjY291bnRzXG4gICAgaWYgKGFjY291bnRzKSB7XG4gICAgICAgIHRoaXMuYWNjb3VudHMgPSBhY2NvdW50cztcbiAgICB9XG59O1xuTWV0aG9kLnByb3RvdHlwZS5jcmVhdGVGdW5jdGlvbiA9IGZ1bmN0aW9uIChyZXF1ZXN0TWFuYWdlciwgYWNjb3VudHMpIHtcbiAgICB2YXIgZnVuYyA9IHRoaXMuYnVpbGRDYWxsKCk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZ1bmMsICdjYWxsJywgeyBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdGhpcy5jYWxsIH0pO1xuICAgIHRoaXMuc2V0UmVxdWVzdE1hbmFnZXIocmVxdWVzdE1hbmFnZXIgfHwgdGhpcy5yZXF1ZXN0TWFuYWdlciwgYWNjb3VudHMgfHwgdGhpcy5hY2NvdW50cyk7XG4gICAgcmV0dXJuIGZ1bmM7XG59O1xuTWV0aG9kLnByb3RvdHlwZS5hdHRhY2hUb09iamVjdCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgZnVuYyA9IHRoaXMuYnVpbGRDYWxsKCk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZ1bmMsICdjYWxsJywgeyBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogdGhpcy5jYWxsIH0pO1xuICAgIHZhciBuYW1lID0gdGhpcy5uYW1lLnNwbGl0KCcuJyk7XG4gICAgaWYgKG5hbWUubGVuZ3RoID4gMSkge1xuICAgICAgICBvYmpbbmFtZVswXV0gPSBvYmpbbmFtZVswXV0gfHwge307XG4gICAgICAgIG9ialtuYW1lWzBdXVtuYW1lWzFdXSA9IGZ1bmM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvYmpbbmFtZVswXV0gPSBmdW5jO1xuICAgIH1cbn07XG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGRldGVybWluZSBuYW1lIG9mIHRoZSBqc29ucnBjIG1ldGhvZCBiYXNlZCBvbiBhcmd1bWVudHNcbiAqXG4gKiBAbWV0aG9kIGdldENhbGxcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3VtZW50c1xuICogQHJldHVybiB7U3RyaW5nfSBuYW1lIG9mIGpzb25ycGMgbWV0aG9kXG4gKi9cbk1ldGhvZC5wcm90b3R5cGUuZ2V0Q2FsbCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLmNhbGwgPT09ICdmdW5jdGlvbicgPyB0aGlzLmNhbGwoYXJncykgOiB0aGlzLmNhbGw7XG59O1xuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBleHRyYWN0IGNhbGxiYWNrIGZyb20gYXJyYXkgb2YgYXJndW1lbnRzLiBNb2RpZmllcyBpbnB1dCBwYXJhbVxuICpcbiAqIEBtZXRob2QgZXh0cmFjdENhbGxiYWNrXG4gKiBAcGFyYW0ge0FycmF5fSBhcmd1bWVudHNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufE51bGx9IGNhbGxiYWNrLCBpZiBleGlzdHNcbiAqL1xuTWV0aG9kLnByb3RvdHlwZS5leHRyYWN0Q2FsbGJhY2sgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIGlmICh0eXBlb2YgKGFyZ3NbYXJncy5sZW5ndGggLSAxXSkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3MucG9wKCk7IC8vIG1vZGlmeSB0aGUgYXJncyBhcnJheSFcbiAgICB9XG59O1xuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGNoZWNrIGlmIHRoZSBudW1iZXIgb2YgYXJndW1lbnRzIGlzIGNvcnJlY3RcbiAqXG4gKiBAbWV0aG9kIHZhbGlkYXRlQXJnc1xuICogQHBhcmFtIHtBcnJheX0gYXJndW1lbnRzXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgaXQgaXMgbm90XG4gKi9cbk1ldGhvZC5wcm90b3R5cGUudmFsaWRhdGVBcmdzID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggIT09IHRoaXMucGFyYW1zKSB7XG4gICAgICAgIHRocm93IGVycm9ycy5JbnZhbGlkTnVtYmVyT2ZQYXJhbXMoYXJncy5sZW5ndGgsIHRoaXMucGFyYW1zLCB0aGlzLm5hbWUpO1xuICAgIH1cbn07XG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZm9ybWF0IGlucHV0IGFyZ3Mgb2YgbWV0aG9kXG4gKlxuICogQG1ldGhvZCBmb3JtYXRJbnB1dFxuICogQHBhcmFtIHtBcnJheX1cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5NZXRob2QucHJvdG90eXBlLmZvcm1hdElucHV0ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmICghdGhpcy5pbnB1dEZvcm1hdHRlcikge1xuICAgICAgICByZXR1cm4gYXJncztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRGb3JtYXR0ZXIubWFwKGZ1bmN0aW9uIChmb3JtYXR0ZXIsIGluZGV4KSB7XG4gICAgICAgIC8vIGJpbmQgdGhpcyBmb3IgZGVmYXVsdEJsb2NrLCBhbmQgZGVmYXVsdEFjY291bnRcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlciA/IGZvcm1hdHRlci5jYWxsKF90aGlzLCBhcmdzW2luZGV4XSkgOiBhcmdzW2luZGV4XTtcbiAgICB9KTtcbn07XG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZm9ybWF0IG91dHB1dChyZXN1bHQpIG9mIG1ldGhvZFxuICpcbiAqIEBtZXRob2QgZm9ybWF0T3V0cHV0XG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuTWV0aG9kLnByb3RvdHlwZS5mb3JtYXRPdXRwdXQgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQubWFwKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5vdXRwdXRGb3JtYXR0ZXIgJiYgcmVzID8gX3RoaXMub3V0cHV0Rm9ybWF0dGVyKHJlcywgdGhpcz8uaGV4Rm9ybWF0KSA6IHJlcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5vdXRwdXRGb3JtYXR0ZXIgJiYgcmVzdWx0ID8gdGhpcy5vdXRwdXRGb3JtYXR0ZXIocmVzdWx0LCB0aGlzPy5oZXhGb3JtYXQpIDogcmVzdWx0O1xuICAgIH1cbn07XG4vKipcbiAqIFNob3VsZCBjcmVhdGUgcGF5bG9hZCBmcm9tIGdpdmVuIGlucHV0IGFyZ3NcbiAqXG4gKiBAbWV0aG9kIHRvUGF5bG9hZFxuICogQHBhcmFtIHtBcnJheX0gYXJnc1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5NZXRob2QucHJvdG90eXBlLnRvUGF5bG9hZCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgdmFyIGNhbGwgPSB0aGlzLmdldENhbGwoYXJncyk7XG4gICAgdmFyIGNhbGxiYWNrID0gdGhpcy5leHRyYWN0Q2FsbGJhY2soYXJncyk7XG4gICAgdmFyIHBhcmFtcyA9IHRoaXMuZm9ybWF0SW5wdXQoYXJncyk7XG4gICAgdGhpcy52YWxpZGF0ZUFyZ3MocGFyYW1zKTtcbiAgICB2YXIgcGF5bG9hZCA9IHtcbiAgICAgICAgbWV0aG9kOiBjYWxsLFxuICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gICAgfTtcbiAgICBpZiAodGhpcy50cmFuc2Zvcm1QYXlsb2FkKSB7XG4gICAgICAgIHBheWxvYWQgPSB0aGlzLnRyYW5zZm9ybVBheWxvYWQocGF5bG9hZCk7XG4gICAgfVxuICAgIHJldHVybiBwYXlsb2FkO1xufTtcbk1ldGhvZC5wcm90b3R5cGUuX2NvbmZpcm1UcmFuc2FjdGlvbiA9IGZ1bmN0aW9uIChkZWZlciwgcmVzdWx0LCBwYXlsb2FkKSB7XG4gICAgdmFyIG1ldGhvZCA9IHRoaXMsIHByb21pc2VSZXNvbHZlZCA9IGZhbHNlLCBjYW5VbnN1YnNjcmliZSA9IHRydWUsIHRpbWVvdXRDb3VudCA9IDAsIGNvbmZpcm1hdGlvbkNvdW50ID0gMCwgaW50ZXJ2YWxJZCA9IG51bGwsIGJsb2NrSGVhZGVyVGltZW91dElkID0gbnVsbCwgbGFzdEJsb2NrID0gbnVsbCwgcmVjZWlwdEpTT04gPSAnJywgZ2FzUHJvdmlkZWQgPSAoKCEhcGF5bG9hZC5wYXJhbXNbMF0gJiYgdHlwZW9mIHBheWxvYWQucGFyYW1zWzBdID09PSAnb2JqZWN0JykgJiYgcGF5bG9hZC5wYXJhbXNbMF0uZ2FzKSA/IHBheWxvYWQucGFyYW1zWzBdLmdhcyA6IG51bGwsIGlzQ29udHJhY3REZXBsb3ltZW50ID0gKCEhcGF5bG9hZC5wYXJhbXNbMF0gJiYgdHlwZW9mIHBheWxvYWQucGFyYW1zWzBdID09PSAnb2JqZWN0JykgJiZcbiAgICAgICAgcGF5bG9hZC5wYXJhbXNbMF0uZGF0YSAmJlxuICAgICAgICBwYXlsb2FkLnBhcmFtc1swXS5mcm9tICYmXG4gICAgICAgICFwYXlsb2FkLnBhcmFtc1swXS50bywgaGFzQnl0ZWNvZGUgPSBpc0NvbnRyYWN0RGVwbG95bWVudCAmJiBwYXlsb2FkLnBhcmFtc1swXS5kYXRhLmxlbmd0aCA+IDI7XG4gICAgLy8gYWRkIGN1c3RvbSBzZW5kIE1ldGhvZHNcbiAgICB2YXIgX2V0aGVyZXVtQ2FsbHMgPSBbXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2dldEJsb2NrQnlOdW1iZXInLFxuICAgICAgICAgICAgY2FsbDogJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJyxcbiAgICAgICAgICAgIHBhcmFtczogMixcbiAgICAgICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVycy5pbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIXZhbDtcbiAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdHRlcjogZm9ybWF0dGVycy5vdXRwdXRCbG9ja0Zvcm1hdHRlclxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZ2V0VHJhbnNhY3Rpb25SZWNlaXB0JyxcbiAgICAgICAgICAgIGNhbGw6ICdldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0JyxcbiAgICAgICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbbnVsbF0sXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IGZvcm1hdHRlcnMub3V0cHV0VHJhbnNhY3Rpb25SZWNlaXB0Rm9ybWF0dGVyXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdnZXRDb2RlJyxcbiAgICAgICAgICAgIGNhbGw6ICdldGhfZ2V0Q29kZScsXG4gICAgICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRBZGRyZXNzRm9ybWF0dGVyLCBmb3JtYXR0ZXJzLmlucHV0RGVmYXVsdEJsb2NrTnVtYmVyRm9ybWF0dGVyXVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZ2V0VHJhbnNhY3Rpb25CeUhhc2gnLFxuICAgICAgICAgICAgY2FsbDogJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaCcsXG4gICAgICAgICAgICBwYXJhbXM6IDEsXG4gICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogW251bGxdLFxuICAgICAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiBmb3JtYXR0ZXJzLm91dHB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgU3Vic2NyaXB0aW9ucyh7XG4gICAgICAgICAgICBuYW1lOiAnc3Vic2NyaWJlJyxcbiAgICAgICAgICAgIHR5cGU6ICdldGgnLFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uczoge1xuICAgICAgICAgICAgICAgICduZXdCbG9ja0hlYWRlcnMnOiB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbk5hbWU6ICduZXdIZWFkcycsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogMCxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiBmb3JtYXR0ZXJzLm91dHB1dEJsb2NrRm9ybWF0dGVyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIF07XG4gICAgLy8gYXR0YWNoIG1ldGhvZHMgdG8gdGhpcy5fZXRoZXJldW1DYWxsXG4gICAgdmFyIF9ldGhlcmV1bUNhbGwgPSB7fTtcbiAgICBfZXRoZXJldW1DYWxscy5mb3JFYWNoKG10aGQgPT4ge1xuICAgICAgICBtdGhkLmF0dGFjaFRvT2JqZWN0KF9ldGhlcmV1bUNhbGwpO1xuICAgICAgICBtdGhkLnJlcXVlc3RNYW5hZ2VyID0gbWV0aG9kLnJlcXVlc3RNYW5hZ2VyOyAvLyBhc3NpZ24gcmF0aGVyIHRoYW4gY2FsbCBzZXRSZXF1ZXN0TWFuYWdlcigpXG4gICAgfSk7XG4gICAgLy8gZmlyZSBcInJlY2VpcHRcIiBhbmQgY29uZmlybWF0aW9uIGV2ZW50cyBhbmQgcmVzb2x2ZSBhZnRlclxuICAgIHZhciBjaGVja0NvbmZpcm1hdGlvbiA9IGZ1bmN0aW9uIChleGlzdGluZ1JlY2VpcHQsIGlzUG9sbGluZywgZXJyLCBibG9ja0hlYWRlciwgc3ViKSB7XG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgZmFrZSB1bnN1YnNjcmliZVxuICAgICAgICAgICAgaWYgKCFzdWIpIHtcbiAgICAgICAgICAgICAgICBzdWIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGJsb2NrSGVhZGVyVGltZW91dElkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgdmFsaWQgcmVjZWlwdCB3ZSBkb24ndCBuZWVkIHRvIHNlbmQgYSByZXF1ZXN0XG4gICAgICAgICAgICByZXR1cm4gKGV4aXN0aW5nUmVjZWlwdCA/IHByb21pRXZlbnQucmVzb2x2ZShleGlzdGluZ1JlY2VpcHQpIDogX2V0aGVyZXVtQ2FsbC5nZXRUcmFuc2FjdGlvblJlY2VpcHQocmVzdWx0KSlcbiAgICAgICAgICAgICAgICAvLyBjYXRjaCBlcnJvciBmcm9tIHJlcXVlc3RpbmcgcmVjZWlwdFxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgcHJvbWlzZVJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB1dGlscy5fZmlyZUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ0ZhaWxlZCB0byBjaGVjayBmb3IgdHJhbnNhY3Rpb24gcmVjZWlwdDonLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBlcnJcbiAgICAgICAgICAgICAgICB9LCBkZWZlci5ldmVudEVtaXR0ZXIsIGRlZmVyLnJlamVjdCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC8vIGlmIENPTkZJUk1BVElPTiBsaXN0ZW5lciBleGlzdHMgY2hlY2sgZm9yIGNvbmZpcm1hdGlvbnMsIGJ5IHNldHRpbmcgY2FuVW5zdWJzY3JpYmUgPSBmYWxzZVxuICAgICAgICAgICAgICAgIC50aGVuKGFzeW5jIGZ1bmN0aW9uIChyZWNlaXB0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWNlaXB0IHx8ICFyZWNlaXB0LmJsb2NrSGFzaCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlY2VpcHQgbWlzc2luZyBvciBibG9ja0hhc2ggbnVsbCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhcHBseSBleHRyYSBmb3JtYXR0ZXJzXG4gICAgICAgICAgICAgICAgaWYgKG1ldGhvZC5leHRyYUZvcm1hdHRlcnMgJiYgbWV0aG9kLmV4dHJhRm9ybWF0dGVycy5yZWNlaXB0Rm9ybWF0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY2VpcHQgPSBtZXRob2QuZXh0cmFGb3JtYXR0ZXJzLnJlY2VpcHRGb3JtYXR0ZXIocmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGNvbmZpcm1hdGlvbiBsaXN0ZW5lciBleGlzdHNcbiAgICAgICAgICAgICAgICBpZiAoZGVmZXIuZXZlbnRFbWl0dGVyLmxpc3RlbmVycygnY29uZmlybWF0aW9uJykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmxvY2s7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBhbiBpbW1lZGlhdGVseSByZXRyaWV2ZWQgcmVjZWlwdCwgaXQncyBhbHJlYWR5XG4gICAgICAgICAgICAgICAgICAgIC8vIGJlZW4gY29uZmlybWVkIGJ5IHRoZSBkaXJlY3QgY2FsbCB0byBjaGVja0NvbmZpcm1hdGlvbiBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHBhcml0eSBpbnN0YW50LXNlYWxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nUmVjZWlwdCA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpcm1hdGlvbkNvdW50ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgbGF0ZXN0IGJsb2NrIHRvIGVtaXQgd2l0aCBjb25maXJtYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXRlc3RCbG9jayA9IGF3YWl0IF9ldGhlcmV1bUNhbGwuZ2V0QmxvY2tCeU51bWJlcignbGF0ZXN0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGF0ZXN0QmxvY2tIYXNoID0gbGF0ZXN0QmxvY2sgPyBsYXRlc3RCbG9jay5oYXNoIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1BvbGxpbmcpIHsgLy8gQ2hlY2sgaWYgYWN0dWFsbHkgYSBuZXcgYmxvY2sgaXMgZXhpc3Rpbmcgb24gcG9sbGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0QmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2sgPSBhd2FpdCBfZXRoZXJldW1DYWxsLmdldEJsb2NrQnlOdW1iZXIobGFzdEJsb2NrLm51bWJlciArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RCbG9jayA9IGJsb2NrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIuZXZlbnRFbWl0dGVyLmVtaXQoJ2NvbmZpcm1hdGlvbicsIGNvbmZpcm1hdGlvbkNvdW50LCByZWNlaXB0LCBsYXRlc3RCbG9ja0hhc2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9jayA9IGF3YWl0IF9ldGhlcmV1bUNhbGwuZ2V0QmxvY2tCeU51bWJlcihyZWNlaXB0LmJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEJsb2NrID0gYmxvY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLmV2ZW50RW1pdHRlci5lbWl0KCdjb25maXJtYXRpb24nLCBjb25maXJtYXRpb25Db3VudCwgcmVjZWlwdCwgbGF0ZXN0QmxvY2tIYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5ldmVudEVtaXR0ZXIuZW1pdCgnY29uZmlybWF0aW9uJywgY29uZmlybWF0aW9uQ291bnQsIHJlY2VpcHQsIGxhdGVzdEJsb2NrSGFzaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKChpc1BvbGxpbmcgJiYgYmxvY2spIHx8ICFpc1BvbGxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbkNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FuVW5zdWJzY3JpYmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvbkNvdW50ID09PSBtZXRob2QudHJhbnNhY3Rpb25Db25maXJtYXRpb25CbG9ja3MgKyAxKSB7IC8vIGFkZCAxIHNvIHdlIGFjY291bnQgZm9yIGNvbmYgMFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5ldmVudEVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY2VpcHQ7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC8vIENIRUNLIGZvciBDT05UUkFDVCBERVBMT1lNRU5UXG4gICAgICAgICAgICAgICAgLnRoZW4oYXN5bmMgZnVuY3Rpb24gKHJlY2VpcHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNDb250cmFjdERlcGxveW1lbnQgJiYgIXByb21pc2VSZXNvbHZlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlY2VpcHQuY29udHJhY3RBZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FuVW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdXRpbHMuX2ZpcmVFcnJvcihlcnJvcnMuTm9Db250cmFjdEFkZHJlc3NGb3VuZEVycm9yKHJlY2VpcHQpLCBkZWZlci5ldmVudEVtaXR0ZXIsIGRlZmVyLnJlamVjdCwgbnVsbCwgcmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGU7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gYXdhaXQgX2V0aGVyZXVtQ2FsbC5nZXRDb2RlKHJlY2VpcHQuY29udHJhY3RBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgZGVwbG95bWVudCBpcyBzdGF0dXMudHJ1ZSBhbmQgdGhlcmUgd2FzIGEgcmVhbFxuICAgICAgICAgICAgICAgICAgICAvLyBieXRlY29kZSBzdHJpbmcsIGFzc3VtZSBpdCB3YXMgc3VjY2Vzc2Z1bC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlcGxveW1lbnRTdWNjZXNzID0gcmVjZWlwdC5zdGF0dXMgPT09IHRydWUgJiYgaGFzQnl0ZWNvZGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXBsb3ltZW50U3VjY2VzcyB8fCBjb2RlLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLmV2ZW50RW1pdHRlci5lbWl0KCdyZWNlaXB0JywgcmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBjb250cmFjdCwgcmV0dXJuIGluc3RhbmNlIGluc3RlYWQgb2YgcmVjZWlwdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZC5leHRyYUZvcm1hdHRlcnMgJiYgbWV0aG9kLmV4dHJhRm9ybWF0dGVycy5jb250cmFjdERlcGxveUZvcm1hdHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLnJlc29sdmUobWV0aG9kLmV4dHJhRm9ybWF0dGVycy5jb250cmFjdERlcGxveUZvcm1hdHRlcihyZWNlaXB0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5yZXNvbHZlKHJlY2VpcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byByZW1vdmUgbGlzdGVuZXJzLCBhcyB0aGV5IGFyZW4ndCByZW1vdmVkIGF1dG9tYXRpY2FsbHkgd2hlbiBzdWNjZXNmdWxsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FuVW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5ldmVudEVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1dGlscy5fZmlyZUVycm9yKGVycm9ycy5Db250cmFjdENvZGVOb3RTdG9yZWRFcnJvcihyZWNlaXB0KSwgZGVmZXIuZXZlbnRFbWl0dGVyLCBkZWZlci5yZWplY3QsIG51bGwsIHJlY2VpcHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYW5VbnN1YnNjcmliZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZVJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY2VpcHQ7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC8vIENIRUNLIGZvciBub3JtYWwgdHggY2hlY2sgZm9yIHJlY2VpcHQgb25seVxuICAgICAgICAgICAgICAgIC50aGVuKGFzeW5jIGZ1bmN0aW9uIChyZWNlaXB0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0NvbnRyYWN0RGVwbG95bWVudCAmJiAhcHJvbWlzZVJlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVjZWlwdC5vdXRPZkdhcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCFnYXNQcm92aWRlZCB8fCBnYXNQcm92aWRlZCAhPT0gcmVjZWlwdC5nYXNVc2VkKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHJlY2VpcHQuc3RhdHVzID09PSB0cnVlIHx8IHJlY2VpcHQuc3RhdHVzID09PSAnMHgxJyB8fCB0eXBlb2YgcmVjZWlwdC5zdGF0dXMgPT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIuZXZlbnRFbWl0dGVyLmVtaXQoJ3JlY2VpcHQnLCByZWNlaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLnJlc29sdmUocmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHJlbW92ZSBsaXN0ZW5lcnMsIGFzIHRoZXkgYXJlbid0IHJlbW92ZWQgYXV0b21hdGljYWxseSB3aGVuIHN1Y2Nlc2Z1bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW5VbnN1YnNjcmliZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLmV2ZW50RW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHRKU09OID0gSlNPTi5zdHJpbmdpZnkocmVjZWlwdCwgbnVsbCwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVjZWlwdC5zdGF0dXMgPT09IGZhbHNlIHx8IHJlY2VpcHQuc3RhdHVzID09PSAnMHgwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXZlcnRNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZC5oYW5kbGVSZXZlcnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtZXRob2QuY2FsbCA9PT0gJ2V0aF9zZW5kVHJhbnNhY3Rpb24nIHx8IG1ldGhvZC5jYWxsID09PSAnZXRoX3NlbmRSYXdUcmFuc2FjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHhSZXBsYXlPcHRpb25zID0gcGF5bG9hZC5wYXJhbXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBzZW5kIHdhcyByYXcsIGZldGNoIHRoZSB0cmFuc2FjdGlvbiBhbmQgcmVjb25zdGl0dXRlIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3JpZ2luYWwgcGFyYW1zIHNvIHRoZXkgY2FuIGJlIHJlcGxheWVkIHdpdGggYGV0aF9jYWxsYFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZC5jYWxsID09PSAnZXRoX3NlbmRSYXdUcmFuc2FjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3VHJhbnNhY3Rpb25IZXggPSBwYXlsb2FkLnBhcmFtc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyc2VkVHggPSBFdGhlcnNUcmFuc2FjdGlvblV0aWxzLnBhcnNlKHJhd1RyYW5zYWN0aW9uSGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eFJlcGxheU9wdGlvbnMgPSBmb3JtYXR0ZXJzLmlucHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBwYXJzZWRUeC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogcGFyc2VkVHgudG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IHBhcnNlZFR4LmZyb20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhczogcGFyc2VkVHguZ2FzTGltaXQudG9IZXhTdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2FzUHJpY2U6IHBhcnNlZFR4Lmdhc1ByaWNlID8gcGFyc2VkVHguZ2FzUHJpY2UudG9IZXhTdHJpbmcoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHBhcnNlZFR4LnZhbHVlLnRvSGV4U3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCByZXZlcnQgcmVhc29uIHN0cmluZyB3aXRoIGV0aF9jYWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnRNZXNzYWdlID0gYXdhaXQgbWV0aG9kLmdldFJldmVydFJlYXNvbih0eFJlcGxheU9wdGlvbnMsIHJlY2VpcHQuYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldmVydE1lc3NhZ2UpIHsgLy8gT25seSB0aHJvdyBhIHJldmVydCBlcnJvciBpZiBhIHJldmVydCByZWFzb24gaXMgZXhpc3RpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlscy5fZmlyZUVycm9yKGVycm9ycy5UcmFuc2FjdGlvblJldmVydEluc3RydWN0aW9uRXJyb3IocmV2ZXJ0TWVzc2FnZS5yZWFzb24sIHJldmVydE1lc3NhZ2Uuc2lnbmF0dXJlLCByZWNlaXB0KSwgZGVmZXIuZXZlbnRFbWl0dGVyLCBkZWZlci5yZWplY3QsIG51bGwsIHJlY2VpcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZmFsc2U7IC8vIFRocm93IGZhbHNlIGFuZCBsZXQgdGhlIHRyeS9jYXRjaCBzdGF0ZW1lbnQgaGFuZGxlIHRoZSBlcnJvciBjb3JyZWN0bHkgYWZ0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGZhbHNlOyAvLyBUaHJvdyBmYWxzZSBhbmQgbGV0IHRoZSB0cnkvY2F0Y2ggc3RhdGVtZW50IGhhbmRsZSB0aGUgZXJyb3IgY29ycmVjdGx5IGFmdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRocm93IGFuIG5vcm1hbCByZXZlcnQgZXJyb3IgaWYgbm8gcmV2ZXJ0IHJlYXNvbiBpcyBnaXZlbiBvciB0aGUgZGV0ZWN0aW9uIG9mIGl0IGlzIGRpc2FibGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzLl9maXJlRXJyb3IoZXJyb3JzLlRyYW5zYWN0aW9uUmV2ZXJ0ZWRXaXRob3V0UmVhc29uRXJyb3IocmVjZWlwdCksIGRlZmVyLmV2ZW50RW1pdHRlciwgZGVmZXIucmVqZWN0LCBudWxsLCByZWNlaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaHJvdyBPT0cgaWYgc3RhdHVzIGlzIG5vdCBleGlzdGluZyBhbmQgcHJvdmlkZWQgZ2FzIGFuZCB1c2VkIGdhcyBhcmUgZXF1YWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlscy5fZmlyZUVycm9yKGVycm9ycy5UcmFuc2FjdGlvbk91dE9mR2FzRXJyb3IocmVjZWlwdCksIGRlZmVyLmV2ZW50RW1pdHRlciwgZGVmZXIucmVqZWN0LCBudWxsLCByZWNlaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuVW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2VSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAvLyB0aW1lIG91dCB0aGUgdHJhbnNhY3Rpb24gaWYgbm90IG1pbmVkIGFmdGVyIDUwIGJsb2Nrc1xuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dENvdW50Kys7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIHdlIGFyZSBodHRwIHBvbGxpbmdcbiAgICAgICAgICAgICAgICBpZiAoISFpc1BvbGxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcG9sbGluZyB0aW1lb3V0IGlzIGRpZmZlcmVudCB0aGFuIHRyYW5zYWN0aW9uQmxvY2tUaW1lb3V0IGJsb2NrcyBzaW5jZSB3ZSBhcmUgdHJpZ2dlcmluZyBldmVyeSBzZWNvbmRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVvdXRDb3VudCAtIDEgPj0gbWV0aG9kLnRyYW5zYWN0aW9uUG9sbGluZ1RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZVJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzLl9maXJlRXJyb3IoZXJyb3JzLlRyYW5zYWN0aW9uRXJyb3IoJ1RyYW5zYWN0aW9uIHdhcyBub3QgbWluZWQgd2l0aGluICcgKyBtZXRob2QudHJhbnNhY3Rpb25Qb2xsaW5nVGltZW91dCArICcgc2Vjb25kcywgcGxlYXNlIG1ha2Ugc3VyZSB5b3VyIHRyYW5zYWN0aW9uIHdhcyBwcm9wZXJseSBzZW50LiBCZSBhd2FyZSB0aGF0IGl0IG1pZ2h0IHN0aWxsIGJlIG1pbmVkIScpLCBkZWZlci5ldmVudEVtaXR0ZXIsIGRlZmVyLnJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0Q291bnQgLSAxID49IG1ldGhvZC50cmFuc2FjdGlvbkJsb2NrVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXRpbHMuX2ZpcmVFcnJvcihlcnJvcnMuVHJhbnNhY3Rpb25FcnJvcignVHJhbnNhY3Rpb24gd2FzIG5vdCBtaW5lZCB3aXRoaW4gJyArIG1ldGhvZC50cmFuc2FjdGlvbkJsb2NrVGltZW91dCArICcgYmxvY2tzLCBwbGVhc2UgbWFrZSBzdXJlIHlvdXIgdHJhbnNhY3Rpb24gd2FzIHByb3Blcmx5IHNlbnQuIEJlIGF3YXJlIHRoYXQgaXQgbWlnaHQgc3RpbGwgYmUgbWluZWQhJyksIGRlZmVyLmV2ZW50RW1pdHRlciwgZGVmZXIucmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICBwcm9taXNlUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdXRpbHMuX2ZpcmVFcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ0ZhaWxlZCB0byBzdWJzY3JpYmUgdG8gbmV3IG5ld0Jsb2NrSGVhZGVycyB0byBjb25maXJtIHRoZSB0cmFuc2FjdGlvbiByZWNlaXB0cy4nLFxuICAgICAgICAgICAgICAgIGRhdGE6IGVyclxuICAgICAgICAgICAgfSwgZGVmZXIuZXZlbnRFbWl0dGVyLCBkZWZlci5yZWplY3QpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBzdGFydCB3YXRjaGluZyBmb3IgY29uZmlybWF0aW9uIGRlcGVuZGluZyBvbiB0aGUgc3VwcG9ydCBmZWF0dXJlcyBvZiB0aGUgcHJvdmlkZXJcbiAgICB2YXIgc3RhcnRXYXRjaGluZyA9IGZ1bmN0aW9uIChleGlzdGluZ1JlY2VpcHQpIHtcbiAgICAgICAgbGV0IGJsb2NrSGVhZGVyQXJyaXZlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBzdGFydEludGVydmFsID0gKCkgPT4ge1xuICAgICAgICAgICAgaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKGNoZWNrQ29uZmlybWF0aW9uLmJpbmQobnVsbCwgZXhpc3RpbmdSZWNlaXB0LCB0cnVlKSwgbWV0aG9kLnRyYW5zYWN0aW9uUG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gSWYgcHJvdmlkZXIgZG8gbm90IHN1cHBvcnQgZXZlbnQgc3Vic2NyaXB0aW9uIHVzZSBwb2xsaW5nXG4gICAgICAgIGlmICghdGhpcy5yZXF1ZXN0TWFuYWdlci5wcm92aWRlci5vbikge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0SW50ZXJ2YWwoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gbmV3IGJsb2NrIGhlYWRlcnMgdG8gbG9vayBmb3IgdHggcmVjZWlwdFxuICAgICAgICBfZXRoZXJldW1DYWxsLnN1YnNjcmliZSgnbmV3QmxvY2tIZWFkZXJzJywgZnVuY3Rpb24gKGVyciwgYmxvY2tIZWFkZXIsIHN1Yikge1xuICAgICAgICAgICAgYmxvY2tIZWFkZXJBcnJpdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChlcnIgfHwgIWJsb2NrSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gZmFsbCBiYWNrIHRvIHBvbGxpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRJbnRlcnZhbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hlY2tDb25maXJtYXRpb24oZXhpc3RpbmdSZWNlaXB0LCBmYWxzZSwgZXJyLCBibG9ja0hlYWRlciwgc3ViKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIHBvbGxpbmcgaWYgdHggcmVjZWlwdCBkaWRuJ3QgYXJyaXZlZCBpbiBcImJsb2NrSGVhZGVyVGltZW91dFwiIFsxMCBzZWNvbmRzXVxuICAgICAgICBibG9ja0hlYWRlclRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFibG9ja0hlYWRlckFycml2ZWQpIHtcbiAgICAgICAgICAgICAgICBzdGFydEludGVydmFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMuYmxvY2tIZWFkZXJUaW1lb3V0ICogMTAwMCk7XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIC8vIGZpcnN0IGNoZWNrIGlmIHdlIGFscmVhZHkgaGF2ZSBhIGNvbmZpcm1lZCB0cmFuc2FjdGlvblxuICAgIF9ldGhlcmV1bUNhbGwuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHJlc3VsdClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlY2VpcHQpIHtcbiAgICAgICAgaWYgKHJlY2VpcHQgJiYgcmVjZWlwdC5ibG9ja0hhc2gpIHtcbiAgICAgICAgICAgIGlmIChkZWZlci5ldmVudEVtaXR0ZXIubGlzdGVuZXJzKCdjb25maXJtYXRpb24nKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgbXVzdCBrZWVwIG9uIHdhdGNoaW5nIGZvciBuZXcgQmxvY2tzLCBpZiBhIGNvbmZpcm1hdGlvbiBsaXN0ZW5lciBpcyBwcmVzZW50XG4gICAgICAgICAgICAgICAgc3RhcnRXYXRjaGluZyhyZWNlaXB0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoZWNrQ29uZmlybWF0aW9uKHJlY2VpcHQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghcHJvbWlzZVJlc29sdmVkKSB7XG4gICAgICAgICAgICBzdGFydFdhdGNoaW5nKCk7XG4gICAgICAgIH1cbiAgICB9KVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXByb21pc2VSZXNvbHZlZClcbiAgICAgICAgICAgIHN0YXJ0V2F0Y2hpbmcoKTtcbiAgICB9KTtcbn07XG52YXIgZ2V0V2FsbGV0ID0gZnVuY3Rpb24gKGZyb20sIGFjY291bnRzKSB7XG4gICAgdmFyIHdhbGxldCA9IG51bGw7XG4gICAgLy8gaXMgaW5kZXggZ2l2ZW5cbiAgICBpZiAodHlwZW9mIGZyb20gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHdhbGxldCA9IGFjY291bnRzLndhbGxldFtmcm9tXTtcbiAgICAgICAgLy8gaXMgYWNjb3VudCBnaXZlblxuICAgIH1cbiAgICBlbHNlIGlmICghIWZyb20gJiYgdHlwZW9mIGZyb20gPT09ICdvYmplY3QnICYmIGZyb20uYWRkcmVzcyAmJiBmcm9tLnByaXZhdGVLZXkpIHtcbiAgICAgICAgd2FsbGV0ID0gZnJvbTtcbiAgICAgICAgLy8gc2VhcmNoIGluIHdhbGxldCBmb3IgYWRkcmVzc1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgd2FsbGV0ID0gYWNjb3VudHMud2FsbGV0W2Zyb20udG9Mb3dlckNhc2UoKV07XG4gICAgfVxuICAgIHJldHVybiB3YWxsZXQ7XG59O1xuTWV0aG9kLnByb3RvdHlwZS5idWlsZENhbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1ldGhvZCA9IHRoaXMsIGlzU2VuZFR4ID0gKG1ldGhvZC5jYWxsID09PSAnZXRoX3NlbmRUcmFuc2FjdGlvbicgfHwgbWV0aG9kLmNhbGwgPT09ICdldGhfc2VuZFJhd1RyYW5zYWN0aW9uJyksIC8vIHx8IG1ldGhvZC5jYWxsID09PSAncGVyc29uYWxfc2VuZFRyYW5zYWN0aW9uJ1xuICAgIGlzQ2FsbCA9IChtZXRob2QuY2FsbCA9PT0gJ2V0aF9jYWxsJyk7XG4gICAgLy8gYWN0dWFsIHNlbmQgZnVuY3Rpb25cbiAgICB2YXIgc2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGV0IGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICB2YXIgZGVmZXIgPSBwcm9taUV2ZW50KCFpc1NlbmRUeCksIHBheWxvYWQgPSBtZXRob2QudG9QYXlsb2FkKGFyZ3MpO1xuICAgICAgICBtZXRob2QuaGV4Rm9ybWF0ID0gZmFsc2U7XG4gICAgICAgIGlmIChtZXRob2QuY2FsbCA9PT0gJ2V0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHQnXG4gICAgICAgICAgICB8fCBtZXRob2QuY2FsbCA9PT0gJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaCdcbiAgICAgICAgICAgIHx8IG1ldGhvZC5uYW1lID09PSAnZ2V0QmxvY2snKSB7XG4gICAgICAgICAgICBtZXRob2QuaGV4Rm9ybWF0ID0gKHBheWxvYWQucGFyYW1zLmxlbmd0aCA8IGFyZ3MubGVuZ3RoICYmIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gJ2hleCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENBTExCQUNLIGZ1bmN0aW9uXG4gICAgICAgIHZhciBzZW5kVHhDYWxsYmFjayA9IGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKG1ldGhvZC5oYW5kbGVSZXZlcnQgJiYgaXNDYWxsICYmIG1ldGhvZC5hYmlDb2Rlcikge1xuICAgICAgICAgICAgICAgIHZhciByZWFzb25EYXRhO1xuICAgICAgICAgICAgICAgIC8vIEdhbmFjaGUgLyBHZXRoIDw9IDEuOS4xMyByZXR1cm4gdGhlIHJlYXNvbiBkYXRhIGFzIGEgc3VjY2Vzc2Z1bCBldGhfY2FsbCByZXNwb25zZVxuICAgICAgICAgICAgICAgIC8vIEdldGggPj0gMS45LjE1IGF0dGFjaGVzIHRoZSByZWFzb24gZGF0YSB0byBhbiBlcnJvciBvYmplY3QuXG4gICAgICAgICAgICAgICAgLy8gR2V0aCAxLjkuMTQgaXMgbWlzc2luZyByZXZlcnQgcmVhc29uIChodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2ViMy5qcy9pc3N1ZXMvMzUyMClcbiAgICAgICAgICAgICAgICBpZiAoIWVyciAmJiBtZXRob2QuaXNSZXZlcnRSZWFzb25TdHJpbmcocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICByZWFzb25EYXRhID0gcmVzdWx0LnN1YnN0cmluZygxMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVyciAmJiBlcnIuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3b3JrYXJvdW5kIGVtYmVkZGVkIGVycm9yIGRldGFpbHMgZ290IGZyb20gc29tZSBwcm92aWRlcnMgbGlrZSBNZXRhTWFza1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVyci5kYXRhID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2FuYWNoZSBoYXMgbm8gYG9yaWdpbmFsRXJyb3JgIHN1Yi1vYmplY3QgdW5saWtlIG90aGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsRXJyb3IgPSBlcnIuZGF0YS5vcmlnaW5hbEVycm9yID8/IGVyci5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uRGF0YSA9IG9yaWdpbmFsRXJyb3IuZGF0YS5zdWJzdHJpbmcoMTApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uRGF0YSA9IGVyci5kYXRhLnN1YnN0cmluZygxMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlYXNvbkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlYXNvbiA9IG1ldGhvZC5hYmlDb2Rlci5kZWNvZGVQYXJhbWV0ZXIoJ3N0cmluZycsICcweCcgKyByZWFzb25EYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpZ25hdHVyZSA9ICdFcnJvcihTdHJpbmcpJztcbiAgICAgICAgICAgICAgICAgICAgdXRpbHMuX2ZpcmVFcnJvcihlcnJvcnMuUmV2ZXJ0SW5zdHJ1Y3Rpb25FcnJvcihyZWFzb24sIHNpZ25hdHVyZSksIGRlZmVyLmV2ZW50RW1pdHRlciwgZGVmZXIucmVqZWN0LCBwYXlsb2FkLmNhbGxiYWNrLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IHJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtZXRob2QuZm9ybWF0T3V0cHV0KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGVyciA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnIgPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQuY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGVyciA9IGVyci5lcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLl9maXJlRXJyb3IoZXJyLCBkZWZlci5ldmVudEVtaXR0ZXIsIGRlZmVyLnJlamVjdCwgcGF5bG9hZC5jYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZXR1cm4gUFJPTUlTRVxuICAgICAgICAgICAgaWYgKCFpc1NlbmRUeCkge1xuICAgICAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVyLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIFBST01JRVZFTlRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlZmVyLmV2ZW50RW1pdHRlci5lbWl0KCd0cmFuc2FjdGlvbkhhc2gnLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIG1ldGhvZC5fY29uZmlybVRyYW5zYWN0aW9uKGRlZmVyLCByZXN1bHQsIHBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBTRU5EUyB0aGUgU0lHTkVEIFNJR05BVFVSRVxuICAgICAgICB2YXIgc2VuZFNpZ25lZFR4ID0gZnVuY3Rpb24gKHNpZ24pIHtcbiAgICAgICAgICAgIHZhciBzaWduZWRQYXlsb2FkID0geyAuLi5wYXlsb2FkLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9zZW5kUmF3VHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgICAgIHBhcmFtczogW3NpZ24ucmF3VHJhbnNhY3Rpb25dXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbWV0aG9kLnJlcXVlc3RNYW5hZ2VyLnNlbmQoc2lnbmVkUGF5bG9hZCwgc2VuZFR4Q2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgc2VuZFJlcXVlc3QgPSBmdW5jdGlvbiAocGF5bG9hZCwgbWV0aG9kKSB7XG4gICAgICAgICAgICBpZiAobWV0aG9kICYmIG1ldGhvZC5hY2NvdW50cyAmJiBtZXRob2QuYWNjb3VudHMud2FsbGV0ICYmIG1ldGhvZC5hY2NvdW50cy53YWxsZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHdhbGxldDtcbiAgICAgICAgICAgICAgICAvLyBFVEhfU0VORFRSQU5TQUNUSU9OXG4gICAgICAgICAgICAgICAgaWYgKHBheWxvYWQubWV0aG9kID09PSAnZXRoX3NlbmRUcmFuc2FjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR4ID0gcGF5bG9hZC5wYXJhbXNbMF07XG4gICAgICAgICAgICAgICAgICAgIHdhbGxldCA9IGdldFdhbGxldCgoISF0eCAmJiB0eXBlb2YgdHggPT09ICdvYmplY3QnKSA/IHR4LmZyb20gOiBudWxsLCBtZXRob2QuYWNjb3VudHMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3YWxsZXQgd2FzIGZvdW5kLCBzaWduIHR4LCBhbmQgc2VuZCB1c2luZyBzZW5kUmF3VHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKHdhbGxldCAmJiB3YWxsZXQucHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR4ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0eCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHR4LmZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kLmRlZmF1bHRDaGFpbiAmJiAhdHguY2hhaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5jaGFpbiA9IG1ldGhvZC5kZWZhdWx0Q2hhaW47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kLmRlZmF1bHRIYXJkZm9yayAmJiAhdHguaGFyZGZvcmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5oYXJkZm9yayA9IG1ldGhvZC5kZWZhdWx0SGFyZGZvcms7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kLmRlZmF1bHRDb21tb24gJiYgIXR4LmNvbW1vbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4LmNvbW1vbiA9IG1ldGhvZC5kZWZhdWx0Q29tbW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kLmFjY291bnRzLnNpZ25UcmFuc2FjdGlvbih0eCwgd2FsbGV0LnByaXZhdGVLZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oc2VuZFNpZ25lZFR4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWZlci5ldmVudEVtaXR0ZXIubGlzdGVuZXJzID09PSAnZnVuY3Rpb24nICYmIGRlZmVyLmV2ZW50RW1pdHRlci5saXN0ZW5lcnMoJ2Vycm9yJykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5ldmVudEVtaXR0ZXIuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSB1c2VybGFuZCBlcnJvciBwcmV2ZW50IGl0IHRvIGJ1YmJsZSB1cCB3aXRoaW4gd2ViMy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5ldmVudEVtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLmV2ZW50RW1pdHRlci5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEVUSF9TSUdOXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBheWxvYWQubWV0aG9kID09PSAnZXRoX3NpZ24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gcGF5bG9hZC5wYXJhbXNbMV07XG4gICAgICAgICAgICAgICAgICAgIHdhbGxldCA9IGdldFdhbGxldChwYXlsb2FkLnBhcmFtc1swXSwgbWV0aG9kLmFjY291bnRzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2FsbGV0IHdhcyBmb3VuZCwgc2lnbiB0eCwgYW5kIHNlbmQgdXNpbmcgc2VuZFJhd1RyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmICh3YWxsZXQgJiYgd2FsbGV0LnByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaWduID0gbWV0aG9kLmFjY291bnRzLnNpZ24oZGF0YSwgd2FsbGV0LnByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBheWxvYWQuY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLmNhbGxiYWNrKG51bGwsIHNpZ24uc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVyLnJlc29sdmUoc2lnbi5zaWduYXR1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5yZXF1ZXN0TWFuYWdlci5zZW5kKHBheWxvYWQsIHNlbmRUeENhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaGFzU2VuZFR4T2JqZWN0ID0gaXNTZW5kVHhcbiAgICAgICAgICAgICYmICEhcGF5bG9hZC5wYXJhbXNbMF1cbiAgICAgICAgICAgICYmIHR5cGVvZiBwYXlsb2FkLnBhcmFtc1swXSA9PT0gJ29iamVjdCc7XG4gICAgICAgIGlmIChoYXNTZW5kVHhPYmplY3QgJiZcbiAgICAgICAgICAgIHBheWxvYWQucGFyYW1zWzBdLnR5cGUgPT09ICcweDEnXG4gICAgICAgICAgICAmJiB0eXBlb2YgcGF5bG9hZC5wYXJhbXNbMF0uYWNjZXNzTGlzdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWQucGFyYW1zWzBdLmFjY2Vzc0xpc3QgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZW5kIHRoZSBhY3R1YWwgdHJhbnNhY3Rpb25cbiAgICAgICAgaWYgKGhhc1NlbmRUeE9iamVjdFxuICAgICAgICAgICAgJiYgKHR5cGVvZiBwYXlsb2FkLnBhcmFtc1swXS5nYXNQcmljZSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICAmJiAodHlwZW9mIHBheWxvYWQucGFyYW1zWzBdLm1heFByaW9yaXR5RmVlUGVyR2FzID09PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICAgICB8fCB0eXBlb2YgcGF5bG9hZC5wYXJhbXNbMF0ubWF4RmVlUGVyR2FzID09PSAndW5kZWZpbmVkJykpKSB7XG4gICAgICAgICAgICBfaGFuZGxlVHhQcmljaW5nKG1ldGhvZCwgcGF5bG9hZC5wYXJhbXNbMF0pLnRoZW4odHhQcmljaW5nID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHhQcmljaW5nLmdhc1ByaWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5wYXJhbXNbMF0uZ2FzUHJpY2UgPSB0eFByaWNpbmcuZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR4UHJpY2luZy5tYXhQcmlvcml0eUZlZVBlckdhcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICYmIHR4UHJpY2luZy5tYXhGZWVQZXJHYXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLnBhcmFtc1swXS5tYXhQcmlvcml0eUZlZVBlckdhcyA9IHR4UHJpY2luZy5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5wYXJhbXNbMF0ubWF4RmVlUGVyR2FzID0gdHhQcmljaW5nLm1heEZlZVBlckdhcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzU2VuZFR4KSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXIuZXZlbnRFbWl0dGVyLmVtaXQoJ3NlbmRpbmcnLCBwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbmRSZXF1ZXN0KHBheWxvYWQsIG1ldGhvZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc1NlbmRUeCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBkZWZlci5ldmVudEVtaXR0ZXIuZW1pdCgnc2VuZGluZycsIHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VuZFJlcXVlc3QocGF5bG9hZCwgbWV0aG9kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTZW5kVHgpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRlZmVyLmV2ZW50RW1pdHRlci5lbWl0KCdzZW50JywgcGF5bG9hZCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmZXIuZXZlbnRFbWl0dGVyO1xuICAgIH07XG4gICAgLy8gbmVjZXNzYXJ5IHRvIGF0dGFjaCB0aGluZ3MgdG8gdGhlIG1ldGhvZFxuICAgIHNlbmQubWV0aG9kID0gbWV0aG9kO1xuICAgIC8vIG5lY2Vzc2FyeSBmb3IgYmF0Y2ggcmVxdWVzdHNcbiAgICBzZW5kLnJlcXVlc3QgPSB0aGlzLnJlcXVlc3QuYmluZCh0aGlzKTtcbiAgICByZXR1cm4gc2VuZDtcbn07XG5mdW5jdGlvbiBfaGFuZGxlVHhQcmljaW5nKG1ldGhvZCwgdHgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGdldEJsb2NrQnlOdW1iZXIgPSAobmV3IE1ldGhvZCh7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2dldEJsb2NrQnlOdW1iZXInLFxuICAgICAgICAgICAgICAgIGNhbGw6ICdldGhfZ2V0QmxvY2tCeU51bWJlcicsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiAyLFxuICAgICAgICAgICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZnVuY3Rpb24gKGJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmxvY2tOdW1iZXIgPyB1dGlscy50b0hleChibG9ja051bWJlcikgOiAnbGF0ZXN0JztcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSkpLmNyZWF0ZUZ1bmN0aW9uKG1ldGhvZC5yZXF1ZXN0TWFuYWdlcik7XG4gICAgICAgICAgICB2YXIgZ2V0R2FzUHJpY2UgPSAobmV3IE1ldGhvZCh7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2dldEdhc1ByaWNlJyxcbiAgICAgICAgICAgICAgICBjYWxsOiAnZXRoX2dhc1ByaWNlJyxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IDBcbiAgICAgICAgICAgIH0pKS5jcmVhdGVGdW5jdGlvbihtZXRob2QucmVxdWVzdE1hbmFnZXIpO1xuICAgICAgICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIGdldEJsb2NrQnlOdW1iZXIoKSxcbiAgICAgICAgICAgICAgICBnZXRHYXNQcmljZSgpXG4gICAgICAgICAgICBdKS50aGVuKHJlc3BvbnNlcyA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2Jsb2NrLCBnYXNQcmljZV0gPSByZXNwb25zZXM7XG4gICAgICAgICAgICAgICAgaWYgKCh0eC50eXBlID09PSAnMHgyJyB8fCB0eC50eXBlID09PSB1bmRlZmluZWQpICYmXG4gICAgICAgICAgICAgICAgICAgIChibG9jayAmJiBibG9jay5iYXNlRmVlUGVyR2FzKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbmV0d29yayBzdXBwb3J0cyBFSVAtMTU1OVxuICAgICAgICAgICAgICAgICAgICAvLyBUYWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcnMtaW8vZXRoZXJzLmpzL2Jsb2IvYmE2ODU0YmRkNWE5MTJmZTg3M2Q1ZGE0OTRjYjVjNjJjMTkwYWRkZS9wYWNrYWdlcy9hYnN0cmFjdC1wcm92aWRlci9zcmMudHMvaW5kZXgudHMjTDIzMFxuICAgICAgICAgICAgICAgICAgICBsZXQgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIG1heEZlZVBlckdhcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lmdhc1ByaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2luZyBsZWdhY3kgZ2FzUHJpY2UgcHJvcGVydHkgb24gYW4gZWlwLTE1NTkgbmV0d29yayxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIHVzZSBnYXNQcmljZSBhcyBib3RoIGZlZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyA9IHR4Lmdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4RmVlUGVyR2FzID0gdHguZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdHguZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyA9IHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzIHx8ICcweDk1MDJGOTAwJzsgLy8gMi41IEd3ZWlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEZlZVBlckdhcyA9IHR4Lm1heEZlZVBlckdhcyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzLnRvSGV4KHV0aWxzLnRvQk4oYmxvY2suYmFzZUZlZVBlckdhcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm11bCh1dGlscy50b0JOKDIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkKHV0aWxzLnRvQk4obWF4UHJpb3JpdHlGZWVQZXJHYXMpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgfHwgdHgubWF4RmVlUGVyR2FzKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJOZXR3b3JrIGRvZXNuJ3Qgc3VwcG9ydCBlaXAtMTU1OVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IGdhc1ByaWNlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZXZlcnQgcmVhc29uIHN0cmluZyBpZiBleGlzdGluZyBvciBvdGhlcndpc2UgZmFsc2UuXG4gKlxuICogQG1ldGhvZCBnZXRSZXZlcnRSZWFzb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdHhPcHRpb25zXG4gKiBAcGFyYW0ge051bWJlcn0gYmxvY2tOdW1iZXJcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxCb29sZWFufFN0cmluZz59XG4gKi9cbk1ldGhvZC5wcm90b3R5cGUuZ2V0UmV2ZXJ0UmVhc29uID0gZnVuY3Rpb24gKHR4T3B0aW9ucywgYmxvY2tOdW1iZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgKG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2NhbGwnLFxuICAgICAgICAgICAgY2FsbDogJ2V0aF9jYWxsJyxcbiAgICAgICAgICAgIHBhcmFtczogMixcbiAgICAgICAgICAgIGFiaUNvZGVyOiBzZWxmLmFiaUNvZGVyLFxuICAgICAgICAgICAgaGFuZGxlUmV2ZXJ0OiB0cnVlXG4gICAgICAgIH0pKVxuICAgICAgICAgICAgLmNyZWF0ZUZ1bmN0aW9uKHNlbGYucmVxdWVzdE1hbmFnZXIpKHR4T3B0aW9ucywgdXRpbHMubnVtYmVyVG9IZXgoYmxvY2tOdW1iZXIpKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IucmVhc29uKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogZXJyb3IucmVhc29uLFxuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IGVycm9yLnNpZ25hdHVyZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGhleCBzdHJpbmcgaXMgYSByZXZlcnQgbWVzc2FnZSBmcm9tIHRoZSBFVk1cbiAqXG4gKiBAbWV0aG9kIGlzUmV2ZXJ0UmVhc29uU3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgLSBIZXggc3RyaW5nIHByZWZpeGVkIHdpdGggMHhcbiAqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuTWV0aG9kLnByb3RvdHlwZS5pc1JldmVydFJlYXNvblN0cmluZyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyAmJiAoKGRhdGEubGVuZ3RoIC0gMikgLyAyKSAlIDMyID09PSA0ICYmIGRhdGEuc3Vic3RyaW5nKDAsIDEwKSA9PT0gJzB4MDhjMzc5YTAnO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBjcmVhdGUgdGhlIHB1cmUgSlNPTlJQQyByZXF1ZXN0IHdoaWNoIGNhbiBiZSB1c2VkIGluIGEgYmF0Y2ggcmVxdWVzdFxuICpcbiAqIEBtZXRob2QgcmVxdWVzdFxuICogQHJldHVybiB7T2JqZWN0fSBqc29ucnBjIHJlcXVlc3RcbiAqL1xuTWV0aG9kLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXlsb2FkID0gdGhpcy50b1BheWxvYWQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgcGF5bG9hZC5mb3JtYXQgPSB0aGlzLmZvcm1hdE91dHB1dC5iaW5kKHRoaXMpO1xuICAgIHJldHVybiBwYXlsb2FkO1xufTtcbm1vZHVsZS5leHBvcnRzID0gTWV0aG9kO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/web3-core-method/lib/index.js\n");

/***/ })

};
;