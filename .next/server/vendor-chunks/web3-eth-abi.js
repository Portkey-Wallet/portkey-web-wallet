/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/web3-eth-abi";
exports.ids = ["vendor-chunks/web3-eth-abi"];
exports.modules = {

/***/ "(ssr)/./node_modules/web3-eth-abi/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/web3-eth-abi/lib/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n */\n/**\n * @file index.js\n * @author Marek Kotewicz <marek@parity.io>\n * @author Fabian Vogelsteller <fabian@frozeman.de>\n * @date 2018\n */\nvar Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\nvar utils = __webpack_require__(/*! web3-utils */ \"(ssr)/./node_modules/web3-utils/lib/index.js\");\nvar EthersAbiCoder = (__webpack_require__(/*! @ethersproject/abi */ \"(ssr)/./node_modules/@ethersproject/abi/lib.esm/index.js\").AbiCoder);\nvar ParamType = (__webpack_require__(/*! @ethersproject/abi */ \"(ssr)/./node_modules/@ethersproject/abi/lib.esm/index.js\").ParamType);\nvar ethersAbiCoder = new EthersAbiCoder(function (type, value) {\n    if (type.match(/^u?int/) && !Array.isArray(value) && (!(!!value && typeof value === 'object') || value.constructor.name !== 'BN')) {\n        return value.toString();\n    }\n    return value;\n});\n// result method\nfunction Result() {\n}\n/**\n * ABICoder prototype should be used to encode/decode solidity params of any type\n */\nvar ABICoder = function () {\n};\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeFunctionSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\nABICoder.prototype.encodeFunctionSignature = function (functionName) {\n    if (typeof functionName === 'function' || typeof functionName === 'object' && functionName) {\n        functionName = utils._jsonInterfaceMethodToString(functionName);\n    }\n    return utils.sha3(functionName).slice(0, 10);\n};\n/**\n * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.\n *\n * @method encodeEventSignature\n * @param {String|Object} functionName\n * @return {String} encoded function name\n */\nABICoder.prototype.encodeEventSignature = function (functionName) {\n    if (typeof functionName === 'function' || typeof functionName === 'object' && functionName) {\n        functionName = utils._jsonInterfaceMethodToString(functionName);\n    }\n    return utils.sha3(functionName);\n};\n/**\n * Should be used to encode plain param\n *\n * @method encodeParameter\n *\n * @param {String|Object} type\n * @param {any} param\n *\n * @return {String} encoded plain param\n */\nABICoder.prototype.encodeParameter = function (type, param) {\n    return this.encodeParameters([type], [param]);\n};\n/**\n * Should be used to encode list of params\n *\n * @method encodeParameters\n *\n * @param {Array<String|Object>} types\n * @param {Array<any>} params\n *\n * @return {String} encoded list of params\n */\nABICoder.prototype.encodeParameters = function (types, params) {\n    var self = this;\n    types = self.mapTypes(types);\n    params = params.map(function (param, index) {\n        let type = types[index];\n        if (typeof type === 'object' && type.type) {\n            // We may get a named type of shape {name, type}\n            type = type.type;\n        }\n        param = self.formatParam(type, param);\n        // Format params for tuples\n        if (typeof type === 'string' && type.includes('tuple')) {\n            const coder = ethersAbiCoder._getCoder(ParamType.from(type));\n            const modifyParams = (coder, param) => {\n                if (coder.name === 'array') {\n                    if (!coder.type.match(/\\[(\\d+)\\]/)) {\n                        return param.map(p => modifyParams(ethersAbiCoder._getCoder(ParamType.from(coder.type.replace('[]', ''))), p));\n                    }\n                    const arrayLength = parseInt(coder.type.match(/\\[(\\d+)\\]/)[1]);\n                    if (param.length !== arrayLength) {\n                        throw new Error('Array length does not matches with the given input');\n                    }\n                    return param.map(p => modifyParams(ethersAbiCoder._getCoder(ParamType.from(coder.type.replace(/\\[\\d+\\]/, ''))), p));\n                }\n                coder.coders.forEach((c, i) => {\n                    if (c.name === 'tuple') {\n                        modifyParams(c, param[i]);\n                    }\n                    else {\n                        param[i] = self.formatParam(c.name, param[i]);\n                    }\n                });\n            };\n            modifyParams(coder, param);\n        }\n        return param;\n    });\n    return ethersAbiCoder.encode(types, params);\n};\n/**\n * Map types if simplified format is used\n *\n * @method mapTypes\n * @param {Array} types\n * @return {Array}\n */\nABICoder.prototype.mapTypes = function (types) {\n    var self = this;\n    var mappedTypes = [];\n    types.forEach(function (type) {\n        // Remap `function` type params to bytes24 since Ethers does not\n        // recognize former type. Solidity docs say `Function` is a bytes24\n        // encoding the contract address followed by the function selector hash.\n        if (typeof type === 'object' && type.type === 'function') {\n            type = Object.assign({}, type, { type: \"bytes24\" });\n        }\n        if (self.isSimplifiedStructFormat(type)) {\n            var structName = Object.keys(type)[0];\n            mappedTypes.push(Object.assign(self.mapStructNameAndType(structName), {\n                components: self.mapStructToCoderFormat(type[structName])\n            }));\n            return;\n        }\n        mappedTypes.push(type);\n    });\n    return mappedTypes;\n};\n/**\n * Check if type is simplified struct format\n *\n * @method isSimplifiedStructFormat\n * @param {string | Object} type\n * @returns {boolean}\n */\nABICoder.prototype.isSimplifiedStructFormat = function (type) {\n    return typeof type === 'object' && typeof type.components === 'undefined' && typeof type.name === 'undefined';\n};\n/**\n * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\n *\n * @method mapStructNameAndType\n * @param {string} structName\n * @return {{type: string, name: *}}\n */\nABICoder.prototype.mapStructNameAndType = function (structName) {\n    var type = 'tuple';\n    if (structName.indexOf('[]') > -1) {\n        type = 'tuple[]';\n        structName = structName.slice(0, -2);\n    }\n    return { type: type, name: structName };\n};\n/**\n * Maps the simplified format in to the expected format of the ABICoder\n *\n * @method mapStructToCoderFormat\n * @param {Object} struct\n * @return {Array}\n */\nABICoder.prototype.mapStructToCoderFormat = function (struct) {\n    var self = this;\n    var components = [];\n    Object.keys(struct).forEach(function (key) {\n        if (typeof struct[key] === 'object') {\n            components.push(Object.assign(self.mapStructNameAndType(key), {\n                components: self.mapStructToCoderFormat(struct[key])\n            }));\n            return;\n        }\n        components.push({\n            name: key,\n            type: struct[key]\n        });\n    });\n    return components;\n};\n/**\n * Handle some formatting of params for backwards compatability with Ethers V4\n *\n * @method formatParam\n * @param {String} - type\n * @param {any} - param\n * @return {any} - The formatted param\n */\nABICoder.prototype.formatParam = function (type, param) {\n    const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\n    const paramTypeBytesArray = new RegExp(/^bytes([0-9]*)\\[\\]$/);\n    const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n    const paramTypeNumberArray = new RegExp(/^(u?int)([0-9]*)\\[\\]$/);\n    // Format BN to string\n    if (utils.isBN(param) || utils.isBigNumber(param)) {\n        return param.toString(10);\n    }\n    if (type.match(paramTypeBytesArray) || type.match(paramTypeNumberArray)) {\n        return param.map(p => this.formatParam(type.replace('[]', ''), p));\n    }\n    // Format correct width for u?int[0-9]*\n    let match = type.match(paramTypeNumber);\n    if (match) {\n        let size = parseInt(match[2] || \"256\");\n        if (size / 8 < param.length) {\n            param = param.startsWith(\"-\")\n                // pad to correct bit width, with - at the beginning\n                ? `-${utils.leftPad(param.substring(1), size)}`\n                // pad to correct bit width\n                : utils.leftPad(param, size);\n        }\n    }\n    // Format correct length for bytes[0-9]+\n    match = type.match(paramTypeBytes);\n    if (match) {\n        if (Buffer.isBuffer(param)) {\n            param = utils.toHex(param);\n        }\n        // format to correct length\n        let size = parseInt(match[1]);\n        if (size) {\n            let maxSize = size * 2;\n            if (param.substring(0, 2) === '0x') {\n                maxSize += 2;\n            }\n            if (param.length < maxSize) {\n                // pad to correct length\n                param = utils.rightPad(param, size * 2);\n            }\n        }\n        // format odd-length bytes to even-length\n        if (param.length % 2 === 1) {\n            param = '0x0' + param.substring(2);\n        }\n    }\n    return param;\n};\n/**\n * Encodes a function call from its json interface and parameters.\n *\n * @method encodeFunctionCall\n * @param {Array} jsonInterface\n * @param {Array} params\n * @return {String} The encoded ABI for this function call\n */\nABICoder.prototype.encodeFunctionCall = function (jsonInterface, params) {\n    return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface.inputs, params).replace('0x', '');\n};\n/**\n * Should be used to decode bytes to plain param\n *\n * @method decodeParameter\n * @param {String} type\n * @param {String} bytes\n * @return {Object} plain param\n */\nABICoder.prototype.decodeParameter = function (type, bytes) {\n    return this.decodeParameters([type], bytes)[0];\n};\n/**\n * Should be used to decode list of params\n *\n * @method decodeParameter\n * @param {Array} outputs\n * @param {String} bytes\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeParameters = function (outputs, bytes) {\n    return this.decodeParametersWith(outputs, bytes, false);\n};\n/**\n * Should be used to decode list of params\n *\n * @method decodeParameter\n * @param {Array} outputs\n * @param {String} bytes\n * @param {Boolean} loose\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeParametersWith = function (outputs, bytes, loose) {\n    if (outputs.length > 0 && (!bytes || bytes === '0x' || bytes === '0X')) {\n        throw new Error('Returned values aren\\'t valid, did it run Out of Gas? ' +\n            'You might also see this error if you are not using the ' +\n            'correct ABI for the contract you are retrieving data from, ' +\n            'requesting data from a block number that does not exist, ' +\n            'or querying a node which is not fully synced.');\n    }\n    var res = ethersAbiCoder.decode(this.mapTypes(outputs), '0x' + bytes.replace(/0x/i, ''), loose);\n    var returnValue = new Result();\n    returnValue.__length__ = 0;\n    outputs.forEach(function (output, i) {\n        var decodedValue = res[returnValue.__length__];\n        const isStringObject = typeof output === 'object' && output.type && output.type === 'string';\n        const isStringType = typeof output === 'string' && output === 'string';\n        // only convert `0x` to null if it's not string value\n        decodedValue = (decodedValue === '0x' && !isStringObject && !isStringType) ? null : decodedValue;\n        returnValue[i] = decodedValue;\n        if ((typeof output === 'function' || !!output && typeof output === 'object') && output.name) {\n            returnValue[output.name] = decodedValue;\n        }\n        returnValue.__length__++;\n    });\n    return returnValue;\n};\n/**\n * Decodes events non- and indexed parameters.\n *\n * @method decodeLog\n * @param {Object} inputs\n * @param {String} data\n * @param {Array} topics\n * @return {Array} array of plain params\n */\nABICoder.prototype.decodeLog = function (inputs, data, topics) {\n    var _this = this;\n    topics = Array.isArray(topics) ? topics : [topics];\n    data = data || '';\n    var notIndexedInputs = [];\n    var indexedParams = [];\n    var topicCount = 0;\n    // TODO check for anonymous logs?\n    inputs.forEach(function (input, i) {\n        if (input.indexed) {\n            indexedParams[i] = (['bool', 'int', 'uint', 'address', 'fixed', 'ufixed'].find(function (staticType) {\n                return input.type.indexOf(staticType) !== -1;\n            })) ? _this.decodeParameter(input.type, topics[topicCount]) : topics[topicCount];\n            topicCount++;\n        }\n        else {\n            notIndexedInputs[i] = input;\n        }\n    });\n    var nonIndexedData = data;\n    var notIndexedParams = (nonIndexedData) ? this.decodeParametersWith(notIndexedInputs, nonIndexedData, true) : [];\n    var returnValue = new Result();\n    returnValue.__length__ = 0;\n    inputs.forEach(function (res, i) {\n        returnValue[i] = (res.type === 'string') ? '' : null;\n        if (typeof notIndexedParams[i] !== 'undefined') {\n            returnValue[i] = notIndexedParams[i];\n        }\n        if (typeof indexedParams[i] !== 'undefined') {\n            returnValue[i] = indexedParams[i];\n        }\n        if (res.name) {\n            returnValue[res.name] = returnValue[i];\n        }\n        returnValue.__length__++;\n    });\n    return returnValue;\n};\nvar coder = new ABICoder();\nmodule.exports = coder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViMy1ldGgtYWJpL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvREFBd0I7QUFDckMsWUFBWSxtQkFBTyxDQUFDLGdFQUFZO0FBQ2hDLHFCQUFxQixvSEFBc0M7QUFDM0QsZ0JBQWdCLHFIQUF1QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsS0FBSztBQUNoQjtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQyxXQUFXLFlBQVk7QUFDdkI7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFVBQVUsaUJBQWlCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEIsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0NBQXdDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHBvcnRrZXkvbmV4dC1leGFtcGxlLy4vbm9kZV9tb2R1bGVzL3dlYjMtZXRoLWFiaS9saWIvaW5kZXguanM/ZDhmMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4gKi9cbi8qKlxuICogQGZpbGUgaW5kZXguanNcbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQHBhcml0eS5pbz5cbiAqIEBhdXRob3IgRmFiaWFuIFZvZ2Vsc3RlbGxlciA8ZmFiaWFuQGZyb3plbWFuLmRlPlxuICogQGRhdGUgMjAxOFxuICovXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnd2ViMy11dGlscycpO1xudmFyIEV0aGVyc0FiaUNvZGVyID0gcmVxdWlyZSgnQGV0aGVyc3Byb2plY3QvYWJpJykuQWJpQ29kZXI7XG52YXIgUGFyYW1UeXBlID0gcmVxdWlyZSgnQGV0aGVyc3Byb2plY3QvYWJpJykuUGFyYW1UeXBlO1xudmFyIGV0aGVyc0FiaUNvZGVyID0gbmV3IEV0aGVyc0FiaUNvZGVyKGZ1bmN0aW9uICh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlLm1hdGNoKC9edT9pbnQvKSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgKCEoISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lICE9PSAnQk4nKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufSk7XG4vLyByZXN1bHQgbWV0aG9kXG5mdW5jdGlvbiBSZXN1bHQoKSB7XG59XG4vKipcbiAqIEFCSUNvZGVyIHByb3RvdHlwZSBzaG91bGQgYmUgdXNlZCB0byBlbmNvZGUvZGVjb2RlIHNvbGlkaXR5IHBhcmFtcyBvZiBhbnkgdHlwZVxuICovXG52YXIgQUJJQ29kZXIgPSBmdW5jdGlvbiAoKSB7XG59O1xuLyoqXG4gKiBFbmNvZGVzIHRoZSBmdW5jdGlvbiBuYW1lIHRvIGl0cyBBQkkgcmVwcmVzZW50YXRpb24sIHdoaWNoIGFyZSB0aGUgZmlyc3QgNCBieXRlcyBvZiB0aGUgc2hhMyBvZiB0aGUgZnVuY3Rpb24gbmFtZSBpbmNsdWRpbmcgIHR5cGVzLlxuICpcbiAqIEBtZXRob2QgZW5jb2RlRnVuY3Rpb25TaWduYXR1cmVcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZnVuY3Rpb25OYW1lXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGVuY29kZWQgZnVuY3Rpb24gbmFtZVxuICovXG5BQklDb2Rlci5wcm90b3R5cGUuZW5jb2RlRnVuY3Rpb25TaWduYXR1cmUgPSBmdW5jdGlvbiAoZnVuY3Rpb25OYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBmdW5jdGlvbk5hbWUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGZ1bmN0aW9uTmFtZSA9PT0gJ29iamVjdCcgJiYgZnVuY3Rpb25OYW1lKSB7XG4gICAgICAgIGZ1bmN0aW9uTmFtZSA9IHV0aWxzLl9qc29uSW50ZXJmYWNlTWV0aG9kVG9TdHJpbmcoZnVuY3Rpb25OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHV0aWxzLnNoYTMoZnVuY3Rpb25OYW1lKS5zbGljZSgwLCAxMCk7XG59O1xuLyoqXG4gKiBFbmNvZGVzIHRoZSBmdW5jdGlvbiBuYW1lIHRvIGl0cyBBQkkgcmVwcmVzZW50YXRpb24sIHdoaWNoIGFyZSB0aGUgZmlyc3QgNCBieXRlcyBvZiB0aGUgc2hhMyBvZiB0aGUgZnVuY3Rpb24gbmFtZSBpbmNsdWRpbmcgIHR5cGVzLlxuICpcbiAqIEBtZXRob2QgZW5jb2RlRXZlbnRTaWduYXR1cmVcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZnVuY3Rpb25OYW1lXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGVuY29kZWQgZnVuY3Rpb24gbmFtZVxuICovXG5BQklDb2Rlci5wcm90b3R5cGUuZW5jb2RlRXZlbnRTaWduYXR1cmUgPSBmdW5jdGlvbiAoZnVuY3Rpb25OYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBmdW5jdGlvbk5hbWUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGZ1bmN0aW9uTmFtZSA9PT0gJ29iamVjdCcgJiYgZnVuY3Rpb25OYW1lKSB7XG4gICAgICAgIGZ1bmN0aW9uTmFtZSA9IHV0aWxzLl9qc29uSW50ZXJmYWNlTWV0aG9kVG9TdHJpbmcoZnVuY3Rpb25OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHV0aWxzLnNoYTMoZnVuY3Rpb25OYW1lKTtcbn07XG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGVuY29kZSBwbGFpbiBwYXJhbVxuICpcbiAqIEBtZXRob2QgZW5jb2RlUGFyYW1ldGVyXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB0eXBlXG4gKiBAcGFyYW0ge2FueX0gcGFyYW1cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGVuY29kZWQgcGxhaW4gcGFyYW1cbiAqL1xuQUJJQ29kZXIucHJvdG90eXBlLmVuY29kZVBhcmFtZXRlciA9IGZ1bmN0aW9uICh0eXBlLCBwYXJhbSkge1xuICAgIHJldHVybiB0aGlzLmVuY29kZVBhcmFtZXRlcnMoW3R5cGVdLCBbcGFyYW1dKTtcbn07XG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGVuY29kZSBsaXN0IG9mIHBhcmFtc1xuICpcbiAqIEBtZXRob2QgZW5jb2RlUGFyYW1ldGVyc1xuICpcbiAqIEBwYXJhbSB7QXJyYXk8U3RyaW5nfE9iamVjdD59IHR5cGVzXG4gKiBAcGFyYW0ge0FycmF5PGFueT59IHBhcmFtc1xuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZCBsaXN0IG9mIHBhcmFtc1xuICovXG5BQklDb2Rlci5wcm90b3R5cGUuZW5jb2RlUGFyYW1ldGVycyA9IGZ1bmN0aW9uICh0eXBlcywgcGFyYW1zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHR5cGVzID0gc2VsZi5tYXBUeXBlcyh0eXBlcyk7XG4gICAgcGFyYW1zID0gcGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0sIGluZGV4KSB7XG4gICAgICAgIGxldCB0eXBlID0gdHlwZXNbaW5kZXhdO1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUudHlwZSkge1xuICAgICAgICAgICAgLy8gV2UgbWF5IGdldCBhIG5hbWVkIHR5cGUgb2Ygc2hhcGUge25hbWUsIHR5cGV9XG4gICAgICAgICAgICB0eXBlID0gdHlwZS50eXBlO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtID0gc2VsZi5mb3JtYXRQYXJhbSh0eXBlLCBwYXJhbSk7XG4gICAgICAgIC8vIEZvcm1hdCBwYXJhbXMgZm9yIHR1cGxlc1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnICYmIHR5cGUuaW5jbHVkZXMoJ3R1cGxlJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVyID0gZXRoZXJzQWJpQ29kZXIuX2dldENvZGVyKFBhcmFtVHlwZS5mcm9tKHR5cGUpKTtcbiAgICAgICAgICAgIGNvbnN0IG1vZGlmeVBhcmFtcyA9IChjb2RlciwgcGFyYW0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZXIubmFtZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvZGVyLnR5cGUubWF0Y2goL1xcWyhcXGQrKVxcXS8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW0ubWFwKHAgPT4gbW9kaWZ5UGFyYW1zKGV0aGVyc0FiaUNvZGVyLl9nZXRDb2RlcihQYXJhbVR5cGUuZnJvbShjb2Rlci50eXBlLnJlcGxhY2UoJ1tdJywgJycpKSksIHApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcnJheUxlbmd0aCA9IHBhcnNlSW50KGNvZGVyLnR5cGUubWF0Y2goL1xcWyhcXGQrKVxcXS8pWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtLmxlbmd0aCAhPT0gYXJyYXlMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXJyYXkgbGVuZ3RoIGRvZXMgbm90IG1hdGNoZXMgd2l0aCB0aGUgZ2l2ZW4gaW5wdXQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW0ubWFwKHAgPT4gbW9kaWZ5UGFyYW1zKGV0aGVyc0FiaUNvZGVyLl9nZXRDb2RlcihQYXJhbVR5cGUuZnJvbShjb2Rlci50eXBlLnJlcGxhY2UoL1xcW1xcZCtcXF0vLCAnJykpKSwgcCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2Rlci5jb2RlcnMuZm9yRWFjaCgoYywgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYy5uYW1lID09PSAndHVwbGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZnlQYXJhbXMoYywgcGFyYW1baV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1baV0gPSBzZWxmLmZvcm1hdFBhcmFtKGMubmFtZSwgcGFyYW1baV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbW9kaWZ5UGFyYW1zKGNvZGVyLCBwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgIH0pO1xuICAgIHJldHVybiBldGhlcnNBYmlDb2Rlci5lbmNvZGUodHlwZXMsIHBhcmFtcyk7XG59O1xuLyoqXG4gKiBNYXAgdHlwZXMgaWYgc2ltcGxpZmllZCBmb3JtYXQgaXMgdXNlZFxuICpcbiAqIEBtZXRob2QgbWFwVHlwZXNcbiAqIEBwYXJhbSB7QXJyYXl9IHR5cGVzXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuQUJJQ29kZXIucHJvdG90eXBlLm1hcFR5cGVzID0gZnVuY3Rpb24gKHR5cGVzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBtYXBwZWRUeXBlcyA9IFtdO1xuICAgIHR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgLy8gUmVtYXAgYGZ1bmN0aW9uYCB0eXBlIHBhcmFtcyB0byBieXRlczI0IHNpbmNlIEV0aGVycyBkb2VzIG5vdFxuICAgICAgICAvLyByZWNvZ25pemUgZm9ybWVyIHR5cGUuIFNvbGlkaXR5IGRvY3Mgc2F5IGBGdW5jdGlvbmAgaXMgYSBieXRlczI0XG4gICAgICAgIC8vIGVuY29kaW5nIHRoZSBjb250cmFjdCBhZGRyZXNzIGZvbGxvd2VkIGJ5IHRoZSBmdW5jdGlvbiBzZWxlY3RvciBoYXNoLlxuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdHlwZSA9IE9iamVjdC5hc3NpZ24oe30sIHR5cGUsIHsgdHlwZTogXCJieXRlczI0XCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYuaXNTaW1wbGlmaWVkU3RydWN0Rm9ybWF0KHR5cGUpKSB7XG4gICAgICAgICAgICB2YXIgc3RydWN0TmFtZSA9IE9iamVjdC5rZXlzKHR5cGUpWzBdO1xuICAgICAgICAgICAgbWFwcGVkVHlwZXMucHVzaChPYmplY3QuYXNzaWduKHNlbGYubWFwU3RydWN0TmFtZUFuZFR5cGUoc3RydWN0TmFtZSksIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBzZWxmLm1hcFN0cnVjdFRvQ29kZXJGb3JtYXQodHlwZVtzdHJ1Y3ROYW1lXSlcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBtYXBwZWRUeXBlcy5wdXNoKHR5cGUpO1xuICAgIH0pO1xuICAgIHJldHVybiBtYXBwZWRUeXBlcztcbn07XG4vKipcbiAqIENoZWNrIGlmIHR5cGUgaXMgc2ltcGxpZmllZCBzdHJ1Y3QgZm9ybWF0XG4gKlxuICogQG1ldGhvZCBpc1NpbXBsaWZpZWRTdHJ1Y3RGb3JtYXRcbiAqIEBwYXJhbSB7c3RyaW5nIHwgT2JqZWN0fSB0eXBlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuQUJJQ29kZXIucHJvdG90eXBlLmlzU2ltcGxpZmllZFN0cnVjdEZvcm1hdCA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdHlwZS5jb21wb25lbnRzID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdHlwZS5uYW1lID09PSAndW5kZWZpbmVkJztcbn07XG4vKipcbiAqIE1hcHMgdGhlIGNvcnJlY3QgdHVwbGUgdHlwZSBhbmQgbmFtZSB3aGVuIHRoZSBzaW1wbGlmaWVkIGZvcm1hdCBpbiBlbmNvZGUvZGVjb2RlUGFyYW1ldGVyIGlzIHVzZWRcbiAqXG4gKiBAbWV0aG9kIG1hcFN0cnVjdE5hbWVBbmRUeXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RydWN0TmFtZVxuICogQHJldHVybiB7e3R5cGU6IHN0cmluZywgbmFtZTogKn19XG4gKi9cbkFCSUNvZGVyLnByb3RvdHlwZS5tYXBTdHJ1Y3ROYW1lQW5kVHlwZSA9IGZ1bmN0aW9uIChzdHJ1Y3ROYW1lKSB7XG4gICAgdmFyIHR5cGUgPSAndHVwbGUnO1xuICAgIGlmIChzdHJ1Y3ROYW1lLmluZGV4T2YoJ1tdJykgPiAtMSkge1xuICAgICAgICB0eXBlID0gJ3R1cGxlW10nO1xuICAgICAgICBzdHJ1Y3ROYW1lID0gc3RydWN0TmFtZS5zbGljZSgwLCAtMik7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IHR5cGUsIG5hbWU6IHN0cnVjdE5hbWUgfTtcbn07XG4vKipcbiAqIE1hcHMgdGhlIHNpbXBsaWZpZWQgZm9ybWF0IGluIHRvIHRoZSBleHBlY3RlZCBmb3JtYXQgb2YgdGhlIEFCSUNvZGVyXG4gKlxuICogQG1ldGhvZCBtYXBTdHJ1Y3RUb0NvZGVyRm9ybWF0XG4gKiBAcGFyYW0ge09iamVjdH0gc3RydWN0XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuQUJJQ29kZXIucHJvdG90eXBlLm1hcFN0cnVjdFRvQ29kZXJGb3JtYXQgPSBmdW5jdGlvbiAoc3RydWN0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjb21wb25lbnRzID0gW107XG4gICAgT2JqZWN0LmtleXMoc3RydWN0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHJ1Y3Rba2V5XSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChPYmplY3QuYXNzaWduKHNlbGYubWFwU3RydWN0TmFtZUFuZFR5cGUoa2V5KSwge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IHNlbGYubWFwU3RydWN0VG9Db2RlckZvcm1hdChzdHJ1Y3Rba2V5XSlcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb21wb25lbnRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAgICAgdHlwZTogc3RydWN0W2tleV1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbXBvbmVudHM7XG59O1xuLyoqXG4gKiBIYW5kbGUgc29tZSBmb3JtYXR0aW5nIG9mIHBhcmFtcyBmb3IgYmFja3dhcmRzIGNvbXBhdGFiaWxpdHkgd2l0aCBFdGhlcnMgVjRcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdFBhcmFtXG4gKiBAcGFyYW0ge1N0cmluZ30gLSB0eXBlXG4gKiBAcGFyYW0ge2FueX0gLSBwYXJhbVxuICogQHJldHVybiB7YW55fSAtIFRoZSBmb3JtYXR0ZWQgcGFyYW1cbiAqL1xuQUJJQ29kZXIucHJvdG90eXBlLmZvcm1hdFBhcmFtID0gZnVuY3Rpb24gKHR5cGUsIHBhcmFtKSB7XG4gICAgY29uc3QgcGFyYW1UeXBlQnl0ZXMgPSBuZXcgUmVnRXhwKC9eYnl0ZXMoWzAtOV0qKSQvKTtcbiAgICBjb25zdCBwYXJhbVR5cGVCeXRlc0FycmF5ID0gbmV3IFJlZ0V4cCgvXmJ5dGVzKFswLTldKilcXFtcXF0kLyk7XG4gICAgY29uc3QgcGFyYW1UeXBlTnVtYmVyID0gbmV3IFJlZ0V4cCgvXih1P2ludCkoWzAtOV0qKSQvKTtcbiAgICBjb25zdCBwYXJhbVR5cGVOdW1iZXJBcnJheSA9IG5ldyBSZWdFeHAoL14odT9pbnQpKFswLTldKilcXFtcXF0kLyk7XG4gICAgLy8gRm9ybWF0IEJOIHRvIHN0cmluZ1xuICAgIGlmICh1dGlscy5pc0JOKHBhcmFtKSB8fCB1dGlscy5pc0JpZ051bWJlcihwYXJhbSkpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtLnRvU3RyaW5nKDEwKTtcbiAgICB9XG4gICAgaWYgKHR5cGUubWF0Y2gocGFyYW1UeXBlQnl0ZXNBcnJheSkgfHwgdHlwZS5tYXRjaChwYXJhbVR5cGVOdW1iZXJBcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtLm1hcChwID0+IHRoaXMuZm9ybWF0UGFyYW0odHlwZS5yZXBsYWNlKCdbXScsICcnKSwgcCkpO1xuICAgIH1cbiAgICAvLyBGb3JtYXQgY29ycmVjdCB3aWR0aCBmb3IgdT9pbnRbMC05XSpcbiAgICBsZXQgbWF0Y2ggPSB0eXBlLm1hdGNoKHBhcmFtVHlwZU51bWJlcik7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGxldCBzaXplID0gcGFyc2VJbnQobWF0Y2hbMl0gfHwgXCIyNTZcIik7XG4gICAgICAgIGlmIChzaXplIC8gOCA8IHBhcmFtLmxlbmd0aCkge1xuICAgICAgICAgICAgcGFyYW0gPSBwYXJhbS5zdGFydHNXaXRoKFwiLVwiKVxuICAgICAgICAgICAgICAgIC8vIHBhZCB0byBjb3JyZWN0IGJpdCB3aWR0aCwgd2l0aCAtIGF0IHRoZSBiZWdpbm5pbmdcbiAgICAgICAgICAgICAgICA/IGAtJHt1dGlscy5sZWZ0UGFkKHBhcmFtLnN1YnN0cmluZygxKSwgc2l6ZSl9YFxuICAgICAgICAgICAgICAgIC8vIHBhZCB0byBjb3JyZWN0IGJpdCB3aWR0aFxuICAgICAgICAgICAgICAgIDogdXRpbHMubGVmdFBhZChwYXJhbSwgc2l6ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRm9ybWF0IGNvcnJlY3QgbGVuZ3RoIGZvciBieXRlc1swLTldK1xuICAgIG1hdGNoID0gdHlwZS5tYXRjaChwYXJhbVR5cGVCeXRlcyk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIocGFyYW0pKSB7XG4gICAgICAgICAgICBwYXJhbSA9IHV0aWxzLnRvSGV4KHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBmb3JtYXQgdG8gY29ycmVjdCBsZW5ndGhcbiAgICAgICAgbGV0IHNpemUgPSBwYXJzZUludChtYXRjaFsxXSk7XG4gICAgICAgIGlmIChzaXplKSB7XG4gICAgICAgICAgICBsZXQgbWF4U2l6ZSA9IHNpemUgKiAyO1xuICAgICAgICAgICAgaWYgKHBhcmFtLnN1YnN0cmluZygwLCAyKSA9PT0gJzB4Jykge1xuICAgICAgICAgICAgICAgIG1heFNpemUgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbS5sZW5ndGggPCBtYXhTaXplKSB7XG4gICAgICAgICAgICAgICAgLy8gcGFkIHRvIGNvcnJlY3QgbGVuZ3RoXG4gICAgICAgICAgICAgICAgcGFyYW0gPSB1dGlscy5yaWdodFBhZChwYXJhbSwgc2l6ZSAqIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGZvcm1hdCBvZGQtbGVuZ3RoIGJ5dGVzIHRvIGV2ZW4tbGVuZ3RoXG4gICAgICAgIGlmIChwYXJhbS5sZW5ndGggJSAyID09PSAxKSB7XG4gICAgICAgICAgICBwYXJhbSA9ICcweDAnICsgcGFyYW0uc3Vic3RyaW5nKDIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJhbTtcbn07XG4vKipcbiAqIEVuY29kZXMgYSBmdW5jdGlvbiBjYWxsIGZyb20gaXRzIGpzb24gaW50ZXJmYWNlIGFuZCBwYXJhbWV0ZXJzLlxuICpcbiAqIEBtZXRob2QgZW5jb2RlRnVuY3Rpb25DYWxsXG4gKiBAcGFyYW0ge0FycmF5fSBqc29uSW50ZXJmYWNlXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJhbXNcbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGVuY29kZWQgQUJJIGZvciB0aGlzIGZ1bmN0aW9uIGNhbGxcbiAqL1xuQUJJQ29kZXIucHJvdG90eXBlLmVuY29kZUZ1bmN0aW9uQ2FsbCA9IGZ1bmN0aW9uIChqc29uSW50ZXJmYWNlLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5lbmNvZGVGdW5jdGlvblNpZ25hdHVyZShqc29uSW50ZXJmYWNlKSArIHRoaXMuZW5jb2RlUGFyYW1ldGVycyhqc29uSW50ZXJmYWNlLmlucHV0cywgcGFyYW1zKS5yZXBsYWNlKCcweCcsICcnKTtcbn07XG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGRlY29kZSBieXRlcyB0byBwbGFpbiBwYXJhbVxuICpcbiAqIEBtZXRob2QgZGVjb2RlUGFyYW1ldGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IGJ5dGVzXG4gKiBAcmV0dXJuIHtPYmplY3R9IHBsYWluIHBhcmFtXG4gKi9cbkFCSUNvZGVyLnByb3RvdHlwZS5kZWNvZGVQYXJhbWV0ZXIgPSBmdW5jdGlvbiAodHlwZSwgYnl0ZXMpIHtcbiAgICByZXR1cm4gdGhpcy5kZWNvZGVQYXJhbWV0ZXJzKFt0eXBlXSwgYnl0ZXMpWzBdO1xufTtcbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZGVjb2RlIGxpc3Qgb2YgcGFyYW1zXG4gKlxuICogQG1ldGhvZCBkZWNvZGVQYXJhbWV0ZXJcbiAqIEBwYXJhbSB7QXJyYXl9IG91dHB1dHNcbiAqIEBwYXJhbSB7U3RyaW5nfSBieXRlc1xuICogQHJldHVybiB7QXJyYXl9IGFycmF5IG9mIHBsYWluIHBhcmFtc1xuICovXG5BQklDb2Rlci5wcm90b3R5cGUuZGVjb2RlUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChvdXRwdXRzLCBieXRlcykge1xuICAgIHJldHVybiB0aGlzLmRlY29kZVBhcmFtZXRlcnNXaXRoKG91dHB1dHMsIGJ5dGVzLCBmYWxzZSk7XG59O1xuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBkZWNvZGUgbGlzdCBvZiBwYXJhbXNcbiAqXG4gKiBAbWV0aG9kIGRlY29kZVBhcmFtZXRlclxuICogQHBhcmFtIHtBcnJheX0gb3V0cHV0c1xuICogQHBhcmFtIHtTdHJpbmd9IGJ5dGVzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGxvb3NlXG4gKiBAcmV0dXJuIHtBcnJheX0gYXJyYXkgb2YgcGxhaW4gcGFyYW1zXG4gKi9cbkFCSUNvZGVyLnByb3RvdHlwZS5kZWNvZGVQYXJhbWV0ZXJzV2l0aCA9IGZ1bmN0aW9uIChvdXRwdXRzLCBieXRlcywgbG9vc2UpIHtcbiAgICBpZiAob3V0cHV0cy5sZW5ndGggPiAwICYmICghYnl0ZXMgfHwgYnl0ZXMgPT09ICcweCcgfHwgYnl0ZXMgPT09ICcwWCcpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmV0dXJuZWQgdmFsdWVzIGFyZW5cXCd0IHZhbGlkLCBkaWQgaXQgcnVuIE91dCBvZiBHYXM/ICcgK1xuICAgICAgICAgICAgJ1lvdSBtaWdodCBhbHNvIHNlZSB0aGlzIGVycm9yIGlmIHlvdSBhcmUgbm90IHVzaW5nIHRoZSAnICtcbiAgICAgICAgICAgICdjb3JyZWN0IEFCSSBmb3IgdGhlIGNvbnRyYWN0IHlvdSBhcmUgcmV0cmlldmluZyBkYXRhIGZyb20sICcgK1xuICAgICAgICAgICAgJ3JlcXVlc3RpbmcgZGF0YSBmcm9tIGEgYmxvY2sgbnVtYmVyIHRoYXQgZG9lcyBub3QgZXhpc3QsICcgK1xuICAgICAgICAgICAgJ29yIHF1ZXJ5aW5nIGEgbm9kZSB3aGljaCBpcyBub3QgZnVsbHkgc3luY2VkLicpO1xuICAgIH1cbiAgICB2YXIgcmVzID0gZXRoZXJzQWJpQ29kZXIuZGVjb2RlKHRoaXMubWFwVHlwZXMob3V0cHV0cyksICcweCcgKyBieXRlcy5yZXBsYWNlKC8weC9pLCAnJyksIGxvb3NlKTtcbiAgICB2YXIgcmV0dXJuVmFsdWUgPSBuZXcgUmVzdWx0KCk7XG4gICAgcmV0dXJuVmFsdWUuX19sZW5ndGhfXyA9IDA7XG4gICAgb3V0cHV0cy5mb3JFYWNoKGZ1bmN0aW9uIChvdXRwdXQsIGkpIHtcbiAgICAgICAgdmFyIGRlY29kZWRWYWx1ZSA9IHJlc1tyZXR1cm5WYWx1ZS5fX2xlbmd0aF9fXTtcbiAgICAgICAgY29uc3QgaXNTdHJpbmdPYmplY3QgPSB0eXBlb2Ygb3V0cHV0ID09PSAnb2JqZWN0JyAmJiBvdXRwdXQudHlwZSAmJiBvdXRwdXQudHlwZSA9PT0gJ3N0cmluZyc7XG4gICAgICAgIGNvbnN0IGlzU3RyaW5nVHlwZSA9IHR5cGVvZiBvdXRwdXQgPT09ICdzdHJpbmcnICYmIG91dHB1dCA9PT0gJ3N0cmluZyc7XG4gICAgICAgIC8vIG9ubHkgY29udmVydCBgMHhgIHRvIG51bGwgaWYgaXQncyBub3Qgc3RyaW5nIHZhbHVlXG4gICAgICAgIGRlY29kZWRWYWx1ZSA9IChkZWNvZGVkVmFsdWUgPT09ICcweCcgJiYgIWlzU3RyaW5nT2JqZWN0ICYmICFpc1N0cmluZ1R5cGUpID8gbnVsbCA6IGRlY29kZWRWYWx1ZTtcbiAgICAgICAgcmV0dXJuVmFsdWVbaV0gPSBkZWNvZGVkVmFsdWU7XG4gICAgICAgIGlmICgodHlwZW9mIG91dHB1dCA9PT0gJ2Z1bmN0aW9uJyB8fCAhIW91dHB1dCAmJiB0eXBlb2Ygb3V0cHV0ID09PSAnb2JqZWN0JykgJiYgb3V0cHV0Lm5hbWUpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlW291dHB1dC5uYW1lXSA9IGRlY29kZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5WYWx1ZS5fX2xlbmd0aF9fKys7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xufTtcbi8qKlxuICogRGVjb2RlcyBldmVudHMgbm9uLSBhbmQgaW5kZXhlZCBwYXJhbWV0ZXJzLlxuICpcbiAqIEBtZXRob2QgZGVjb2RlTG9nXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRzXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YVxuICogQHBhcmFtIHtBcnJheX0gdG9waWNzXG4gKiBAcmV0dXJuIHtBcnJheX0gYXJyYXkgb2YgcGxhaW4gcGFyYW1zXG4gKi9cbkFCSUNvZGVyLnByb3RvdHlwZS5kZWNvZGVMb2cgPSBmdW5jdGlvbiAoaW5wdXRzLCBkYXRhLCB0b3BpY3MpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRvcGljcyA9IEFycmF5LmlzQXJyYXkodG9waWNzKSA/IHRvcGljcyA6IFt0b3BpY3NdO1xuICAgIGRhdGEgPSBkYXRhIHx8ICcnO1xuICAgIHZhciBub3RJbmRleGVkSW5wdXRzID0gW107XG4gICAgdmFyIGluZGV4ZWRQYXJhbXMgPSBbXTtcbiAgICB2YXIgdG9waWNDb3VudCA9IDA7XG4gICAgLy8gVE9ETyBjaGVjayBmb3IgYW5vbnltb3VzIGxvZ3M/XG4gICAgaW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKGlucHV0LCBpKSB7XG4gICAgICAgIGlmIChpbnB1dC5pbmRleGVkKSB7XG4gICAgICAgICAgICBpbmRleGVkUGFyYW1zW2ldID0gKFsnYm9vbCcsICdpbnQnLCAndWludCcsICdhZGRyZXNzJywgJ2ZpeGVkJywgJ3VmaXhlZCddLmZpbmQoZnVuY3Rpb24gKHN0YXRpY1R5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQudHlwZS5pbmRleE9mKHN0YXRpY1R5cGUpICE9PSAtMTtcbiAgICAgICAgICAgIH0pKSA/IF90aGlzLmRlY29kZVBhcmFtZXRlcihpbnB1dC50eXBlLCB0b3BpY3NbdG9waWNDb3VudF0pIDogdG9waWNzW3RvcGljQ291bnRdO1xuICAgICAgICAgICAgdG9waWNDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm90SW5kZXhlZElucHV0c1tpXSA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdmFyIG5vbkluZGV4ZWREYXRhID0gZGF0YTtcbiAgICB2YXIgbm90SW5kZXhlZFBhcmFtcyA9IChub25JbmRleGVkRGF0YSkgPyB0aGlzLmRlY29kZVBhcmFtZXRlcnNXaXRoKG5vdEluZGV4ZWRJbnB1dHMsIG5vbkluZGV4ZWREYXRhLCB0cnVlKSA6IFtdO1xuICAgIHZhciByZXR1cm5WYWx1ZSA9IG5ldyBSZXN1bHQoKTtcbiAgICByZXR1cm5WYWx1ZS5fX2xlbmd0aF9fID0gMDtcbiAgICBpbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAocmVzLCBpKSB7XG4gICAgICAgIHJldHVyblZhbHVlW2ldID0gKHJlcy50eXBlID09PSAnc3RyaW5nJykgPyAnJyA6IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2Ygbm90SW5kZXhlZFBhcmFtc1tpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlW2ldID0gbm90SW5kZXhlZFBhcmFtc1tpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGluZGV4ZWRQYXJhbXNbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZVtpXSA9IGluZGV4ZWRQYXJhbXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcy5uYW1lKSB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZVtyZXMubmFtZV0gPSByZXR1cm5WYWx1ZVtpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5WYWx1ZS5fX2xlbmd0aF9fKys7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xufTtcbnZhciBjb2RlciA9IG5ldyBBQklDb2RlcigpO1xubW9kdWxlLmV4cG9ydHMgPSBjb2RlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/web3-eth-abi/lib/index.js\n");

/***/ })

};
;