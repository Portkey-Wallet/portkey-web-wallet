"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fs-minipass";
exports.ids = ["vendor-chunks/fs-minipass"];
exports.modules = {

/***/ "(ssr)/./node_modules/fs-minipass/index.js":
/*!*******************************************!*\
  !*** ./node_modules/fs-minipass/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nconst MiniPass = __webpack_require__(/*! minipass */ \"(ssr)/./node_modules/minipass/index.js\")\nconst EE = (__webpack_require__(/*! events */ \"events\").EventEmitter)\nconst fs = __webpack_require__(/*! fs */ \"fs\")\n\n// for writev\nconst binding = process.binding('fs')\nconst writeBuffers = binding.writeBuffers\n/* istanbul ignore next */\nconst FSReqWrap = binding.FSReqWrap || binding.FSReqCallback\n\nconst _autoClose = Symbol('_autoClose')\nconst _close = Symbol('_close')\nconst _ended = Symbol('_ended')\nconst _fd = Symbol('_fd')\nconst _finished = Symbol('_finished')\nconst _flags = Symbol('_flags')\nconst _flush = Symbol('_flush')\nconst _handleChunk = Symbol('_handleChunk')\nconst _makeBuf = Symbol('_makeBuf')\nconst _mode = Symbol('_mode')\nconst _needDrain = Symbol('_needDrain')\nconst _onerror = Symbol('_onerror')\nconst _onopen = Symbol('_onopen')\nconst _onread = Symbol('_onread')\nconst _onwrite = Symbol('_onwrite')\nconst _open = Symbol('_open')\nconst _path = Symbol('_path')\nconst _pos = Symbol('_pos')\nconst _queue = Symbol('_queue')\nconst _read = Symbol('_read')\nconst _readSize = Symbol('_readSize')\nconst _reading = Symbol('_reading')\nconst _remain = Symbol('_remain')\nconst _size = Symbol('_size')\nconst _write = Symbol('_write')\nconst _writing = Symbol('_writing')\nconst _defaultFlag = Symbol('_defaultFlag')\n\nclass ReadStream extends MiniPass {\n  constructor (path, opt) {\n    opt = opt || {}\n    super(opt)\n\n    this.writable = false\n\n    if (typeof path !== 'string')\n      throw new TypeError('path must be a string')\n\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null\n    this[_path] = path\n    this[_readSize] = opt.readSize || 16*1024*1024\n    this[_reading] = false\n    this[_size] = typeof opt.size === 'number' ? opt.size : Infinity\n    this[_remain] = this[_size]\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ?\n      opt.autoClose : true\n\n    if (typeof this[_fd] === 'number')\n      this[_read]()\n    else\n      this[_open]()\n  }\n\n  get fd () { return this[_fd] }\n  get path () { return this[_path] }\n\n  write () {\n    throw new TypeError('this is a readable stream')\n  }\n\n  end () {\n    throw new TypeError('this is a readable stream')\n  }\n\n  [_open] () {\n    fs.open(this[_path], 'r', (er, fd) => this[_onopen](er, fd))\n  }\n\n  [_onopen] (er, fd) {\n    if (er)\n      this[_onerror](er)\n    else {\n      this[_fd] = fd\n      this.emit('open', fd)\n      this[_read]()\n    }\n  }\n\n  [_makeBuf] () {\n    return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]))\n  }\n\n  [_read] () {\n    if (!this[_reading]) {\n      this[_reading] = true\n      const buf = this[_makeBuf]()\n      /* istanbul ignore if */\n      if (buf.length === 0) return process.nextTick(() => this[_onread](null, 0, buf))\n      fs.read(this[_fd], buf, 0, buf.length, null, (er, br, buf) =>\n        this[_onread](er, br, buf))\n    }\n  }\n\n  [_onread] (er, br, buf) {\n    this[_reading] = false\n    if (er)\n      this[_onerror](er)\n    else if (this[_handleChunk](br, buf))\n      this[_read]()\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      fs.close(this[_fd], _ => this.emit('close'))\n      this[_fd] = null\n    }\n  }\n\n  [_onerror] (er) {\n    this[_reading] = true\n    this[_close]()\n    this.emit('error', er)\n  }\n\n  [_handleChunk] (br, buf) {\n    let ret = false\n    // no effect if infinite\n    this[_remain] -= br\n    if (br > 0)\n      ret = super.write(br < buf.length ? buf.slice(0, br) : buf)\n\n    if (br === 0 || this[_remain] <= 0) {\n      ret = false\n      this[_close]()\n      super.end()\n    }\n\n    return ret\n  }\n\n  emit (ev, data) {\n    switch (ev) {\n      case 'prefinish':\n      case 'finish':\n        break\n\n      case 'drain':\n        if (typeof this[_fd] === 'number')\n          this[_read]()\n        break\n\n      default:\n        return super.emit(ev, data)\n    }\n  }\n}\n\nclass ReadStreamSync extends ReadStream {\n  [_open] () {\n    let threw = true\n    try {\n      this[_onopen](null, fs.openSync(this[_path], 'r'))\n      threw = false\n    } finally {\n      if (threw)\n        this[_close]()\n    }\n  }\n\n  [_read] () {\n    let threw = true\n    try {\n      if (!this[_reading]) {\n        this[_reading] = true\n        do {\n          const buf = this[_makeBuf]()\n          /* istanbul ignore next */\n          const br = buf.length === 0 ? 0 : fs.readSync(this[_fd], buf, 0, buf.length, null)\n          if (!this[_handleChunk](br, buf))\n            break\n        } while (true)\n        this[_reading] = false\n      }\n      threw = false\n    } finally {\n      if (threw)\n        this[_close]()\n    }\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      try {\n        fs.closeSync(this[_fd])\n      } catch (er) {}\n      this[_fd] = null\n      this.emit('close')\n    }\n  }\n}\n\nclass WriteStream extends EE {\n  constructor (path, opt) {\n    opt = opt || {}\n    super(opt)\n    this.readable = false\n    this[_writing] = false\n    this[_ended] = false\n    this[_needDrain] = false\n    this[_queue] = []\n    this[_path] = path\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null\n    this[_mode] = opt.mode === undefined ? 0o666 : opt.mode\n    this[_pos] = typeof opt.start === 'number' ? opt.start : null\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ?\n      opt.autoClose : true\n\n    // truncating makes no sense when writing into the middle\n    const defaultFlag = this[_pos] !== null ? 'r+' : 'w'\n    this[_defaultFlag] = opt.flags === undefined\n    this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags\n\n    if (this[_fd] === null)\n      this[_open]()\n  }\n\n  get fd () { return this[_fd] }\n  get path () { return this[_path] }\n\n  [_onerror] (er) {\n    this[_close]()\n    this[_writing] = true\n    this.emit('error', er)\n  }\n\n  [_open] () {\n    fs.open(this[_path], this[_flags], this[_mode],\n      (er, fd) => this[_onopen](er, fd))\n  }\n\n  [_onopen] (er, fd) {\n    if (this[_defaultFlag] &&\n        this[_flags] === 'r+' &&\n        er && er.code === 'ENOENT') {\n      this[_flags] = 'w'\n      this[_open]()\n    } else if (er)\n      this[_onerror](er)\n    else {\n      this[_fd] = fd\n      this.emit('open', fd)\n      this[_flush]()\n    }\n  }\n\n  end (buf, enc) {\n    if (buf)\n      this.write(buf, enc)\n\n    this[_ended] = true\n\n    // synthetic after-write logic, where drain/finish live\n    if (!this[_writing] && !this[_queue].length &&\n        typeof this[_fd] === 'number')\n      this[_onwrite](null, 0)\n  }\n\n  write (buf, enc) {\n    if (typeof buf === 'string')\n      buf = new Buffer(buf, enc)\n\n    if (this[_ended]) {\n      this.emit('error', new Error('write() after end()'))\n      return false\n    }\n\n    if (this[_fd] === null || this[_writing] || this[_queue].length) {\n      this[_queue].push(buf)\n      this[_needDrain] = true\n      return false\n    }\n\n    this[_writing] = true\n    this[_write](buf)\n    return true\n  }\n\n  [_write] (buf) {\n    fs.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) =>\n      this[_onwrite](er, bw))\n  }\n\n  [_onwrite] (er, bw) {\n    if (er)\n      this[_onerror](er)\n    else {\n      if (this[_pos] !== null)\n        this[_pos] += bw\n      if (this[_queue].length)\n        this[_flush]()\n      else {\n        this[_writing] = false\n\n        if (this[_ended] && !this[_finished]) {\n          this[_finished] = true\n          this[_close]()\n          this.emit('finish')\n        } else if (this[_needDrain]) {\n          this[_needDrain] = false\n          this.emit('drain')\n        }\n      }\n    }\n  }\n\n  [_flush] () {\n    if (this[_queue].length === 0) {\n      if (this[_ended])\n        this[_onwrite](null, 0)\n    } else if (this[_queue].length === 1)\n      this[_write](this[_queue].pop())\n    else {\n      const iovec = this[_queue]\n      this[_queue] = []\n      writev(this[_fd], iovec, this[_pos],\n        (er, bw) => this[_onwrite](er, bw))\n    }\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      fs.close(this[_fd], _ => this.emit('close'))\n      this[_fd] = null\n    }\n  }\n}\n\nclass WriteStreamSync extends WriteStream {\n  [_open] () {\n    let fd\n    try {\n      fd = fs.openSync(this[_path], this[_flags], this[_mode])\n    } catch (er) {\n      if (this[_defaultFlag] &&\n          this[_flags] === 'r+' &&\n          er && er.code === 'ENOENT') {\n        this[_flags] = 'w'\n        return this[_open]()\n      } else\n        throw er\n    }\n    this[_onopen](null, fd)\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      try {\n        fs.closeSync(this[_fd])\n      } catch (er) {}\n      this[_fd] = null\n      this.emit('close')\n    }\n  }\n\n  [_write] (buf) {\n    try {\n      this[_onwrite](null,\n        fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos]))\n    } catch (er) {\n      this[_onwrite](er, 0)\n    }\n  }\n}\n\nconst writev = (fd, iovec, pos, cb) => {\n  const done = (er, bw) => cb(er, bw, iovec)\n  const req = new FSReqWrap()\n  req.oncomplete = done\n  binding.writeBuffers(fd, iovec, pos, req)\n}\n\nexports.ReadStream = ReadStream\nexports.ReadStreamSync = ReadStreamSync\n\nexports.WriteStream = WriteStream\nexports.WriteStreamSync = WriteStreamSync\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZnMtbWluaXBhc3MvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWixpQkFBaUIsbUJBQU8sQ0FBQyx3REFBVTtBQUNuQyxXQUFXLDBEQUE4QjtBQUN6QyxXQUFXLG1CQUFPLENBQUMsY0FBSTs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZCxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCLHNCQUFzQjs7QUFFdEIsbUJBQW1CO0FBQ25CLHVCQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL0Bwb3J0a2V5L25leHQtZXhhbXBsZS8uL25vZGVfbW9kdWxlcy9mcy1taW5pcGFzcy9pbmRleC5qcz84NWRlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuY29uc3QgTWluaVBhc3MgPSByZXF1aXJlKCdtaW5pcGFzcycpXG5jb25zdCBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5cbi8vIGZvciB3cml0ZXZcbmNvbnN0IGJpbmRpbmcgPSBwcm9jZXNzLmJpbmRpbmcoJ2ZzJylcbmNvbnN0IHdyaXRlQnVmZmVycyA9IGJpbmRpbmcud3JpdGVCdWZmZXJzXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgRlNSZXFXcmFwID0gYmluZGluZy5GU1JlcVdyYXAgfHwgYmluZGluZy5GU1JlcUNhbGxiYWNrXG5cbmNvbnN0IF9hdXRvQ2xvc2UgPSBTeW1ib2woJ19hdXRvQ2xvc2UnKVxuY29uc3QgX2Nsb3NlID0gU3ltYm9sKCdfY2xvc2UnKVxuY29uc3QgX2VuZGVkID0gU3ltYm9sKCdfZW5kZWQnKVxuY29uc3QgX2ZkID0gU3ltYm9sKCdfZmQnKVxuY29uc3QgX2ZpbmlzaGVkID0gU3ltYm9sKCdfZmluaXNoZWQnKVxuY29uc3QgX2ZsYWdzID0gU3ltYm9sKCdfZmxhZ3MnKVxuY29uc3QgX2ZsdXNoID0gU3ltYm9sKCdfZmx1c2gnKVxuY29uc3QgX2hhbmRsZUNodW5rID0gU3ltYm9sKCdfaGFuZGxlQ2h1bmsnKVxuY29uc3QgX21ha2VCdWYgPSBTeW1ib2woJ19tYWtlQnVmJylcbmNvbnN0IF9tb2RlID0gU3ltYm9sKCdfbW9kZScpXG5jb25zdCBfbmVlZERyYWluID0gU3ltYm9sKCdfbmVlZERyYWluJylcbmNvbnN0IF9vbmVycm9yID0gU3ltYm9sKCdfb25lcnJvcicpXG5jb25zdCBfb25vcGVuID0gU3ltYm9sKCdfb25vcGVuJylcbmNvbnN0IF9vbnJlYWQgPSBTeW1ib2woJ19vbnJlYWQnKVxuY29uc3QgX29ud3JpdGUgPSBTeW1ib2woJ19vbndyaXRlJylcbmNvbnN0IF9vcGVuID0gU3ltYm9sKCdfb3BlbicpXG5jb25zdCBfcGF0aCA9IFN5bWJvbCgnX3BhdGgnKVxuY29uc3QgX3BvcyA9IFN5bWJvbCgnX3BvcycpXG5jb25zdCBfcXVldWUgPSBTeW1ib2woJ19xdWV1ZScpXG5jb25zdCBfcmVhZCA9IFN5bWJvbCgnX3JlYWQnKVxuY29uc3QgX3JlYWRTaXplID0gU3ltYm9sKCdfcmVhZFNpemUnKVxuY29uc3QgX3JlYWRpbmcgPSBTeW1ib2woJ19yZWFkaW5nJylcbmNvbnN0IF9yZW1haW4gPSBTeW1ib2woJ19yZW1haW4nKVxuY29uc3QgX3NpemUgPSBTeW1ib2woJ19zaXplJylcbmNvbnN0IF93cml0ZSA9IFN5bWJvbCgnX3dyaXRlJylcbmNvbnN0IF93cml0aW5nID0gU3ltYm9sKCdfd3JpdGluZycpXG5jb25zdCBfZGVmYXVsdEZsYWcgPSBTeW1ib2woJ19kZWZhdWx0RmxhZycpXG5cbmNsYXNzIFJlYWRTdHJlYW0gZXh0ZW5kcyBNaW5pUGFzcyB7XG4gIGNvbnN0cnVjdG9yIChwYXRoLCBvcHQpIHtcbiAgICBvcHQgPSBvcHQgfHwge31cbiAgICBzdXBlcihvcHQpXG5cbiAgICB0aGlzLndyaXRhYmxlID0gZmFsc2VcblxuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXRoIG11c3QgYmUgYSBzdHJpbmcnKVxuXG4gICAgdGhpc1tfZmRdID0gdHlwZW9mIG9wdC5mZCA9PT0gJ251bWJlcicgPyBvcHQuZmQgOiBudWxsXG4gICAgdGhpc1tfcGF0aF0gPSBwYXRoXG4gICAgdGhpc1tfcmVhZFNpemVdID0gb3B0LnJlYWRTaXplIHx8IDE2KjEwMjQqMTAyNFxuICAgIHRoaXNbX3JlYWRpbmddID0gZmFsc2VcbiAgICB0aGlzW19zaXplXSA9IHR5cGVvZiBvcHQuc2l6ZSA9PT0gJ251bWJlcicgPyBvcHQuc2l6ZSA6IEluZmluaXR5XG4gICAgdGhpc1tfcmVtYWluXSA9IHRoaXNbX3NpemVdXG4gICAgdGhpc1tfYXV0b0Nsb3NlXSA9IHR5cGVvZiBvcHQuYXV0b0Nsb3NlID09PSAnYm9vbGVhbicgP1xuICAgICAgb3B0LmF1dG9DbG9zZSA6IHRydWVcblxuICAgIGlmICh0eXBlb2YgdGhpc1tfZmRdID09PSAnbnVtYmVyJylcbiAgICAgIHRoaXNbX3JlYWRdKClcbiAgICBlbHNlXG4gICAgICB0aGlzW19vcGVuXSgpXG4gIH1cblxuICBnZXQgZmQgKCkgeyByZXR1cm4gdGhpc1tfZmRdIH1cbiAgZ2V0IHBhdGggKCkgeyByZXR1cm4gdGhpc1tfcGF0aF0gfVxuXG4gIHdyaXRlICgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0aGlzIGlzIGEgcmVhZGFibGUgc3RyZWFtJylcbiAgfVxuXG4gIGVuZCAoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBhIHJlYWRhYmxlIHN0cmVhbScpXG4gIH1cblxuICBbX29wZW5dICgpIHtcbiAgICBmcy5vcGVuKHRoaXNbX3BhdGhdLCAncicsIChlciwgZmQpID0+IHRoaXNbX29ub3Blbl0oZXIsIGZkKSlcbiAgfVxuXG4gIFtfb25vcGVuXSAoZXIsIGZkKSB7XG4gICAgaWYgKGVyKVxuICAgICAgdGhpc1tfb25lcnJvcl0oZXIpXG4gICAgZWxzZSB7XG4gICAgICB0aGlzW19mZF0gPSBmZFxuICAgICAgdGhpcy5lbWl0KCdvcGVuJywgZmQpXG4gICAgICB0aGlzW19yZWFkXSgpXG4gICAgfVxuICB9XG5cbiAgW19tYWtlQnVmXSAoKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZShNYXRoLm1pbih0aGlzW19yZWFkU2l6ZV0sIHRoaXNbX3JlbWFpbl0pKVxuICB9XG5cbiAgW19yZWFkXSAoKSB7XG4gICAgaWYgKCF0aGlzW19yZWFkaW5nXSkge1xuICAgICAgdGhpc1tfcmVhZGluZ10gPSB0cnVlXG4gICAgICBjb25zdCBidWYgPSB0aGlzW19tYWtlQnVmXSgpXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChidWYubGVuZ3RoID09PSAwKSByZXR1cm4gcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB0aGlzW19vbnJlYWRdKG51bGwsIDAsIGJ1ZikpXG4gICAgICBmcy5yZWFkKHRoaXNbX2ZkXSwgYnVmLCAwLCBidWYubGVuZ3RoLCBudWxsLCAoZXIsIGJyLCBidWYpID0+XG4gICAgICAgIHRoaXNbX29ucmVhZF0oZXIsIGJyLCBidWYpKVxuICAgIH1cbiAgfVxuXG4gIFtfb25yZWFkXSAoZXIsIGJyLCBidWYpIHtcbiAgICB0aGlzW19yZWFkaW5nXSA9IGZhbHNlXG4gICAgaWYgKGVyKVxuICAgICAgdGhpc1tfb25lcnJvcl0oZXIpXG4gICAgZWxzZSBpZiAodGhpc1tfaGFuZGxlQ2h1bmtdKGJyLCBidWYpKVxuICAgICAgdGhpc1tfcmVhZF0oKVxuICB9XG5cbiAgW19jbG9zZV0gKCkge1xuICAgIGlmICh0aGlzW19hdXRvQ2xvc2VdICYmIHR5cGVvZiB0aGlzW19mZF0gPT09ICdudW1iZXInKSB7XG4gICAgICBmcy5jbG9zZSh0aGlzW19mZF0sIF8gPT4gdGhpcy5lbWl0KCdjbG9zZScpKVxuICAgICAgdGhpc1tfZmRdID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIFtfb25lcnJvcl0gKGVyKSB7XG4gICAgdGhpc1tfcmVhZGluZ10gPSB0cnVlXG4gICAgdGhpc1tfY2xvc2VdKClcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gIH1cblxuICBbX2hhbmRsZUNodW5rXSAoYnIsIGJ1Zikge1xuICAgIGxldCByZXQgPSBmYWxzZVxuICAgIC8vIG5vIGVmZmVjdCBpZiBpbmZpbml0ZVxuICAgIHRoaXNbX3JlbWFpbl0gLT0gYnJcbiAgICBpZiAoYnIgPiAwKVxuICAgICAgcmV0ID0gc3VwZXIud3JpdGUoYnIgPCBidWYubGVuZ3RoID8gYnVmLnNsaWNlKDAsIGJyKSA6IGJ1ZilcblxuICAgIGlmIChiciA9PT0gMCB8fCB0aGlzW19yZW1haW5dIDw9IDApIHtcbiAgICAgIHJldCA9IGZhbHNlXG4gICAgICB0aGlzW19jbG9zZV0oKVxuICAgICAgc3VwZXIuZW5kKClcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBlbWl0IChldiwgZGF0YSkge1xuICAgIHN3aXRjaCAoZXYpIHtcbiAgICAgIGNhc2UgJ3ByZWZpbmlzaCc6XG4gICAgICBjYXNlICdmaW5pc2gnOlxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlICdkcmFpbic6XG4gICAgICAgIGlmICh0eXBlb2YgdGhpc1tfZmRdID09PSAnbnVtYmVyJylcbiAgICAgICAgICB0aGlzW19yZWFkXSgpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBzdXBlci5lbWl0KGV2LCBkYXRhKVxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBSZWFkU3RyZWFtU3luYyBleHRlbmRzIFJlYWRTdHJlYW0ge1xuICBbX29wZW5dICgpIHtcbiAgICBsZXQgdGhyZXcgPSB0cnVlXG4gICAgdHJ5IHtcbiAgICAgIHRoaXNbX29ub3Blbl0obnVsbCwgZnMub3BlblN5bmModGhpc1tfcGF0aF0sICdyJykpXG4gICAgICB0aHJldyA9IGZhbHNlXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICh0aHJldylcbiAgICAgICAgdGhpc1tfY2xvc2VdKClcbiAgICB9XG4gIH1cblxuICBbX3JlYWRdICgpIHtcbiAgICBsZXQgdGhyZXcgPSB0cnVlXG4gICAgdHJ5IHtcbiAgICAgIGlmICghdGhpc1tfcmVhZGluZ10pIHtcbiAgICAgICAgdGhpc1tfcmVhZGluZ10gPSB0cnVlXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBjb25zdCBidWYgPSB0aGlzW19tYWtlQnVmXSgpXG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICBjb25zdCBiciA9IGJ1Zi5sZW5ndGggPT09IDAgPyAwIDogZnMucmVhZFN5bmModGhpc1tfZmRdLCBidWYsIDAsIGJ1Zi5sZW5ndGgsIG51bGwpXG4gICAgICAgICAgaWYgKCF0aGlzW19oYW5kbGVDaHVua10oYnIsIGJ1ZikpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICB9IHdoaWxlICh0cnVlKVxuICAgICAgICB0aGlzW19yZWFkaW5nXSA9IGZhbHNlXG4gICAgICB9XG4gICAgICB0aHJldyA9IGZhbHNlXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICh0aHJldylcbiAgICAgICAgdGhpc1tfY2xvc2VdKClcbiAgICB9XG4gIH1cblxuICBbX2Nsb3NlXSAoKSB7XG4gICAgaWYgKHRoaXNbX2F1dG9DbG9zZV0gJiYgdHlwZW9mIHRoaXNbX2ZkXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZzLmNsb3NlU3luYyh0aGlzW19mZF0pXG4gICAgICB9IGNhdGNoIChlcikge31cbiAgICAgIHRoaXNbX2ZkXSA9IG51bGxcbiAgICAgIHRoaXMuZW1pdCgnY2xvc2UnKVxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBXcml0ZVN0cmVhbSBleHRlbmRzIEVFIHtcbiAgY29uc3RydWN0b3IgKHBhdGgsIG9wdCkge1xuICAgIG9wdCA9IG9wdCB8fCB7fVxuICAgIHN1cGVyKG9wdClcbiAgICB0aGlzLnJlYWRhYmxlID0gZmFsc2VcbiAgICB0aGlzW193cml0aW5nXSA9IGZhbHNlXG4gICAgdGhpc1tfZW5kZWRdID0gZmFsc2VcbiAgICB0aGlzW19uZWVkRHJhaW5dID0gZmFsc2VcbiAgICB0aGlzW19xdWV1ZV0gPSBbXVxuICAgIHRoaXNbX3BhdGhdID0gcGF0aFxuICAgIHRoaXNbX2ZkXSA9IHR5cGVvZiBvcHQuZmQgPT09ICdudW1iZXInID8gb3B0LmZkIDogbnVsbFxuICAgIHRoaXNbX21vZGVdID0gb3B0Lm1vZGUgPT09IHVuZGVmaW5lZCA/IDBvNjY2IDogb3B0Lm1vZGVcbiAgICB0aGlzW19wb3NdID0gdHlwZW9mIG9wdC5zdGFydCA9PT0gJ251bWJlcicgPyBvcHQuc3RhcnQgOiBudWxsXG4gICAgdGhpc1tfYXV0b0Nsb3NlXSA9IHR5cGVvZiBvcHQuYXV0b0Nsb3NlID09PSAnYm9vbGVhbicgP1xuICAgICAgb3B0LmF1dG9DbG9zZSA6IHRydWVcblxuICAgIC8vIHRydW5jYXRpbmcgbWFrZXMgbm8gc2Vuc2Ugd2hlbiB3cml0aW5nIGludG8gdGhlIG1pZGRsZVxuICAgIGNvbnN0IGRlZmF1bHRGbGFnID0gdGhpc1tfcG9zXSAhPT0gbnVsbCA/ICdyKycgOiAndydcbiAgICB0aGlzW19kZWZhdWx0RmxhZ10gPSBvcHQuZmxhZ3MgPT09IHVuZGVmaW5lZFxuICAgIHRoaXNbX2ZsYWdzXSA9IHRoaXNbX2RlZmF1bHRGbGFnXSA/IGRlZmF1bHRGbGFnIDogb3B0LmZsYWdzXG5cbiAgICBpZiAodGhpc1tfZmRdID09PSBudWxsKVxuICAgICAgdGhpc1tfb3Blbl0oKVxuICB9XG5cbiAgZ2V0IGZkICgpIHsgcmV0dXJuIHRoaXNbX2ZkXSB9XG4gIGdldCBwYXRoICgpIHsgcmV0dXJuIHRoaXNbX3BhdGhdIH1cblxuICBbX29uZXJyb3JdIChlcikge1xuICAgIHRoaXNbX2Nsb3NlXSgpXG4gICAgdGhpc1tfd3JpdGluZ10gPSB0cnVlXG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICB9XG5cbiAgW19vcGVuXSAoKSB7XG4gICAgZnMub3Blbih0aGlzW19wYXRoXSwgdGhpc1tfZmxhZ3NdLCB0aGlzW19tb2RlXSxcbiAgICAgIChlciwgZmQpID0+IHRoaXNbX29ub3Blbl0oZXIsIGZkKSlcbiAgfVxuXG4gIFtfb25vcGVuXSAoZXIsIGZkKSB7XG4gICAgaWYgKHRoaXNbX2RlZmF1bHRGbGFnXSAmJlxuICAgICAgICB0aGlzW19mbGFnc10gPT09ICdyKycgJiZcbiAgICAgICAgZXIgJiYgZXIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgIHRoaXNbX2ZsYWdzXSA9ICd3J1xuICAgICAgdGhpc1tfb3Blbl0oKVxuICAgIH0gZWxzZSBpZiAoZXIpXG4gICAgICB0aGlzW19vbmVycm9yXShlcilcbiAgICBlbHNlIHtcbiAgICAgIHRoaXNbX2ZkXSA9IGZkXG4gICAgICB0aGlzLmVtaXQoJ29wZW4nLCBmZClcbiAgICAgIHRoaXNbX2ZsdXNoXSgpXG4gICAgfVxuICB9XG5cbiAgZW5kIChidWYsIGVuYykge1xuICAgIGlmIChidWYpXG4gICAgICB0aGlzLndyaXRlKGJ1ZiwgZW5jKVxuXG4gICAgdGhpc1tfZW5kZWRdID0gdHJ1ZVxuXG4gICAgLy8gc3ludGhldGljIGFmdGVyLXdyaXRlIGxvZ2ljLCB3aGVyZSBkcmFpbi9maW5pc2ggbGl2ZVxuICAgIGlmICghdGhpc1tfd3JpdGluZ10gJiYgIXRoaXNbX3F1ZXVlXS5sZW5ndGggJiZcbiAgICAgICAgdHlwZW9mIHRoaXNbX2ZkXSA9PT0gJ251bWJlcicpXG4gICAgICB0aGlzW19vbndyaXRlXShudWxsLCAwKVxuICB9XG5cbiAgd3JpdGUgKGJ1ZiwgZW5jKSB7XG4gICAgaWYgKHR5cGVvZiBidWYgPT09ICdzdHJpbmcnKVxuICAgICAgYnVmID0gbmV3IEJ1ZmZlcihidWYsIGVuYylcblxuICAgIGlmICh0aGlzW19lbmRlZF0pIHtcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3dyaXRlKCkgYWZ0ZXIgZW5kKCknKSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmICh0aGlzW19mZF0gPT09IG51bGwgfHwgdGhpc1tfd3JpdGluZ10gfHwgdGhpc1tfcXVldWVdLmxlbmd0aCkge1xuICAgICAgdGhpc1tfcXVldWVdLnB1c2goYnVmKVxuICAgICAgdGhpc1tfbmVlZERyYWluXSA9IHRydWVcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHRoaXNbX3dyaXRpbmddID0gdHJ1ZVxuICAgIHRoaXNbX3dyaXRlXShidWYpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIFtfd3JpdGVdIChidWYpIHtcbiAgICBmcy53cml0ZSh0aGlzW19mZF0sIGJ1ZiwgMCwgYnVmLmxlbmd0aCwgdGhpc1tfcG9zXSwgKGVyLCBidykgPT5cbiAgICAgIHRoaXNbX29ud3JpdGVdKGVyLCBidykpXG4gIH1cblxuICBbX29ud3JpdGVdIChlciwgYncpIHtcbiAgICBpZiAoZXIpXG4gICAgICB0aGlzW19vbmVycm9yXShlcilcbiAgICBlbHNlIHtcbiAgICAgIGlmICh0aGlzW19wb3NdICE9PSBudWxsKVxuICAgICAgICB0aGlzW19wb3NdICs9IGJ3XG4gICAgICBpZiAodGhpc1tfcXVldWVdLmxlbmd0aClcbiAgICAgICAgdGhpc1tfZmx1c2hdKClcbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzW193cml0aW5nXSA9IGZhbHNlXG5cbiAgICAgICAgaWYgKHRoaXNbX2VuZGVkXSAmJiAhdGhpc1tfZmluaXNoZWRdKSB7XG4gICAgICAgICAgdGhpc1tfZmluaXNoZWRdID0gdHJ1ZVxuICAgICAgICAgIHRoaXNbX2Nsb3NlXSgpXG4gICAgICAgICAgdGhpcy5lbWl0KCdmaW5pc2gnKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXNbX25lZWREcmFpbl0pIHtcbiAgICAgICAgICB0aGlzW19uZWVkRHJhaW5dID0gZmFsc2VcbiAgICAgICAgICB0aGlzLmVtaXQoJ2RyYWluJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIFtfZmx1c2hdICgpIHtcbiAgICBpZiAodGhpc1tfcXVldWVdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKHRoaXNbX2VuZGVkXSlcbiAgICAgICAgdGhpc1tfb253cml0ZV0obnVsbCwgMClcbiAgICB9IGVsc2UgaWYgKHRoaXNbX3F1ZXVlXS5sZW5ndGggPT09IDEpXG4gICAgICB0aGlzW193cml0ZV0odGhpc1tfcXVldWVdLnBvcCgpKVxuICAgIGVsc2Uge1xuICAgICAgY29uc3QgaW92ZWMgPSB0aGlzW19xdWV1ZV1cbiAgICAgIHRoaXNbX3F1ZXVlXSA9IFtdXG4gICAgICB3cml0ZXYodGhpc1tfZmRdLCBpb3ZlYywgdGhpc1tfcG9zXSxcbiAgICAgICAgKGVyLCBidykgPT4gdGhpc1tfb253cml0ZV0oZXIsIGJ3KSlcbiAgICB9XG4gIH1cblxuICBbX2Nsb3NlXSAoKSB7XG4gICAgaWYgKHRoaXNbX2F1dG9DbG9zZV0gJiYgdHlwZW9mIHRoaXNbX2ZkXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGZzLmNsb3NlKHRoaXNbX2ZkXSwgXyA9PiB0aGlzLmVtaXQoJ2Nsb3NlJykpXG4gICAgICB0aGlzW19mZF0gPSBudWxsXG4gICAgfVxuICB9XG59XG5cbmNsYXNzIFdyaXRlU3RyZWFtU3luYyBleHRlbmRzIFdyaXRlU3RyZWFtIHtcbiAgW19vcGVuXSAoKSB7XG4gICAgbGV0IGZkXG4gICAgdHJ5IHtcbiAgICAgIGZkID0gZnMub3BlblN5bmModGhpc1tfcGF0aF0sIHRoaXNbX2ZsYWdzXSwgdGhpc1tfbW9kZV0pXG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIGlmICh0aGlzW19kZWZhdWx0RmxhZ10gJiZcbiAgICAgICAgICB0aGlzW19mbGFnc10gPT09ICdyKycgJiZcbiAgICAgICAgICBlciAmJiBlci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgICB0aGlzW19mbGFnc10gPSAndydcbiAgICAgICAgcmV0dXJuIHRoaXNbX29wZW5dKClcbiAgICAgIH0gZWxzZVxuICAgICAgICB0aHJvdyBlclxuICAgIH1cbiAgICB0aGlzW19vbm9wZW5dKG51bGwsIGZkKVxuICB9XG5cbiAgW19jbG9zZV0gKCkge1xuICAgIGlmICh0aGlzW19hdXRvQ2xvc2VdICYmIHR5cGVvZiB0aGlzW19mZF0gPT09ICdudW1iZXInKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmcy5jbG9zZVN5bmModGhpc1tfZmRdKVxuICAgICAgfSBjYXRjaCAoZXIpIHt9XG4gICAgICB0aGlzW19mZF0gPSBudWxsXG4gICAgICB0aGlzLmVtaXQoJ2Nsb3NlJylcbiAgICB9XG4gIH1cblxuICBbX3dyaXRlXSAoYnVmKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXNbX29ud3JpdGVdKG51bGwsXG4gICAgICAgIGZzLndyaXRlU3luYyh0aGlzW19mZF0sIGJ1ZiwgMCwgYnVmLmxlbmd0aCwgdGhpc1tfcG9zXSkpXG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIHRoaXNbX29ud3JpdGVdKGVyLCAwKVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCB3cml0ZXYgPSAoZmQsIGlvdmVjLCBwb3MsIGNiKSA9PiB7XG4gIGNvbnN0IGRvbmUgPSAoZXIsIGJ3KSA9PiBjYihlciwgYncsIGlvdmVjKVxuICBjb25zdCByZXEgPSBuZXcgRlNSZXFXcmFwKClcbiAgcmVxLm9uY29tcGxldGUgPSBkb25lXG4gIGJpbmRpbmcud3JpdGVCdWZmZXJzKGZkLCBpb3ZlYywgcG9zLCByZXEpXG59XG5cbmV4cG9ydHMuUmVhZFN0cmVhbSA9IFJlYWRTdHJlYW1cbmV4cG9ydHMuUmVhZFN0cmVhbVN5bmMgPSBSZWFkU3RyZWFtU3luY1xuXG5leHBvcnRzLldyaXRlU3RyZWFtID0gV3JpdGVTdHJlYW1cbmV4cG9ydHMuV3JpdGVTdHJlYW1TeW5jID0gV3JpdGVTdHJlYW1TeW5jXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fs-minipass/index.js\n");

/***/ })

};
;