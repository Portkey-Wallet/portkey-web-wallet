"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/minipass";
exports.ids = ["vendor-chunks/minipass"];
exports.modules = {

/***/ "(ssr)/./node_modules/minipass/index.js":
/*!****************************************!*\
  !*** ./node_modules/minipass/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst EE = __webpack_require__(/*! events */ \"events\")\nconst Yallist = __webpack_require__(/*! yallist */ \"(ssr)/./node_modules/yallist/yallist.js\")\nconst SD = (__webpack_require__(/*! string_decoder */ \"string_decoder\").StringDecoder)\n\nconst EOF = Symbol('EOF')\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\nconst EMITTED_END = Symbol('emittedEnd')\nconst EMITTING_END = Symbol('emittingEnd')\nconst CLOSED = Symbol('closed')\nconst READ = Symbol('read')\nconst FLUSH = Symbol('flush')\nconst FLUSHCHUNK = Symbol('flushChunk')\nconst ENCODING = Symbol('encoding')\nconst DECODER = Symbol('decoder')\nconst FLOWING = Symbol('flowing')\nconst PAUSED = Symbol('paused')\nconst RESUME = Symbol('resume')\nconst BUFFERLENGTH = Symbol('bufferLength')\nconst BUFFERPUSH = Symbol('bufferPush')\nconst BUFFERSHIFT = Symbol('bufferShift')\nconst OBJECTMODE = Symbol('objectMode')\nconst DESTROYED = Symbol('destroyed')\n\n// TODO remove when Node v8 support drops\nconst doIter = global._MP_NO_ITERATOR_SYMBOLS_  !== '1'\nconst ASYNCITERATOR = doIter && Symbol.asyncIterator\n  || Symbol('asyncIterator not implemented')\nconst ITERATOR = doIter && Symbol.iterator\n  || Symbol('iterator not implemented')\n\n// Buffer in node 4.x < 4.5.0 doesn't have working Buffer.from\n// or Buffer.alloc, and Buffer in node 10 deprecated the ctor.\n// .M, this is fine .\\^/M..\nconst B = Buffer.alloc ? Buffer\n  : /* istanbul ignore next */ (__webpack_require__(/*! safe-buffer */ \"(ssr)/./node_modules/safe-buffer/index.js\").Buffer)\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\nconst isEndish = ev =>\n  ev === 'end' ||\n  ev === 'finish' ||\n  ev === 'prefinish'\n\nconst isArrayBuffer = b => b instanceof ArrayBuffer ||\n  typeof b === 'object' &&\n  b.constructor &&\n  b.constructor.name === 'ArrayBuffer' &&\n  b.byteLength >= 0\n\nconst isArrayBufferView = b => !B.isBuffer(b) && ArrayBuffer.isView(b)\n\nmodule.exports = class Minipass extends EE {\n  constructor (options) {\n    super()\n    this[FLOWING] = false\n    // whether we're explicitly paused\n    this[PAUSED] = false\n    this.pipes = new Yallist()\n    this.buffer = new Yallist()\n    this[OBJECTMODE] = options && options.objectMode || false\n    if (this[OBJECTMODE])\n      this[ENCODING] = null\n    else\n      this[ENCODING] = options && options.encoding || null\n    if (this[ENCODING] === 'buffer')\n      this[ENCODING] = null\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null\n    this[EOF] = false\n    this[EMITTED_END] = false\n    this[EMITTING_END] = false\n    this[CLOSED] = false\n    this.writable = true\n    this.readable = true\n    this[BUFFERLENGTH] = 0\n    this[DESTROYED] = false\n  }\n\n  get bufferLength () { return this[BUFFERLENGTH] }\n\n  get encoding () { return this[ENCODING] }\n  set encoding (enc) {\n    if (this[OBJECTMODE])\n      throw new Error('cannot set encoding in objectMode')\n\n    if (this[ENCODING] && enc !== this[ENCODING] &&\n        (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))\n      throw new Error('cannot change encoding')\n\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null\n      if (this.buffer.length)\n        this.buffer = this.buffer.map(chunk => this[DECODER].write(chunk))\n    }\n\n    this[ENCODING] = enc\n  }\n\n  setEncoding (enc) {\n    this.encoding = enc\n  }\n\n  get objectMode () { return this[OBJECTMODE] }\n  set objectMode (ॐ ) { this[OBJECTMODE] = this[OBJECTMODE] || !!ॐ  }\n\n  write (chunk, encoding, cb) {\n    if (this[EOF])\n      throw new Error('write after end')\n\n    if (this[DESTROYED]) {\n      this.emit('error', Object.assign(\n        new Error('Cannot call write after a stream was destroyed'),\n        { code: 'ERR_STREAM_DESTROYED' }\n      ))\n      return true\n    }\n\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (!encoding)\n      encoding = 'utf8'\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything else switches us into object mode\n    if (!this[OBJECTMODE] && !B.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk))\n        chunk = B.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)\n      else if (isArrayBuffer(chunk))\n        chunk = B.from(chunk)\n      else if (typeof chunk !== 'string')\n        // use the setter so we throw if we have encoding set\n        this.objectMode = true\n    }\n\n    // this ensures at this point that the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!this.objectMode && !chunk.length) {\n      const ret = this.flowing\n      if (this[BUFFERLENGTH] !== 0)\n        this.emit('readable')\n      if (cb)\n        cb()\n      return ret\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (typeof chunk === 'string' && !this[OBJECTMODE] &&\n        // unless it is a string already ready for us to use\n        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\n      chunk = B.from(chunk, encoding)\n    }\n\n    if (B.isBuffer(chunk) && this[ENCODING])\n      chunk = this[DECODER].write(chunk)\n\n    try {\n      return this.flowing\n        ? (this.emit('data', chunk), this.flowing)\n        : (this[BUFFERPUSH](chunk), false)\n    } finally {\n      if (this[BUFFERLENGTH] !== 0)\n        this.emit('readable')\n      if (cb)\n        cb()\n    }\n  }\n\n  read (n) {\n    if (this[DESTROYED])\n      return null\n\n    try {\n      if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH])\n        return null\n\n      if (this[OBJECTMODE])\n        n = null\n\n      if (this.buffer.length > 1 && !this[OBJECTMODE]) {\n        if (this.encoding)\n          this.buffer = new Yallist([\n            Array.from(this.buffer).join('')\n          ])\n        else\n          this.buffer = new Yallist([\n            B.concat(Array.from(this.buffer), this[BUFFERLENGTH])\n          ])\n      }\n\n      return this[READ](n || null, this.buffer.head.value)\n    } finally {\n      this[MAYBE_EMIT_END]()\n    }\n  }\n\n  [READ] (n, chunk) {\n    if (n === chunk.length || n === null)\n      this[BUFFERSHIFT]()\n    else {\n      this.buffer.head.value = chunk.slice(n)\n      chunk = chunk.slice(0, n)\n      this[BUFFERLENGTH] -= n\n    }\n\n    this.emit('data', chunk)\n\n    if (!this.buffer.length && !this[EOF])\n      this.emit('drain')\n\n    return chunk\n  }\n\n  end (chunk, encoding, cb) {\n    if (typeof chunk === 'function')\n      cb = chunk, chunk = null\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n    if (chunk)\n      this.write(chunk, encoding)\n    if (cb)\n      this.once('end', cb)\n    this[EOF] = true\n    this.writable = false\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this.flowing || !this[PAUSED])\n      this[MAYBE_EMIT_END]()\n    return this\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME] () {\n    if (this[DESTROYED])\n      return\n\n    this[PAUSED] = false\n    this[FLOWING] = true\n    this.emit('resume')\n    if (this.buffer.length)\n      this[FLUSH]()\n    else if (this[EOF])\n      this[MAYBE_EMIT_END]()\n    else\n      this.emit('drain')\n  }\n\n  resume () {\n    return this[RESUME]()\n  }\n\n  pause () {\n    this[FLOWING] = false\n    this[PAUSED] = true\n  }\n\n  get destroyed () {\n    return this[DESTROYED]\n  }\n\n  get flowing () {\n    return this[FLOWING]\n  }\n\n  get paused () {\n    return this[PAUSED]\n  }\n\n  [BUFFERPUSH] (chunk) {\n    if (this[OBJECTMODE])\n      this[BUFFERLENGTH] += 1\n    else\n      this[BUFFERLENGTH] += chunk.length\n    return this.buffer.push(chunk)\n  }\n\n  [BUFFERSHIFT] () {\n    if (this.buffer.length) {\n      if (this[OBJECTMODE])\n        this[BUFFERLENGTH] -= 1\n      else\n        this[BUFFERLENGTH] -= this.buffer.head.value.length\n    }\n    return this.buffer.shift()\n  }\n\n  [FLUSH] () {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()))\n\n    if (!this.buffer.length && !this[EOF])\n      this.emit('drain')\n  }\n\n  [FLUSHCHUNK] (chunk) {\n    return chunk ? (this.emit('data', chunk), this.flowing) : false\n  }\n\n  pipe (dest, opts) {\n    if (this[DESTROYED])\n      return\n\n    const ended = this[EMITTED_END]\n    opts = opts || {}\n    if (dest === process.stdout || dest === process.stderr)\n      opts.end = false\n    else\n      opts.end = opts.end !== false\n\n    const p = { dest: dest, opts: opts, ondrain: _ => this[RESUME]() }\n    this.pipes.push(p)\n\n    dest.on('drain', p.ondrain)\n    this[RESUME]()\n    // piping an ended stream ends immediately\n    if (ended && p.opts.end)\n      p.dest.end()\n    return dest\n  }\n\n  addListener (ev, fn) {\n    return this.on(ev, fn)\n  }\n\n  on (ev, fn) {\n    try {\n      return super.on(ev, fn)\n    } finally {\n      if (ev === 'data' && !this.pipes.length && !this.flowing)\n        this[RESUME]()\n      else if (isEndish(ev) && this[EMITTED_END]) {\n        super.emit(ev)\n        this.removeAllListeners(ev)\n      }\n    }\n  }\n\n  get emittedEnd () {\n    return this[EMITTED_END]\n  }\n\n  [MAYBE_EMIT_END] () {\n    if (!this[EMITTING_END] &&\n        !this[EMITTED_END] &&\n        !this[DESTROYED] &&\n        this.buffer.length === 0 &&\n        this[EOF]) {\n      this[EMITTING_END] = true\n      this.emit('end')\n      this.emit('prefinish')\n      this.emit('finish')\n      if (this[CLOSED])\n        this.emit('close')\n      this[EMITTING_END] = false\n    }\n  }\n\n  emit (ev, data) {\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])\n      return\n    else if (ev === 'data') {\n      if (!data)\n        return\n\n      if (this.pipes.length)\n        this.pipes.forEach(p =>\n          p.dest.write(data) === false && this.pause())\n    } else if (ev === 'end') {\n      // only actual end gets this treatment\n      if (this[EMITTED_END] === true)\n        return\n\n      this[EMITTED_END] = true\n      this.readable = false\n\n      if (this[DECODER]) {\n        data = this[DECODER].end()\n        if (data) {\n          this.pipes.forEach(p => p.dest.write(data))\n          super.emit('data', data)\n        }\n      }\n\n      this.pipes.forEach(p => {\n        p.dest.removeListener('drain', p.ondrain)\n        if (p.opts.end)\n          p.dest.end()\n      })\n    } else if (ev === 'close') {\n      this[CLOSED] = true\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED])\n        return\n    }\n\n    // TODO: replace with a spread operator when Node v4 support drops\n    const args = new Array(arguments.length)\n    args[0] = ev\n    args[1] = data\n    if (arguments.length > 2) {\n      for (let i = 2; i < arguments.length; i++) {\n        args[i] = arguments[i]\n      }\n    }\n\n    try {\n      return super.emit.apply(this, args)\n    } finally {\n      if (!isEndish(ev))\n        this[MAYBE_EMIT_END]()\n      else\n        this.removeAllListeners(ev)\n    }\n  }\n\n  // const all = await stream.collect()\n  collect () {\n    const buf = []\n    buf.dataLength = 0\n    this.on('data', c => {\n      buf.push(c)\n      buf.dataLength += c.length\n    })\n    return this.promise().then(() => buf)\n  }\n\n  // const data = await stream.concat()\n  concat () {\n    return this[OBJECTMODE]\n      ? Promise.reject(new Error('cannot concat in objectMode'))\n      : this.collect().then(buf =>\n          this[OBJECTMODE]\n            ? Promise.reject(new Error('cannot concat in objectMode'))\n            : this[ENCODING] ? buf.join('') : B.concat(buf, buf.dataLength))\n  }\n\n  // stream.promise().then(() => done, er => emitted error)\n  promise () {\n    return new Promise((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')))\n      this.on('end', () => resolve())\n      this.on('error', er => reject(er))\n    })\n  }\n\n  // for await (let chunk of stream)\n  [ASYNCITERATOR] () {\n    const next = () => {\n      const res = this.read()\n      if (res !== null)\n        return Promise.resolve({ done: false, value: res })\n\n      if (this[EOF])\n        return Promise.resolve({ done: true })\n\n      let resolve = null\n      let reject = null\n      const onerr = er => {\n        this.removeListener('data', ondata)\n        this.removeListener('end', onend)\n        reject(er)\n      }\n      const ondata = value => {\n        this.removeListener('error', onerr)\n        this.removeListener('end', onend)\n        this.pause()\n        resolve({ value: value, done: !!this[EOF] })\n      }\n      const onend = () => {\n        this.removeListener('error', onerr)\n        this.removeListener('data', ondata)\n        resolve({ done: true })\n      }\n      const ondestroy = () => onerr(new Error('stream destroyed'))\n      return new Promise((res, rej) => {\n        reject = rej\n        resolve = res\n        this.once(DESTROYED, ondestroy)\n        this.once('error', onerr)\n        this.once('end', onend)\n        this.once('data', ondata)\n      })\n    }\n\n    return { next }\n  }\n\n  // for (let chunk of stream)\n  [ITERATOR] () {\n    const next = () => {\n      const value = this.read()\n      const done = value === null\n      return { value, done }\n    }\n    return { next }\n  }\n\n  destroy (er) {\n    if (this[DESTROYED]) {\n      if (er)\n        this.emit('error', er)\n      else\n        this.emit(DESTROYED)\n      return this\n    }\n\n    this[DESTROYED] = true\n\n    // throw away all buffered data, it's never coming out\n    this.buffer = new Yallist()\n    this[BUFFERLENGTH] = 0\n\n    if (typeof this.close === 'function' && !this[CLOSED])\n      this.close()\n\n    if (er)\n      this.emit('error', er)\n    else // if no error to emit, still reject pending promises\n      this.emit(DESTROYED)\n\n    return this\n  }\n\n  static isStream (s) {\n    return !!s && (s instanceof Minipass || s instanceof EE && (\n      typeof s.pipe === 'function' || // readable\n      (typeof s.write === 'function' && typeof s.end === 'function') // writable\n    ))\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWluaXBhc3MvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWixXQUFXLG1CQUFPLENBQUMsc0JBQVE7QUFDM0IsZ0JBQWdCLG1CQUFPLENBQUMsd0RBQVM7QUFDakMsV0FBVywyRUFBdUM7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNEZBQTZCOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3Qjs7QUFFeEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEIsd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHlCQUF5Qjs7QUFFMUQ7QUFDQSxpQ0FBaUMsWUFBWTs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQ0FBaUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHBvcnRrZXkvbmV4dC1leGFtcGxlLy4vbm9kZV9tb2R1bGVzL21pbmlwYXNzL2luZGV4LmpzPzY5YTgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5jb25zdCBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpXG5jb25zdCBZYWxsaXN0ID0gcmVxdWlyZSgneWFsbGlzdCcpXG5jb25zdCBTRCA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJykuU3RyaW5nRGVjb2RlclxuXG5jb25zdCBFT0YgPSBTeW1ib2woJ0VPRicpXG5jb25zdCBNQVlCRV9FTUlUX0VORCA9IFN5bWJvbCgnbWF5YmVFbWl0RW5kJylcbmNvbnN0IEVNSVRURURfRU5EID0gU3ltYm9sKCdlbWl0dGVkRW5kJylcbmNvbnN0IEVNSVRUSU5HX0VORCA9IFN5bWJvbCgnZW1pdHRpbmdFbmQnKVxuY29uc3QgQ0xPU0VEID0gU3ltYm9sKCdjbG9zZWQnKVxuY29uc3QgUkVBRCA9IFN5bWJvbCgncmVhZCcpXG5jb25zdCBGTFVTSCA9IFN5bWJvbCgnZmx1c2gnKVxuY29uc3QgRkxVU0hDSFVOSyA9IFN5bWJvbCgnZmx1c2hDaHVuaycpXG5jb25zdCBFTkNPRElORyA9IFN5bWJvbCgnZW5jb2RpbmcnKVxuY29uc3QgREVDT0RFUiA9IFN5bWJvbCgnZGVjb2RlcicpXG5jb25zdCBGTE9XSU5HID0gU3ltYm9sKCdmbG93aW5nJylcbmNvbnN0IFBBVVNFRCA9IFN5bWJvbCgncGF1c2VkJylcbmNvbnN0IFJFU1VNRSA9IFN5bWJvbCgncmVzdW1lJylcbmNvbnN0IEJVRkZFUkxFTkdUSCA9IFN5bWJvbCgnYnVmZmVyTGVuZ3RoJylcbmNvbnN0IEJVRkZFUlBVU0ggPSBTeW1ib2woJ2J1ZmZlclB1c2gnKVxuY29uc3QgQlVGRkVSU0hJRlQgPSBTeW1ib2woJ2J1ZmZlclNoaWZ0JylcbmNvbnN0IE9CSkVDVE1PREUgPSBTeW1ib2woJ29iamVjdE1vZGUnKVxuY29uc3QgREVTVFJPWUVEID0gU3ltYm9sKCdkZXN0cm95ZWQnKVxuXG4vLyBUT0RPIHJlbW92ZSB3aGVuIE5vZGUgdjggc3VwcG9ydCBkcm9wc1xuY29uc3QgZG9JdGVyID0gZ2xvYmFsLl9NUF9OT19JVEVSQVRPUl9TWU1CT0xTXyAgIT09ICcxJ1xuY29uc3QgQVNZTkNJVEVSQVRPUiA9IGRvSXRlciAmJiBTeW1ib2wuYXN5bmNJdGVyYXRvclxuICB8fCBTeW1ib2woJ2FzeW5jSXRlcmF0b3Igbm90IGltcGxlbWVudGVkJylcbmNvbnN0IElURVJBVE9SID0gZG9JdGVyICYmIFN5bWJvbC5pdGVyYXRvclxuICB8fCBTeW1ib2woJ2l0ZXJhdG9yIG5vdCBpbXBsZW1lbnRlZCcpXG5cbi8vIEJ1ZmZlciBpbiBub2RlIDQueCA8IDQuNS4wIGRvZXNuJ3QgaGF2ZSB3b3JraW5nIEJ1ZmZlci5mcm9tXG4vLyBvciBCdWZmZXIuYWxsb2MsIGFuZCBCdWZmZXIgaW4gbm9kZSAxMCBkZXByZWNhdGVkIHRoZSBjdG9yLlxuLy8gLk0sIHRoaXMgaXMgZmluZSAuXFxeL00uLlxuY29uc3QgQiA9IEJ1ZmZlci5hbGxvYyA/IEJ1ZmZlclxuICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbi8vIGV2ZW50cyB0aGF0IG1lYW4gJ3RoZSBzdHJlYW0gaXMgb3Zlcidcbi8vIHRoZXNlIGFyZSB0cmVhdGVkIHNwZWNpYWxseSwgYW5kIHJlLWVtaXR0ZWRcbi8vIGlmIHRoZXkgYXJlIGxpc3RlbmVkIGZvciBhZnRlciBlbWl0dGluZy5cbmNvbnN0IGlzRW5kaXNoID0gZXYgPT5cbiAgZXYgPT09ICdlbmQnIHx8XG4gIGV2ID09PSAnZmluaXNoJyB8fFxuICBldiA9PT0gJ3ByZWZpbmlzaCdcblxuY29uc3QgaXNBcnJheUJ1ZmZlciA9IGIgPT4gYiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XG4gIHR5cGVvZiBiID09PSAnb2JqZWN0JyAmJlxuICBiLmNvbnN0cnVjdG9yICYmXG4gIGIuY29uc3RydWN0b3IubmFtZSA9PT0gJ0FycmF5QnVmZmVyJyAmJlxuICBiLmJ5dGVMZW5ndGggPj0gMFxuXG5jb25zdCBpc0FycmF5QnVmZmVyVmlldyA9IGIgPT4gIUIuaXNCdWZmZXIoYikgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KGIpXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgTWluaXBhc3MgZXh0ZW5kcyBFRSB7XG4gIGNvbnN0cnVjdG9yIChvcHRpb25zKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXNbRkxPV0lOR10gPSBmYWxzZVxuICAgIC8vIHdoZXRoZXIgd2UncmUgZXhwbGljaXRseSBwYXVzZWRcbiAgICB0aGlzW1BBVVNFRF0gPSBmYWxzZVxuICAgIHRoaXMucGlwZXMgPSBuZXcgWWFsbGlzdCgpXG4gICAgdGhpcy5idWZmZXIgPSBuZXcgWWFsbGlzdCgpXG4gICAgdGhpc1tPQkpFQ1RNT0RFXSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5vYmplY3RNb2RlIHx8IGZhbHNlXG4gICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pXG4gICAgICB0aGlzW0VOQ09ESU5HXSA9IG51bGxcbiAgICBlbHNlXG4gICAgICB0aGlzW0VOQ09ESU5HXSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5lbmNvZGluZyB8fCBudWxsXG4gICAgaWYgKHRoaXNbRU5DT0RJTkddID09PSAnYnVmZmVyJylcbiAgICAgIHRoaXNbRU5DT0RJTkddID0gbnVsbFxuICAgIHRoaXNbREVDT0RFUl0gPSB0aGlzW0VOQ09ESU5HXSA/IG5ldyBTRCh0aGlzW0VOQ09ESU5HXSkgOiBudWxsXG4gICAgdGhpc1tFT0ZdID0gZmFsc2VcbiAgICB0aGlzW0VNSVRURURfRU5EXSA9IGZhbHNlXG4gICAgdGhpc1tFTUlUVElOR19FTkRdID0gZmFsc2VcbiAgICB0aGlzW0NMT1NFRF0gPSBmYWxzZVxuICAgIHRoaXMud3JpdGFibGUgPSB0cnVlXG4gICAgdGhpcy5yZWFkYWJsZSA9IHRydWVcbiAgICB0aGlzW0JVRkZFUkxFTkdUSF0gPSAwXG4gICAgdGhpc1tERVNUUk9ZRURdID0gZmFsc2VcbiAgfVxuXG4gIGdldCBidWZmZXJMZW5ndGggKCkgeyByZXR1cm4gdGhpc1tCVUZGRVJMRU5HVEhdIH1cblxuICBnZXQgZW5jb2RpbmcgKCkgeyByZXR1cm4gdGhpc1tFTkNPRElOR10gfVxuICBzZXQgZW5jb2RpbmcgKGVuYykge1xuICAgIGlmICh0aGlzW09CSkVDVE1PREVdKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3Qgc2V0IGVuY29kaW5nIGluIG9iamVjdE1vZGUnKVxuXG4gICAgaWYgKHRoaXNbRU5DT0RJTkddICYmIGVuYyAhPT0gdGhpc1tFTkNPRElOR10gJiZcbiAgICAgICAgKHRoaXNbREVDT0RFUl0gJiYgdGhpc1tERUNPREVSXS5sYXN0TmVlZCB8fCB0aGlzW0JVRkZFUkxFTkdUSF0pKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY2hhbmdlIGVuY29kaW5nJylcblxuICAgIGlmICh0aGlzW0VOQ09ESU5HXSAhPT0gZW5jKSB7XG4gICAgICB0aGlzW0RFQ09ERVJdID0gZW5jID8gbmV3IFNEKGVuYykgOiBudWxsXG4gICAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoKVxuICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyLm1hcChjaHVuayA9PiB0aGlzW0RFQ09ERVJdLndyaXRlKGNodW5rKSlcbiAgICB9XG5cbiAgICB0aGlzW0VOQ09ESU5HXSA9IGVuY1xuICB9XG5cbiAgc2V0RW5jb2RpbmcgKGVuYykge1xuICAgIHRoaXMuZW5jb2RpbmcgPSBlbmNcbiAgfVxuXG4gIGdldCBvYmplY3RNb2RlICgpIHsgcmV0dXJuIHRoaXNbT0JKRUNUTU9ERV0gfVxuICBzZXQgb2JqZWN0TW9kZSAo4KWQICkgeyB0aGlzW09CSkVDVE1PREVdID0gdGhpc1tPQkpFQ1RNT0RFXSB8fCAhIeClkCAgfVxuXG4gIHdyaXRlIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgaWYgKHRoaXNbRU9GXSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJylcblxuICAgIGlmICh0aGlzW0RFU1RST1lFRF0pIHtcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBPYmplY3QuYXNzaWduKFxuICAgICAgICBuZXcgRXJyb3IoJ0Nhbm5vdCBjYWxsIHdyaXRlIGFmdGVyIGEgc3RyZWFtIHdhcyBkZXN0cm95ZWQnKSxcbiAgICAgICAgeyBjb2RlOiAnRVJSX1NUUkVBTV9ERVNUUk9ZRUQnIH1cbiAgICAgICkpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IGVuY29kaW5nLCBlbmNvZGluZyA9ICd1dGY4J1xuXG4gICAgaWYgKCFlbmNvZGluZylcbiAgICAgIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgICAvLyBjb252ZXJ0IGFycmF5IGJ1ZmZlcnMgYW5kIHR5cGVkIGFycmF5IHZpZXdzIGludG8gYnVmZmVyc1xuICAgIC8vIGF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZSwgd2UgbWF5IHdhbnQgdG8gZG8gdGhlIG9wcG9zaXRlIVxuICAgIC8vIGxlYXZlIHN0cmluZ3MgYW5kIGJ1ZmZlcnMgYXMtaXNcbiAgICAvLyBhbnl0aGluZyBlbHNlIHN3aXRjaGVzIHVzIGludG8gb2JqZWN0IG1vZGVcbiAgICBpZiAoIXRoaXNbT0JKRUNUTU9ERV0gJiYgIUIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgICBpZiAoaXNBcnJheUJ1ZmZlclZpZXcoY2h1bmspKVxuICAgICAgICBjaHVuayA9IEIuZnJvbShjaHVuay5idWZmZXIsIGNodW5rLmJ5dGVPZmZzZXQsIGNodW5rLmJ5dGVMZW5ndGgpXG4gICAgICBlbHNlIGlmIChpc0FycmF5QnVmZmVyKGNodW5rKSlcbiAgICAgICAgY2h1bmsgPSBCLmZyb20oY2h1bmspXG4gICAgICBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnKVxuICAgICAgICAvLyB1c2UgdGhlIHNldHRlciBzbyB3ZSB0aHJvdyBpZiB3ZSBoYXZlIGVuY29kaW5nIHNldFxuICAgICAgICB0aGlzLm9iamVjdE1vZGUgPSB0cnVlXG4gICAgfVxuXG4gICAgLy8gdGhpcyBlbnN1cmVzIGF0IHRoaXMgcG9pbnQgdGhhdCB0aGUgY2h1bmsgaXMgYSBidWZmZXIgb3Igc3RyaW5nXG4gICAgLy8gZG9uJ3QgYnVmZmVyIGl0IHVwIG9yIHNlbmQgaXQgdG8gdGhlIGRlY29kZXJcbiAgICBpZiAoIXRoaXMub2JqZWN0TW9kZSAmJiAhY2h1bmsubGVuZ3RoKSB7XG4gICAgICBjb25zdCByZXQgPSB0aGlzLmZsb3dpbmdcbiAgICAgIGlmICh0aGlzW0JVRkZFUkxFTkdUSF0gIT09IDApXG4gICAgICAgIHRoaXMuZW1pdCgncmVhZGFibGUnKVxuICAgICAgaWYgKGNiKVxuICAgICAgICBjYigpXG4gICAgICByZXR1cm4gcmV0XG4gICAgfVxuXG4gICAgLy8gZmFzdC1wYXRoIHdyaXRpbmcgc3RyaW5ncyBvZiBzYW1lIGVuY29kaW5nIHRvIGEgc3RyZWFtIHdpdGhcbiAgICAvLyBhbiBlbXB0eSBidWZmZXIsIHNraXBwaW5nIHRoZSBidWZmZXIvZGVjb2RlciBkYW5jZVxuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnICYmICF0aGlzW09CSkVDVE1PREVdICYmXG4gICAgICAgIC8vIHVubGVzcyBpdCBpcyBhIHN0cmluZyBhbHJlYWR5IHJlYWR5IGZvciB1cyB0byB1c2VcbiAgICAgICAgIShlbmNvZGluZyA9PT0gdGhpc1tFTkNPRElOR10gJiYgIXRoaXNbREVDT0RFUl0ubGFzdE5lZWQpKSB7XG4gICAgICBjaHVuayA9IEIuZnJvbShjaHVuaywgZW5jb2RpbmcpXG4gICAgfVxuXG4gICAgaWYgKEIuaXNCdWZmZXIoY2h1bmspICYmIHRoaXNbRU5DT0RJTkddKVxuICAgICAgY2h1bmsgPSB0aGlzW0RFQ09ERVJdLndyaXRlKGNodW5rKVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dpbmdcbiAgICAgICAgPyAodGhpcy5lbWl0KCdkYXRhJywgY2h1bmspLCB0aGlzLmZsb3dpbmcpXG4gICAgICAgIDogKHRoaXNbQlVGRkVSUFVTSF0oY2h1bmspLCBmYWxzZSlcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHRoaXNbQlVGRkVSTEVOR1RIXSAhPT0gMClcbiAgICAgICAgdGhpcy5lbWl0KCdyZWFkYWJsZScpXG4gICAgICBpZiAoY2IpXG4gICAgICAgIGNiKClcbiAgICB9XG4gIH1cblxuICByZWFkIChuKSB7XG4gICAgaWYgKHRoaXNbREVTVFJPWUVEXSlcbiAgICAgIHJldHVybiBudWxsXG5cbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXNbQlVGRkVSTEVOR1RIXSA9PT0gMCB8fCBuID09PSAwIHx8IG4gPiB0aGlzW0JVRkZFUkxFTkdUSF0pXG4gICAgICAgIHJldHVybiBudWxsXG5cbiAgICAgIGlmICh0aGlzW09CSkVDVE1PREVdKVxuICAgICAgICBuID0gbnVsbFxuXG4gICAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoID4gMSAmJiAhdGhpc1tPQkpFQ1RNT0RFXSkge1xuICAgICAgICBpZiAodGhpcy5lbmNvZGluZylcbiAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBZYWxsaXN0KFtcbiAgICAgICAgICAgIEFycmF5LmZyb20odGhpcy5idWZmZXIpLmpvaW4oJycpXG4gICAgICAgICAgXSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFlhbGxpc3QoW1xuICAgICAgICAgICAgQi5jb25jYXQoQXJyYXkuZnJvbSh0aGlzLmJ1ZmZlciksIHRoaXNbQlVGRkVSTEVOR1RIXSlcbiAgICAgICAgICBdKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpc1tSRUFEXShuIHx8IG51bGwsIHRoaXMuYnVmZmVyLmhlYWQudmFsdWUpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKClcbiAgICB9XG4gIH1cblxuICBbUkVBRF0gKG4sIGNodW5rKSB7XG4gICAgaWYgKG4gPT09IGNodW5rLmxlbmd0aCB8fCBuID09PSBudWxsKVxuICAgICAgdGhpc1tCVUZGRVJTSElGVF0oKVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5idWZmZXIuaGVhZC52YWx1ZSA9IGNodW5rLnNsaWNlKG4pXG4gICAgICBjaHVuayA9IGNodW5rLnNsaWNlKDAsIG4pXG4gICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gLT0gblxuICAgIH1cblxuICAgIHRoaXMuZW1pdCgnZGF0YScsIGNodW5rKVxuXG4gICAgaWYgKCF0aGlzLmJ1ZmZlci5sZW5ndGggJiYgIXRoaXNbRU9GXSlcbiAgICAgIHRoaXMuZW1pdCgnZHJhaW4nKVxuXG4gICAgcmV0dXJuIGNodW5rXG4gIH1cblxuICBlbmQgKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBjaHVuaywgY2h1bmsgPSBudWxsXG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiID0gZW5jb2RpbmcsIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgaWYgKGNodW5rKVxuICAgICAgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpXG4gICAgaWYgKGNiKVxuICAgICAgdGhpcy5vbmNlKCdlbmQnLCBjYilcbiAgICB0aGlzW0VPRl0gPSB0cnVlXG4gICAgdGhpcy53cml0YWJsZSA9IGZhbHNlXG5cbiAgICAvLyBpZiB3ZSBoYXZlbid0IHdyaXR0ZW4gYW55dGhpbmcsIHRoZW4gZ28gYWhlYWQgYW5kIGVtaXQsXG4gICAgLy8gZXZlbiBpZiB3ZSdyZSBub3QgcmVhZGluZy5cbiAgICAvLyB3ZSdsbCByZS1lbWl0IGlmIGEgbmV3ICdlbmQnIGxpc3RlbmVyIGlzIGFkZGVkIGFueXdheS5cbiAgICAvLyBUaGlzIG1ha2VzIE1QIG1vcmUgc3VpdGFibGUgdG8gd3JpdGUtb25seSB1c2UgY2FzZXMuXG4gICAgaWYgKHRoaXMuZmxvd2luZyB8fCAhdGhpc1tQQVVTRURdKVxuICAgICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBkb24ndCBsZXQgdGhlIGludGVybmFsIHJlc3VtZSBiZSBvdmVyd3JpdHRlblxuICBbUkVTVU1FXSAoKSB7XG4gICAgaWYgKHRoaXNbREVTVFJPWUVEXSlcbiAgICAgIHJldHVyblxuXG4gICAgdGhpc1tQQVVTRURdID0gZmFsc2VcbiAgICB0aGlzW0ZMT1dJTkddID0gdHJ1ZVxuICAgIHRoaXMuZW1pdCgncmVzdW1lJylcbiAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoKVxuICAgICAgdGhpc1tGTFVTSF0oKVxuICAgIGVsc2UgaWYgKHRoaXNbRU9GXSlcbiAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKClcbiAgICBlbHNlXG4gICAgICB0aGlzLmVtaXQoJ2RyYWluJylcbiAgfVxuXG4gIHJlc3VtZSAoKSB7XG4gICAgcmV0dXJuIHRoaXNbUkVTVU1FXSgpXG4gIH1cblxuICBwYXVzZSAoKSB7XG4gICAgdGhpc1tGTE9XSU5HXSA9IGZhbHNlXG4gICAgdGhpc1tQQVVTRURdID0gdHJ1ZVxuICB9XG5cbiAgZ2V0IGRlc3Ryb3llZCAoKSB7XG4gICAgcmV0dXJuIHRoaXNbREVTVFJPWUVEXVxuICB9XG5cbiAgZ2V0IGZsb3dpbmcgKCkge1xuICAgIHJldHVybiB0aGlzW0ZMT1dJTkddXG4gIH1cblxuICBnZXQgcGF1c2VkICgpIHtcbiAgICByZXR1cm4gdGhpc1tQQVVTRURdXG4gIH1cblxuICBbQlVGRkVSUFVTSF0gKGNodW5rKSB7XG4gICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pXG4gICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gKz0gMVxuICAgIGVsc2VcbiAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSArPSBjaHVuay5sZW5ndGhcbiAgICByZXR1cm4gdGhpcy5idWZmZXIucHVzaChjaHVuaylcbiAgfVxuXG4gIFtCVUZGRVJTSElGVF0gKCkge1xuICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzW09CSkVDVE1PREVdKVxuICAgICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gLT0gMVxuICAgICAgZWxzZVxuICAgICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gLT0gdGhpcy5idWZmZXIuaGVhZC52YWx1ZS5sZW5ndGhcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyLnNoaWZ0KClcbiAgfVxuXG4gIFtGTFVTSF0gKCkge1xuICAgIGRvIHt9IHdoaWxlICh0aGlzW0ZMVVNIQ0hVTktdKHRoaXNbQlVGRkVSU0hJRlRdKCkpKVxuXG4gICAgaWYgKCF0aGlzLmJ1ZmZlci5sZW5ndGggJiYgIXRoaXNbRU9GXSlcbiAgICAgIHRoaXMuZW1pdCgnZHJhaW4nKVxuICB9XG5cbiAgW0ZMVVNIQ0hVTktdIChjaHVuaykge1xuICAgIHJldHVybiBjaHVuayA/ICh0aGlzLmVtaXQoJ2RhdGEnLCBjaHVuayksIHRoaXMuZmxvd2luZykgOiBmYWxzZVxuICB9XG5cbiAgcGlwZSAoZGVzdCwgb3B0cykge1xuICAgIGlmICh0aGlzW0RFU1RST1lFRF0pXG4gICAgICByZXR1cm5cblxuICAgIGNvbnN0IGVuZGVkID0gdGhpc1tFTUlUVEVEX0VORF1cbiAgICBvcHRzID0gb3B0cyB8fCB7fVxuICAgIGlmIChkZXN0ID09PSBwcm9jZXNzLnN0ZG91dCB8fCBkZXN0ID09PSBwcm9jZXNzLnN0ZGVycilcbiAgICAgIG9wdHMuZW5kID0gZmFsc2VcbiAgICBlbHNlXG4gICAgICBvcHRzLmVuZCA9IG9wdHMuZW5kICE9PSBmYWxzZVxuXG4gICAgY29uc3QgcCA9IHsgZGVzdDogZGVzdCwgb3B0czogb3B0cywgb25kcmFpbjogXyA9PiB0aGlzW1JFU1VNRV0oKSB9XG4gICAgdGhpcy5waXBlcy5wdXNoKHApXG5cbiAgICBkZXN0Lm9uKCdkcmFpbicsIHAub25kcmFpbilcbiAgICB0aGlzW1JFU1VNRV0oKVxuICAgIC8vIHBpcGluZyBhbiBlbmRlZCBzdHJlYW0gZW5kcyBpbW1lZGlhdGVseVxuICAgIGlmIChlbmRlZCAmJiBwLm9wdHMuZW5kKVxuICAgICAgcC5kZXN0LmVuZCgpXG4gICAgcmV0dXJuIGRlc3RcbiAgfVxuXG4gIGFkZExpc3RlbmVyIChldiwgZm4pIHtcbiAgICByZXR1cm4gdGhpcy5vbihldiwgZm4pXG4gIH1cblxuICBvbiAoZXYsIGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBzdXBlci5vbihldiwgZm4pXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChldiA9PT0gJ2RhdGEnICYmICF0aGlzLnBpcGVzLmxlbmd0aCAmJiAhdGhpcy5mbG93aW5nKVxuICAgICAgICB0aGlzW1JFU1VNRV0oKVxuICAgICAgZWxzZSBpZiAoaXNFbmRpc2goZXYpICYmIHRoaXNbRU1JVFRFRF9FTkRdKSB7XG4gICAgICAgIHN1cGVyLmVtaXQoZXYpXG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGV2KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCBlbWl0dGVkRW5kICgpIHtcbiAgICByZXR1cm4gdGhpc1tFTUlUVEVEX0VORF1cbiAgfVxuXG4gIFtNQVlCRV9FTUlUX0VORF0gKCkge1xuICAgIGlmICghdGhpc1tFTUlUVElOR19FTkRdICYmXG4gICAgICAgICF0aGlzW0VNSVRURURfRU5EXSAmJlxuICAgICAgICAhdGhpc1tERVNUUk9ZRURdICYmXG4gICAgICAgIHRoaXMuYnVmZmVyLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICB0aGlzW0VPRl0pIHtcbiAgICAgIHRoaXNbRU1JVFRJTkdfRU5EXSA9IHRydWVcbiAgICAgIHRoaXMuZW1pdCgnZW5kJylcbiAgICAgIHRoaXMuZW1pdCgncHJlZmluaXNoJylcbiAgICAgIHRoaXMuZW1pdCgnZmluaXNoJylcbiAgICAgIGlmICh0aGlzW0NMT1NFRF0pXG4gICAgICAgIHRoaXMuZW1pdCgnY2xvc2UnKVxuICAgICAgdGhpc1tFTUlUVElOR19FTkRdID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICBlbWl0IChldiwgZGF0YSkge1xuICAgIC8vIGVycm9yIGFuZCBjbG9zZSBhcmUgb25seSBldmVudHMgYWxsb3dlZCBhZnRlciBjYWxsaW5nIGRlc3Ryb3koKVxuICAgIGlmIChldiAhPT0gJ2Vycm9yJyAmJiBldiAhPT0gJ2Nsb3NlJyAmJiBldiAhPT0gREVTVFJPWUVEICYmIHRoaXNbREVTVFJPWUVEXSlcbiAgICAgIHJldHVyblxuICAgIGVsc2UgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAgIGlmICghZGF0YSlcbiAgICAgICAgcmV0dXJuXG5cbiAgICAgIGlmICh0aGlzLnBpcGVzLmxlbmd0aClcbiAgICAgICAgdGhpcy5waXBlcy5mb3JFYWNoKHAgPT5cbiAgICAgICAgICBwLmRlc3Qud3JpdGUoZGF0YSkgPT09IGZhbHNlICYmIHRoaXMucGF1c2UoKSlcbiAgICB9IGVsc2UgaWYgKGV2ID09PSAnZW5kJykge1xuICAgICAgLy8gb25seSBhY3R1YWwgZW5kIGdldHMgdGhpcyB0cmVhdG1lbnRcbiAgICAgIGlmICh0aGlzW0VNSVRURURfRU5EXSA9PT0gdHJ1ZSlcbiAgICAgICAgcmV0dXJuXG5cbiAgICAgIHRoaXNbRU1JVFRFRF9FTkRdID0gdHJ1ZVxuICAgICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlXG5cbiAgICAgIGlmICh0aGlzW0RFQ09ERVJdKSB7XG4gICAgICAgIGRhdGEgPSB0aGlzW0RFQ09ERVJdLmVuZCgpXG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgdGhpcy5waXBlcy5mb3JFYWNoKHAgPT4gcC5kZXN0LndyaXRlKGRhdGEpKVxuICAgICAgICAgIHN1cGVyLmVtaXQoJ2RhdGEnLCBkYXRhKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGlwZXMuZm9yRWFjaChwID0+IHtcbiAgICAgICAgcC5kZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIHAub25kcmFpbilcbiAgICAgICAgaWYgKHAub3B0cy5lbmQpXG4gICAgICAgICAgcC5kZXN0LmVuZCgpXG4gICAgICB9KVxuICAgIH0gZWxzZSBpZiAoZXYgPT09ICdjbG9zZScpIHtcbiAgICAgIHRoaXNbQ0xPU0VEXSA9IHRydWVcbiAgICAgIC8vIGRvbid0IGVtaXQgY2xvc2UgYmVmb3JlICdlbmQnIGFuZCAnZmluaXNoJ1xuICAgICAgaWYgKCF0aGlzW0VNSVRURURfRU5EXSAmJiAhdGhpc1tERVNUUk9ZRURdKVxuICAgICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZXBsYWNlIHdpdGggYSBzcHJlYWQgb3BlcmF0b3Igd2hlbiBOb2RlIHY0IHN1cHBvcnQgZHJvcHNcbiAgICBjb25zdCBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgYXJnc1swXSA9IGV2XG4gICAgYXJnc1sxXSA9IGRhdGFcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHN1cGVyLmVtaXQuYXBwbHkodGhpcywgYXJncylcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKCFpc0VuZGlzaChldikpXG4gICAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKClcbiAgICAgIGVsc2VcbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoZXYpXG4gICAgfVxuICB9XG5cbiAgLy8gY29uc3QgYWxsID0gYXdhaXQgc3RyZWFtLmNvbGxlY3QoKVxuICBjb2xsZWN0ICgpIHtcbiAgICBjb25zdCBidWYgPSBbXVxuICAgIGJ1Zi5kYXRhTGVuZ3RoID0gMFxuICAgIHRoaXMub24oJ2RhdGEnLCBjID0+IHtcbiAgICAgIGJ1Zi5wdXNoKGMpXG4gICAgICBidWYuZGF0YUxlbmd0aCArPSBjLmxlbmd0aFxuICAgIH0pXG4gICAgcmV0dXJuIHRoaXMucHJvbWlzZSgpLnRoZW4oKCkgPT4gYnVmKVxuICB9XG5cbiAgLy8gY29uc3QgZGF0YSA9IGF3YWl0IHN0cmVhbS5jb25jYXQoKVxuICBjb25jYXQgKCkge1xuICAgIHJldHVybiB0aGlzW09CSkVDVE1PREVdXG4gICAgICA/IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignY2Fubm90IGNvbmNhdCBpbiBvYmplY3RNb2RlJykpXG4gICAgICA6IHRoaXMuY29sbGVjdCgpLnRoZW4oYnVmID0+XG4gICAgICAgICAgdGhpc1tPQkpFQ1RNT0RFXVxuICAgICAgICAgICAgPyBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ2Nhbm5vdCBjb25jYXQgaW4gb2JqZWN0TW9kZScpKVxuICAgICAgICAgICAgOiB0aGlzW0VOQ09ESU5HXSA/IGJ1Zi5qb2luKCcnKSA6IEIuY29uY2F0KGJ1ZiwgYnVmLmRhdGFMZW5ndGgpKVxuICB9XG5cbiAgLy8gc3RyZWFtLnByb21pc2UoKS50aGVuKCgpID0+IGRvbmUsIGVyID0+IGVtaXR0ZWQgZXJyb3IpXG4gIHByb21pc2UgKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLm9uKERFU1RST1lFRCwgKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignc3RyZWFtIGRlc3Ryb3llZCcpKSlcbiAgICAgIHRoaXMub24oJ2VuZCcsICgpID0+IHJlc29sdmUoKSlcbiAgICAgIHRoaXMub24oJ2Vycm9yJywgZXIgPT4gcmVqZWN0KGVyKSlcbiAgICB9KVxuICB9XG5cbiAgLy8gZm9yIGF3YWl0IChsZXQgY2h1bmsgb2Ygc3RyZWFtKVxuICBbQVNZTkNJVEVSQVRPUl0gKCkge1xuICAgIGNvbnN0IG5leHQgPSAoKSA9PiB7XG4gICAgICBjb25zdCByZXMgPSB0aGlzLnJlYWQoKVxuICAgICAgaWYgKHJlcyAhPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGRvbmU6IGZhbHNlLCB2YWx1ZTogcmVzIH0pXG5cbiAgICAgIGlmICh0aGlzW0VPRl0pXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBkb25lOiB0cnVlIH0pXG5cbiAgICAgIGxldCByZXNvbHZlID0gbnVsbFxuICAgICAgbGV0IHJlamVjdCA9IG51bGxcbiAgICAgIGNvbnN0IG9uZXJyID0gZXIgPT4ge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKVxuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZClcbiAgICAgICAgcmVqZWN0KGVyKVxuICAgICAgfVxuICAgICAgY29uc3Qgb25kYXRhID0gdmFsdWUgPT4ge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyKVxuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZClcbiAgICAgICAgdGhpcy5wYXVzZSgpXG4gICAgICAgIHJlc29sdmUoeyB2YWx1ZTogdmFsdWUsIGRvbmU6ICEhdGhpc1tFT0ZdIH0pXG4gICAgICB9XG4gICAgICBjb25zdCBvbmVuZCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycilcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSlcbiAgICAgICAgcmVzb2x2ZSh7IGRvbmU6IHRydWUgfSlcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9uZGVzdHJveSA9ICgpID0+IG9uZXJyKG5ldyBFcnJvcignc3RyZWFtIGRlc3Ryb3llZCcpKVxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICByZWplY3QgPSByZWpcbiAgICAgICAgcmVzb2x2ZSA9IHJlc1xuICAgICAgICB0aGlzLm9uY2UoREVTVFJPWUVELCBvbmRlc3Ryb3kpXG4gICAgICAgIHRoaXMub25jZSgnZXJyb3InLCBvbmVycilcbiAgICAgICAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZClcbiAgICAgICAgdGhpcy5vbmNlKCdkYXRhJywgb25kYXRhKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4geyBuZXh0IH1cbiAgfVxuXG4gIC8vIGZvciAobGV0IGNodW5rIG9mIHN0cmVhbSlcbiAgW0lURVJBVE9SXSAoKSB7XG4gICAgY29uc3QgbmV4dCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5yZWFkKClcbiAgICAgIGNvbnN0IGRvbmUgPSB2YWx1ZSA9PT0gbnVsbFxuICAgICAgcmV0dXJuIHsgdmFsdWUsIGRvbmUgfVxuICAgIH1cbiAgICByZXR1cm4geyBuZXh0IH1cbiAgfVxuXG4gIGRlc3Ryb3kgKGVyKSB7XG4gICAgaWYgKHRoaXNbREVTVFJPWUVEXSkge1xuICAgICAgaWYgKGVyKVxuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgICBlbHNlXG4gICAgICAgIHRoaXMuZW1pdChERVNUUk9ZRUQpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHRoaXNbREVTVFJPWUVEXSA9IHRydWVcblxuICAgIC8vIHRocm93IGF3YXkgYWxsIGJ1ZmZlcmVkIGRhdGEsIGl0J3MgbmV2ZXIgY29taW5nIG91dFxuICAgIHRoaXMuYnVmZmVyID0gbmV3IFlhbGxpc3QoKVxuICAgIHRoaXNbQlVGRkVSTEVOR1RIXSA9IDBcblxuICAgIGlmICh0eXBlb2YgdGhpcy5jbG9zZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhdGhpc1tDTE9TRURdKVxuICAgICAgdGhpcy5jbG9zZSgpXG5cbiAgICBpZiAoZXIpXG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgZWxzZSAvLyBpZiBubyBlcnJvciB0byBlbWl0LCBzdGlsbCByZWplY3QgcGVuZGluZyBwcm9taXNlc1xuICAgICAgdGhpcy5lbWl0KERFU1RST1lFRClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGF0aWMgaXNTdHJlYW0gKHMpIHtcbiAgICByZXR1cm4gISFzICYmIChzIGluc3RhbmNlb2YgTWluaXBhc3MgfHwgcyBpbnN0YW5jZW9mIEVFICYmIChcbiAgICAgIHR5cGVvZiBzLnBpcGUgPT09ICdmdW5jdGlvbicgfHwgLy8gcmVhZGFibGVcbiAgICAgICh0eXBlb2Ygcy53cml0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygcy5lbmQgPT09ICdmdW5jdGlvbicpIC8vIHdyaXRhYmxlXG4gICAgKSlcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/minipass/index.js\n");

/***/ })

};
;