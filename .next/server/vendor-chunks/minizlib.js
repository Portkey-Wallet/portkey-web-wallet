/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/minizlib";
exports.ids = ["vendor-chunks/minizlib"];
exports.modules = {

/***/ "(ssr)/./node_modules/minizlib/constants.js":
/*!********************************************!*\
  !*** ./node_modules/minizlib/constants.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Update with any zlib constants that are added or changed in the future.\n// Node v6 didn't export this, so we just hard code the version and rely\n// on all the other hard-coded values from zlib v4736.  When node v6\n// support drops, we can just export the realZlibConstants object.\nconst realZlibConstants = (__webpack_require__(/*! zlib */ \"zlib\").constants) ||\n  /* istanbul ignore next */ { ZLIB_VERNUM: 4736 }\n\nmodule.exports = Object.freeze(Object.assign(Object.create(null), {\n  Z_NO_FLUSH: 0,\n  Z_PARTIAL_FLUSH: 1,\n  Z_SYNC_FLUSH: 2,\n  Z_FULL_FLUSH: 3,\n  Z_FINISH: 4,\n  Z_BLOCK: 5,\n  Z_OK: 0,\n  Z_STREAM_END: 1,\n  Z_NEED_DICT: 2,\n  Z_ERRNO: -1,\n  Z_STREAM_ERROR: -2,\n  Z_DATA_ERROR: -3,\n  Z_MEM_ERROR: -4,\n  Z_BUF_ERROR: -5,\n  Z_VERSION_ERROR: -6,\n  Z_NO_COMPRESSION: 0,\n  Z_BEST_SPEED: 1,\n  Z_BEST_COMPRESSION: 9,\n  Z_DEFAULT_COMPRESSION: -1,\n  Z_FILTERED: 1,\n  Z_HUFFMAN_ONLY: 2,\n  Z_RLE: 3,\n  Z_FIXED: 4,\n  Z_DEFAULT_STRATEGY: 0,\n  DEFLATE: 1,\n  INFLATE: 2,\n  GZIP: 3,\n  GUNZIP: 4,\n  DEFLATERAW: 5,\n  INFLATERAW: 6,\n  UNZIP: 7,\n  BROTLI_DECODE: 8,\n  BROTLI_ENCODE: 9,\n  Z_MIN_WINDOWBITS: 8,\n  Z_MAX_WINDOWBITS: 15,\n  Z_DEFAULT_WINDOWBITS: 15,\n  Z_MIN_CHUNK: 64,\n  Z_MAX_CHUNK: Infinity,\n  Z_DEFAULT_CHUNK: 16384,\n  Z_MIN_MEMLEVEL: 1,\n  Z_MAX_MEMLEVEL: 9,\n  Z_DEFAULT_MEMLEVEL: 8,\n  Z_MIN_LEVEL: -1,\n  Z_MAX_LEVEL: 9,\n  Z_DEFAULT_LEVEL: -1,\n  BROTLI_OPERATION_PROCESS: 0,\n  BROTLI_OPERATION_FLUSH: 1,\n  BROTLI_OPERATION_FINISH: 2,\n  BROTLI_OPERATION_EMIT_METADATA: 3,\n  BROTLI_MODE_GENERIC: 0,\n  BROTLI_MODE_TEXT: 1,\n  BROTLI_MODE_FONT: 2,\n  BROTLI_DEFAULT_MODE: 0,\n  BROTLI_MIN_QUALITY: 0,\n  BROTLI_MAX_QUALITY: 11,\n  BROTLI_DEFAULT_QUALITY: 11,\n  BROTLI_MIN_WINDOW_BITS: 10,\n  BROTLI_MAX_WINDOW_BITS: 24,\n  BROTLI_LARGE_MAX_WINDOW_BITS: 30,\n  BROTLI_DEFAULT_WINDOW: 22,\n  BROTLI_MIN_INPUT_BLOCK_BITS: 16,\n  BROTLI_MAX_INPUT_BLOCK_BITS: 24,\n  BROTLI_PARAM_MODE: 0,\n  BROTLI_PARAM_QUALITY: 1,\n  BROTLI_PARAM_LGWIN: 2,\n  BROTLI_PARAM_LGBLOCK: 3,\n  BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,\n  BROTLI_PARAM_SIZE_HINT: 5,\n  BROTLI_PARAM_LARGE_WINDOW: 6,\n  BROTLI_PARAM_NPOSTFIX: 7,\n  BROTLI_PARAM_NDIRECT: 8,\n  BROTLI_DECODER_RESULT_ERROR: 0,\n  BROTLI_DECODER_RESULT_SUCCESS: 1,\n  BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,\n  BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,\n  BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,\n  BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,\n  BROTLI_DECODER_NO_ERROR: 0,\n  BROTLI_DECODER_SUCCESS: 1,\n  BROTLI_DECODER_NEEDS_MORE_INPUT: 2,\n  BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,\n  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,\n  BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,\n  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,\n  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,\n  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,\n  BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,\n  BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,\n  BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,\n  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,\n  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,\n  BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,\n  BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,\n  BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,\n  BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,\n  BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,\n  BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,\n  BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,\n  BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,\n  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,\n  BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,\n  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,\n  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,\n  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,\n  BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,\n  BROTLI_DECODER_ERROR_UNREACHABLE: -31,\n}, realZlibConstants))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWluaXpsaWIvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1EQUF5QjtBQUNuRCwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHBvcnRrZXkvbmV4dC1leGFtcGxlLy4vbm9kZV9tb2R1bGVzL21pbml6bGliL2NvbnN0YW50cy5qcz9jOTJlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFVwZGF0ZSB3aXRoIGFueSB6bGliIGNvbnN0YW50cyB0aGF0IGFyZSBhZGRlZCBvciBjaGFuZ2VkIGluIHRoZSBmdXR1cmUuXG4vLyBOb2RlIHY2IGRpZG4ndCBleHBvcnQgdGhpcywgc28gd2UganVzdCBoYXJkIGNvZGUgdGhlIHZlcnNpb24gYW5kIHJlbHlcbi8vIG9uIGFsbCB0aGUgb3RoZXIgaGFyZC1jb2RlZCB2YWx1ZXMgZnJvbSB6bGliIHY0NzM2LiAgV2hlbiBub2RlIHY2XG4vLyBzdXBwb3J0IGRyb3BzLCB3ZSBjYW4ganVzdCBleHBvcnQgdGhlIHJlYWxabGliQ29uc3RhbnRzIG9iamVjdC5cbmNvbnN0IHJlYWxabGliQ29uc3RhbnRzID0gcmVxdWlyZSgnemxpYicpLmNvbnN0YW50cyB8fFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB7IFpMSUJfVkVSTlVNOiA0NzM2IH1cblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZnJlZXplKE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICBaX05PX0ZMVVNIOiAwLFxuICBaX1BBUlRJQUxfRkxVU0g6IDEsXG4gIFpfU1lOQ19GTFVTSDogMixcbiAgWl9GVUxMX0ZMVVNIOiAzLFxuICBaX0ZJTklTSDogNCxcbiAgWl9CTE9DSzogNSxcbiAgWl9PSzogMCxcbiAgWl9TVFJFQU1fRU5EOiAxLFxuICBaX05FRURfRElDVDogMixcbiAgWl9FUlJOTzogLTEsXG4gIFpfU1RSRUFNX0VSUk9SOiAtMixcbiAgWl9EQVRBX0VSUk9SOiAtMyxcbiAgWl9NRU1fRVJST1I6IC00LFxuICBaX0JVRl9FUlJPUjogLTUsXG4gIFpfVkVSU0lPTl9FUlJPUjogLTYsXG4gIFpfTk9fQ09NUFJFU1NJT046IDAsXG4gIFpfQkVTVF9TUEVFRDogMSxcbiAgWl9CRVNUX0NPTVBSRVNTSU9OOiA5LFxuICBaX0RFRkFVTFRfQ09NUFJFU1NJT046IC0xLFxuICBaX0ZJTFRFUkVEOiAxLFxuICBaX0hVRkZNQU5fT05MWTogMixcbiAgWl9STEU6IDMsXG4gIFpfRklYRUQ6IDQsXG4gIFpfREVGQVVMVF9TVFJBVEVHWTogMCxcbiAgREVGTEFURTogMSxcbiAgSU5GTEFURTogMixcbiAgR1pJUDogMyxcbiAgR1VOWklQOiA0LFxuICBERUZMQVRFUkFXOiA1LFxuICBJTkZMQVRFUkFXOiA2LFxuICBVTlpJUDogNyxcbiAgQlJPVExJX0RFQ09ERTogOCxcbiAgQlJPVExJX0VOQ09ERTogOSxcbiAgWl9NSU5fV0lORE9XQklUUzogOCxcbiAgWl9NQVhfV0lORE9XQklUUzogMTUsXG4gIFpfREVGQVVMVF9XSU5ET1dCSVRTOiAxNSxcbiAgWl9NSU5fQ0hVTks6IDY0LFxuICBaX01BWF9DSFVOSzogSW5maW5pdHksXG4gIFpfREVGQVVMVF9DSFVOSzogMTYzODQsXG4gIFpfTUlOX01FTUxFVkVMOiAxLFxuICBaX01BWF9NRU1MRVZFTDogOSxcbiAgWl9ERUZBVUxUX01FTUxFVkVMOiA4LFxuICBaX01JTl9MRVZFTDogLTEsXG4gIFpfTUFYX0xFVkVMOiA5LFxuICBaX0RFRkFVTFRfTEVWRUw6IC0xLFxuICBCUk9UTElfT1BFUkFUSU9OX1BST0NFU1M6IDAsXG4gIEJST1RMSV9PUEVSQVRJT05fRkxVU0g6IDEsXG4gIEJST1RMSV9PUEVSQVRJT05fRklOSVNIOiAyLFxuICBCUk9UTElfT1BFUkFUSU9OX0VNSVRfTUVUQURBVEE6IDMsXG4gIEJST1RMSV9NT0RFX0dFTkVSSUM6IDAsXG4gIEJST1RMSV9NT0RFX1RFWFQ6IDEsXG4gIEJST1RMSV9NT0RFX0ZPTlQ6IDIsXG4gIEJST1RMSV9ERUZBVUxUX01PREU6IDAsXG4gIEJST1RMSV9NSU5fUVVBTElUWTogMCxcbiAgQlJPVExJX01BWF9RVUFMSVRZOiAxMSxcbiAgQlJPVExJX0RFRkFVTFRfUVVBTElUWTogMTEsXG4gIEJST1RMSV9NSU5fV0lORE9XX0JJVFM6IDEwLFxuICBCUk9UTElfTUFYX1dJTkRPV19CSVRTOiAyNCxcbiAgQlJPVExJX0xBUkdFX01BWF9XSU5ET1dfQklUUzogMzAsXG4gIEJST1RMSV9ERUZBVUxUX1dJTkRPVzogMjIsXG4gIEJST1RMSV9NSU5fSU5QVVRfQkxPQ0tfQklUUzogMTYsXG4gIEJST1RMSV9NQVhfSU5QVVRfQkxPQ0tfQklUUzogMjQsXG4gIEJST1RMSV9QQVJBTV9NT0RFOiAwLFxuICBCUk9UTElfUEFSQU1fUVVBTElUWTogMSxcbiAgQlJPVExJX1BBUkFNX0xHV0lOOiAyLFxuICBCUk9UTElfUEFSQU1fTEdCTE9DSzogMyxcbiAgQlJPVExJX1BBUkFNX0RJU0FCTEVfTElURVJBTF9DT05URVhUX01PREVMSU5HOiA0LFxuICBCUk9UTElfUEFSQU1fU0laRV9ISU5UOiA1LFxuICBCUk9UTElfUEFSQU1fTEFSR0VfV0lORE9XOiA2LFxuICBCUk9UTElfUEFSQU1fTlBPU1RGSVg6IDcsXG4gIEJST1RMSV9QQVJBTV9ORElSRUNUOiA4LFxuICBCUk9UTElfREVDT0RFUl9SRVNVTFRfRVJST1I6IDAsXG4gIEJST1RMSV9ERUNPREVSX1JFU1VMVF9TVUNDRVNTOiAxLFxuICBCUk9UTElfREVDT0RFUl9SRVNVTFRfTkVFRFNfTU9SRV9JTlBVVDogMixcbiAgQlJPVExJX0RFQ09ERVJfUkVTVUxUX05FRURTX01PUkVfT1VUUFVUOiAzLFxuICBCUk9UTElfREVDT0RFUl9QQVJBTV9ESVNBQkxFX1JJTkdfQlVGRkVSX1JFQUxMT0NBVElPTjogMCxcbiAgQlJPVExJX0RFQ09ERVJfUEFSQU1fTEFSR0VfV0lORE9XOiAxLFxuICBCUk9UTElfREVDT0RFUl9OT19FUlJPUjogMCxcbiAgQlJPVExJX0RFQ09ERVJfU1VDQ0VTUzogMSxcbiAgQlJPVExJX0RFQ09ERVJfTkVFRFNfTU9SRV9JTlBVVDogMixcbiAgQlJPVExJX0RFQ09ERVJfTkVFRFNfTU9SRV9PVVRQVVQ6IDMsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9FWFVCRVJBTlRfTklCQkxFOiAtMSxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX1JFU0VSVkVEOiAtMixcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX0VYVUJFUkFOVF9NRVRBX05JQkJMRTogLTMsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9TSU1QTEVfSFVGRk1BTl9BTFBIQUJFVDogLTQsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9TSU1QTEVfSFVGRk1BTl9TQU1FOiAtNSxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX0NMX1NQQUNFOiAtNixcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX0hVRkZNQU5fU1BBQ0U6IC03LFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfQ09OVEVYVF9NQVBfUkVQRUFUOiAtOCxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX0JMT0NLX0xFTkdUSF8xOiAtOSxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX0JMT0NLX0xFTkdUSF8yOiAtMTAsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9UUkFOU0ZPUk06IC0xMSxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX0RJQ1RJT05BUlk6IC0xMixcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX1dJTkRPV19CSVRTOiAtMTMsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9QQURESU5HXzE6IC0xNCxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX1BBRERJTkdfMjogLTE1LFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfRElTVEFOQ0U6IC0xNixcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRElDVElPTkFSWV9OT1RfU0VUOiAtMTksXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0lOVkFMSURfQVJHVU1FTlRTOiAtMjAsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0FMTE9DX0NPTlRFWFRfTU9ERVM6IC0yMSxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfQUxMT0NfVFJFRV9HUk9VUFM6IC0yMixcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfQUxMT0NfQ09OVEVYVF9NQVA6IC0yNSxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfQUxMT0NfUklOR19CVUZGRVJfMTogLTI2LFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9BTExPQ19SSU5HX0JVRkZFUl8yOiAtMjcsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0FMTE9DX0JMT0NLX1RZUEVfVFJFRVM6IC0zMCxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfVU5SRUFDSEFCTEU6IC0zMSxcbn0sIHJlYWxabGliQ29uc3RhbnRzKSlcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/minizlib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/minizlib/index.js":
/*!****************************************!*\
  !*** ./node_modules/minizlib/index.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer)\nconst realZlib = __webpack_require__(/*! zlib */ \"zlib\")\n\nconst constants = exports.constants = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/minizlib/constants.js\")\nconst Minipass = __webpack_require__(/*! minipass */ \"(ssr)/./node_modules/minipass/index.js\")\n\nconst OriginalBufferConcat = Buffer.concat\n\nclass ZlibError extends Error {\n  constructor (err) {\n    super('zlib: ' + err.message)\n    this.code = err.code\n    this.errno = err.errno\n    /* istanbul ignore if */\n    if (!this.code)\n      this.code = 'ZLIB_ERROR'\n\n    this.message = 'zlib: ' + err.message\n    Error.captureStackTrace(this, this.constructor)\n  }\n\n  get name () {\n    return 'ZlibError'\n  }\n}\n\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\nconst _opts = Symbol('opts')\nconst _flushFlag = Symbol('flushFlag')\nconst _finishFlushFlag = Symbol('finishFlushFlag')\nconst _fullFlushFlag = Symbol('fullFlushFlag')\nconst _handle = Symbol('handle')\nconst _onError = Symbol('onError')\nconst _sawError = Symbol('sawError')\nconst _level = Symbol('level')\nconst _strategy = Symbol('strategy')\nconst _ended = Symbol('ended')\nconst _defaultFullFlush = Symbol('_defaultFullFlush')\n\nclass ZlibBase extends Minipass {\n  constructor (opts, mode) {\n    if (!opts || typeof opts !== 'object')\n      throw new TypeError('invalid options for ZlibBase constructor')\n\n    super(opts)\n    this[_ended] = false\n    this[_opts] = opts\n\n    this[_flushFlag] = opts.flush\n    this[_finishFlushFlag] = opts.finishFlush\n    // this will throw if any options are invalid for the class selected\n    try {\n      this[_handle] = new realZlib[mode](opts)\n    } catch (er) {\n      // make sure that all errors get decorated properly\n      throw new ZlibError(er)\n    }\n\n    this[_onError] = (err) => {\n      this[_sawError] = true\n      // there is no way to cleanly recover.\n      // continuing only obscures problems.\n      this.close()\n      this.emit('error', err)\n    }\n\n    this[_handle].on('error', er => this[_onError](new ZlibError(er)))\n    this.once('end', () => this.close)\n  }\n\n  close () {\n    if (this[_handle]) {\n      this[_handle].close()\n      this[_handle] = null\n      this.emit('close')\n    }\n  }\n\n  reset () {\n    if (!this[_sawError]) {\n      assert(this[_handle], 'zlib binding closed')\n      return this[_handle].reset()\n    }\n  }\n\n  flush (flushFlag) {\n    if (this.ended)\n      return\n\n    if (typeof flushFlag !== 'number')\n      flushFlag = this[_fullFlushFlag]\n    this.write(Object.assign(Buffer.alloc(0), { [_flushFlag]: flushFlag }))\n  }\n\n  end (chunk, encoding, cb) {\n    if (chunk)\n      this.write(chunk, encoding)\n    this.flush(this[_finishFlushFlag])\n    this[_ended] = true\n    return super.end(null, null, cb)\n  }\n\n  get ended () {\n    return this[_ended]\n  }\n\n  write (chunk, encoding, cb) {\n    // process the chunk using the sync process\n    // then super.write() all the outputted chunks\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (typeof chunk === 'string')\n      chunk = Buffer.from(chunk, encoding)\n\n    if (this[_sawError])\n      return\n    assert(this[_handle], 'zlib binding closed')\n\n    // _processChunk tries to .close() the native handle after it's done, so we\n    // intercept that by temporarily making it a no-op.\n    const nativeHandle = this[_handle]._handle\n    const originalNativeClose = nativeHandle.close\n    nativeHandle.close = () => {}\n    const originalClose = this[_handle].close\n    this[_handle].close = () => {}\n    // It also calls `Buffer.concat()` at the end, which may be convenient\n    // for some, but which we are not interested in as it slows us down.\n    Buffer.concat = (args) => args\n    let result\n    try {\n      const flushFlag = typeof chunk[_flushFlag] === 'number'\n        ? chunk[_flushFlag] : this[_flushFlag]\n      result = this[_handle]._processChunk(chunk, flushFlag)\n      // if we don't throw, reset it back how it was\n      Buffer.concat = OriginalBufferConcat\n    } catch (err) {\n      // or if we do, put Buffer.concat() back before we emit error\n      // Error events call into user code, which may call Buffer.concat()\n      Buffer.concat = OriginalBufferConcat\n      this[_onError](new ZlibError(err))\n    } finally {\n      if (this[_handle]) {\n        // Core zlib resets `_handle` to null after attempting to close the\n        // native handle. Our no-op handler prevented actual closure, but we\n        // need to restore the `._handle` property.\n        this[_handle]._handle = nativeHandle\n        nativeHandle.close = originalNativeClose\n        this[_handle].close = originalClose\n        // `_processChunk()` adds an 'error' listener. If we don't remove it\n        // after each call, these handlers start piling up.\n        this[_handle].removeAllListeners('error')\n      }\n    }\n\n    let writeReturn\n    if (result) {\n      if (Array.isArray(result) && result.length > 0) {\n        // The first buffer is always `handle._outBuffer`, which would be\n        // re-used for later invocations; so, we always have to copy that one.\n        writeReturn = super.write(Buffer.from(result[0]))\n        for (let i = 1; i < result.length; i++) {\n          writeReturn = super.write(result[i])\n        }\n      } else {\n        writeReturn = super.write(Buffer.from(result))\n      }\n    }\n\n    if (cb)\n      cb()\n    return writeReturn\n  }\n}\n\nclass Zlib extends ZlibBase {\n  constructor (opts, mode) {\n    opts = opts || {}\n\n    opts.flush = opts.flush || constants.Z_NO_FLUSH\n    opts.finishFlush = opts.finishFlush || constants.Z_FINISH\n    super(opts, mode)\n\n    this[_fullFlushFlag] = constants.Z_FULL_FLUSH\n    this[_level] = opts.level\n    this[_strategy] = opts.strategy\n  }\n\n  params (level, strategy) {\n    if (this[_sawError])\n      return\n\n    if (!this[_handle])\n      throw new Error('cannot switch params when binding is closed')\n\n    // no way to test this without also not supporting params at all\n    /* istanbul ignore if */\n    if (!this[_handle].params)\n      throw new Error('not supported in this implementation')\n\n    if (this[_level] !== level || this[_strategy] !== strategy) {\n      this.flush(constants.Z_SYNC_FLUSH)\n      assert(this[_handle], 'zlib binding closed')\n      // .params() calls .flush(), but the latter is always async in the\n      // core zlib. We override .flush() temporarily to intercept that and\n      // flush synchronously.\n      const origFlush = this[_handle].flush\n      this[_handle].flush = (flushFlag, cb) => {\n        this.flush(flushFlag)\n        cb()\n      }\n      try {\n        this[_handle].params(level, strategy)\n      } finally {\n        this[_handle].flush = origFlush\n      }\n      /* istanbul ignore else */\n      if (this[_handle]) {\n        this[_level] = level\n        this[_strategy] = strategy\n      }\n    }\n  }\n}\n\n// minimal 2-byte header\nclass Deflate extends Zlib {\n  constructor (opts) {\n    super(opts, 'Deflate')\n  }\n}\n\nclass Inflate extends Zlib {\n  constructor (opts) {\n    super(opts, 'Inflate')\n  }\n}\n\n// gzip - bigger header, same deflate compression\nclass Gzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Gzip')\n  }\n}\n\nclass Gunzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Gunzip')\n  }\n}\n\n// raw - no header\nclass DeflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, 'DeflateRaw')\n  }\n}\n\nclass InflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, 'InflateRaw')\n  }\n}\n\n// auto-detect header.\nclass Unzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Unzip')\n  }\n}\n\nclass Brotli extends ZlibBase {\n  constructor (opts, mode) {\n    opts = opts || {}\n\n    opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS\n    opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH\n\n    super(opts, mode)\n\n    this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH\n  }\n}\n\nclass BrotliCompress extends Brotli {\n  constructor (opts) {\n    super(opts, 'BrotliCompress')\n  }\n}\n\nclass BrotliDecompress extends Brotli {\n  constructor (opts) {\n    super(opts, 'BrotliDecompress')\n  }\n}\n\nexports.Deflate = Deflate\nexports.Inflate = Inflate\nexports.Gzip = Gzip\nexports.Gunzip = Gunzip\nexports.DeflateRaw = DeflateRaw\nexports.InflateRaw = InflateRaw\nexports.Unzip = Unzip\n/* istanbul ignore else */\nif (typeof realZlib.BrotliCompress === 'function') {\n  exports.BrotliCompress = BrotliCompress\n  exports.BrotliDecompress = BrotliDecompress\n} else {\n  exports.BrotliCompress = exports.BrotliDecompress = class {\n    constructor () {\n      throw new Error('Brotli is not supported in this version of Node.js')\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWluaXpsaWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLGVBQWUsb0RBQXdCO0FBQ3ZDLGlCQUFpQixtQkFBTyxDQUFDLGtCQUFNOztBQUUvQixrQkFBa0IsMkdBQTZDO0FBQy9ELGlCQUFpQixtQkFBTyxDQUFDLHdEQUFVOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QseUJBQXlCO0FBQ3pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmLGVBQWU7QUFDZixZQUFZO0FBQ1osY0FBYztBQUNkLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxFQUFFLHNCQUFzQjtBQUN4QixFQUFFLHdCQUF3QjtBQUMxQixFQUFFO0FBQ0YsRUFBRSxzQkFBc0IsR0FBRyx3QkFBd0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0Bwb3J0a2V5L25leHQtZXhhbXBsZS8uL25vZGVfbW9kdWxlcy9taW5pemxpYi9pbmRleC5qcz9jNzgwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyXG5jb25zdCByZWFsWmxpYiA9IHJlcXVpcmUoJ3psaWInKVxuXG5jb25zdCBjb25zdGFudHMgPSBleHBvcnRzLmNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzLmpzJylcbmNvbnN0IE1pbmlwYXNzID0gcmVxdWlyZSgnbWluaXBhc3MnKVxuXG5jb25zdCBPcmlnaW5hbEJ1ZmZlckNvbmNhdCA9IEJ1ZmZlci5jb25jYXRcblxuY2xhc3MgWmxpYkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAoZXJyKSB7XG4gICAgc3VwZXIoJ3psaWI6ICcgKyBlcnIubWVzc2FnZSlcbiAgICB0aGlzLmNvZGUgPSBlcnIuY29kZVxuICAgIHRoaXMuZXJybm8gPSBlcnIuZXJybm9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXRoaXMuY29kZSlcbiAgICAgIHRoaXMuY29kZSA9ICdaTElCX0VSUk9SJ1xuXG4gICAgdGhpcy5tZXNzYWdlID0gJ3psaWI6ICcgKyBlcnIubWVzc2FnZVxuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpXG4gIH1cblxuICBnZXQgbmFtZSAoKSB7XG4gICAgcmV0dXJuICdabGliRXJyb3InXG4gIH1cbn1cblxuLy8gdGhlIFpsaWIgY2xhc3MgdGhleSBhbGwgaW5oZXJpdCBmcm9tXG4vLyBUaGlzIHRoaW5nIG1hbmFnZXMgdGhlIHF1ZXVlIG9mIHJlcXVlc3RzLCBhbmQgcmV0dXJuc1xuLy8gdHJ1ZSBvciBmYWxzZSBpZiB0aGVyZSBpcyBhbnl0aGluZyBpbiB0aGUgcXVldWUgd2hlblxuLy8geW91IGNhbGwgdGhlIC53cml0ZSgpIG1ldGhvZC5cbmNvbnN0IF9vcHRzID0gU3ltYm9sKCdvcHRzJylcbmNvbnN0IF9mbHVzaEZsYWcgPSBTeW1ib2woJ2ZsdXNoRmxhZycpXG5jb25zdCBfZmluaXNoRmx1c2hGbGFnID0gU3ltYm9sKCdmaW5pc2hGbHVzaEZsYWcnKVxuY29uc3QgX2Z1bGxGbHVzaEZsYWcgPSBTeW1ib2woJ2Z1bGxGbHVzaEZsYWcnKVxuY29uc3QgX2hhbmRsZSA9IFN5bWJvbCgnaGFuZGxlJylcbmNvbnN0IF9vbkVycm9yID0gU3ltYm9sKCdvbkVycm9yJylcbmNvbnN0IF9zYXdFcnJvciA9IFN5bWJvbCgnc2F3RXJyb3InKVxuY29uc3QgX2xldmVsID0gU3ltYm9sKCdsZXZlbCcpXG5jb25zdCBfc3RyYXRlZ3kgPSBTeW1ib2woJ3N0cmF0ZWd5JylcbmNvbnN0IF9lbmRlZCA9IFN5bWJvbCgnZW5kZWQnKVxuY29uc3QgX2RlZmF1bHRGdWxsRmx1c2ggPSBTeW1ib2woJ19kZWZhdWx0RnVsbEZsdXNoJylcblxuY2xhc3MgWmxpYkJhc2UgZXh0ZW5kcyBNaW5pcGFzcyB7XG4gIGNvbnN0cnVjdG9yIChvcHRzLCBtb2RlKSB7XG4gICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0JylcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgb3B0aW9ucyBmb3IgWmxpYkJhc2UgY29uc3RydWN0b3InKVxuXG4gICAgc3VwZXIob3B0cylcbiAgICB0aGlzW19lbmRlZF0gPSBmYWxzZVxuICAgIHRoaXNbX29wdHNdID0gb3B0c1xuXG4gICAgdGhpc1tfZmx1c2hGbGFnXSA9IG9wdHMuZmx1c2hcbiAgICB0aGlzW19maW5pc2hGbHVzaEZsYWddID0gb3B0cy5maW5pc2hGbHVzaFxuICAgIC8vIHRoaXMgd2lsbCB0aHJvdyBpZiBhbnkgb3B0aW9ucyBhcmUgaW52YWxpZCBmb3IgdGhlIGNsYXNzIHNlbGVjdGVkXG4gICAgdHJ5IHtcbiAgICAgIHRoaXNbX2hhbmRsZV0gPSBuZXcgcmVhbFpsaWJbbW9kZV0ob3B0cylcbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgYWxsIGVycm9ycyBnZXQgZGVjb3JhdGVkIHByb3Blcmx5XG4gICAgICB0aHJvdyBuZXcgWmxpYkVycm9yKGVyKVxuICAgIH1cblxuICAgIHRoaXNbX29uRXJyb3JdID0gKGVycikgPT4ge1xuICAgICAgdGhpc1tfc2F3RXJyb3JdID0gdHJ1ZVxuICAgICAgLy8gdGhlcmUgaXMgbm8gd2F5IHRvIGNsZWFubHkgcmVjb3Zlci5cbiAgICAgIC8vIGNvbnRpbnVpbmcgb25seSBvYnNjdXJlcyBwcm9ibGVtcy5cbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycilcbiAgICB9XG5cbiAgICB0aGlzW19oYW5kbGVdLm9uKCdlcnJvcicsIGVyID0+IHRoaXNbX29uRXJyb3JdKG5ldyBabGliRXJyb3IoZXIpKSlcbiAgICB0aGlzLm9uY2UoJ2VuZCcsICgpID0+IHRoaXMuY2xvc2UpXG4gIH1cblxuICBjbG9zZSAoKSB7XG4gICAgaWYgKHRoaXNbX2hhbmRsZV0pIHtcbiAgICAgIHRoaXNbX2hhbmRsZV0uY2xvc2UoKVxuICAgICAgdGhpc1tfaGFuZGxlXSA9IG51bGxcbiAgICAgIHRoaXMuZW1pdCgnY2xvc2UnKVxuICAgIH1cbiAgfVxuXG4gIHJlc2V0ICgpIHtcbiAgICBpZiAoIXRoaXNbX3Nhd0Vycm9yXSkge1xuICAgICAgYXNzZXJ0KHRoaXNbX2hhbmRsZV0sICd6bGliIGJpbmRpbmcgY2xvc2VkJylcbiAgICAgIHJldHVybiB0aGlzW19oYW5kbGVdLnJlc2V0KClcbiAgICB9XG4gIH1cblxuICBmbHVzaCAoZmx1c2hGbGFnKSB7XG4gICAgaWYgKHRoaXMuZW5kZWQpXG4gICAgICByZXR1cm5cblxuICAgIGlmICh0eXBlb2YgZmx1c2hGbGFnICE9PSAnbnVtYmVyJylcbiAgICAgIGZsdXNoRmxhZyA9IHRoaXNbX2Z1bGxGbHVzaEZsYWddXG4gICAgdGhpcy53cml0ZShPYmplY3QuYXNzaWduKEJ1ZmZlci5hbGxvYygwKSwgeyBbX2ZsdXNoRmxhZ106IGZsdXNoRmxhZyB9KSlcbiAgfVxuXG4gIGVuZCAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIGlmIChjaHVuaylcbiAgICAgIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKVxuICAgIHRoaXMuZmx1c2godGhpc1tfZmluaXNoRmx1c2hGbGFnXSlcbiAgICB0aGlzW19lbmRlZF0gPSB0cnVlXG4gICAgcmV0dXJuIHN1cGVyLmVuZChudWxsLCBudWxsLCBjYilcbiAgfVxuXG4gIGdldCBlbmRlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXNbX2VuZGVkXVxuICB9XG5cbiAgd3JpdGUgKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICAvLyBwcm9jZXNzIHRoZSBjaHVuayB1c2luZyB0aGUgc3luYyBwcm9jZXNzXG4gICAgLy8gdGhlbiBzdXBlci53cml0ZSgpIGFsbCB0aGUgb3V0cHV0dGVkIGNodW5rc1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IGVuY29kaW5nLCBlbmNvZGluZyA9ICd1dGY4J1xuXG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpXG4gICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZylcblxuICAgIGlmICh0aGlzW19zYXdFcnJvcl0pXG4gICAgICByZXR1cm5cbiAgICBhc3NlcnQodGhpc1tfaGFuZGxlXSwgJ3psaWIgYmluZGluZyBjbG9zZWQnKVxuXG4gICAgLy8gX3Byb2Nlc3NDaHVuayB0cmllcyB0byAuY2xvc2UoKSB0aGUgbmF0aXZlIGhhbmRsZSBhZnRlciBpdCdzIGRvbmUsIHNvIHdlXG4gICAgLy8gaW50ZXJjZXB0IHRoYXQgYnkgdGVtcG9yYXJpbHkgbWFraW5nIGl0IGEgbm8tb3AuXG4gICAgY29uc3QgbmF0aXZlSGFuZGxlID0gdGhpc1tfaGFuZGxlXS5faGFuZGxlXG4gICAgY29uc3Qgb3JpZ2luYWxOYXRpdmVDbG9zZSA9IG5hdGl2ZUhhbmRsZS5jbG9zZVxuICAgIG5hdGl2ZUhhbmRsZS5jbG9zZSA9ICgpID0+IHt9XG4gICAgY29uc3Qgb3JpZ2luYWxDbG9zZSA9IHRoaXNbX2hhbmRsZV0uY2xvc2VcbiAgICB0aGlzW19oYW5kbGVdLmNsb3NlID0gKCkgPT4ge31cbiAgICAvLyBJdCBhbHNvIGNhbGxzIGBCdWZmZXIuY29uY2F0KClgIGF0IHRoZSBlbmQsIHdoaWNoIG1heSBiZSBjb252ZW5pZW50XG4gICAgLy8gZm9yIHNvbWUsIGJ1dCB3aGljaCB3ZSBhcmUgbm90IGludGVyZXN0ZWQgaW4gYXMgaXQgc2xvd3MgdXMgZG93bi5cbiAgICBCdWZmZXIuY29uY2F0ID0gKGFyZ3MpID0+IGFyZ3NcbiAgICBsZXQgcmVzdWx0XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZsdXNoRmxhZyA9IHR5cGVvZiBjaHVua1tfZmx1c2hGbGFnXSA9PT0gJ251bWJlcidcbiAgICAgICAgPyBjaHVua1tfZmx1c2hGbGFnXSA6IHRoaXNbX2ZsdXNoRmxhZ11cbiAgICAgIHJlc3VsdCA9IHRoaXNbX2hhbmRsZV0uX3Byb2Nlc3NDaHVuayhjaHVuaywgZmx1c2hGbGFnKVxuICAgICAgLy8gaWYgd2UgZG9uJ3QgdGhyb3csIHJlc2V0IGl0IGJhY2sgaG93IGl0IHdhc1xuICAgICAgQnVmZmVyLmNvbmNhdCA9IE9yaWdpbmFsQnVmZmVyQ29uY2F0XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBvciBpZiB3ZSBkbywgcHV0IEJ1ZmZlci5jb25jYXQoKSBiYWNrIGJlZm9yZSB3ZSBlbWl0IGVycm9yXG4gICAgICAvLyBFcnJvciBldmVudHMgY2FsbCBpbnRvIHVzZXIgY29kZSwgd2hpY2ggbWF5IGNhbGwgQnVmZmVyLmNvbmNhdCgpXG4gICAgICBCdWZmZXIuY29uY2F0ID0gT3JpZ2luYWxCdWZmZXJDb25jYXRcbiAgICAgIHRoaXNbX29uRXJyb3JdKG5ldyBabGliRXJyb3IoZXJyKSlcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHRoaXNbX2hhbmRsZV0pIHtcbiAgICAgICAgLy8gQ29yZSB6bGliIHJlc2V0cyBgX2hhbmRsZWAgdG8gbnVsbCBhZnRlciBhdHRlbXB0aW5nIHRvIGNsb3NlIHRoZVxuICAgICAgICAvLyBuYXRpdmUgaGFuZGxlLiBPdXIgbm8tb3AgaGFuZGxlciBwcmV2ZW50ZWQgYWN0dWFsIGNsb3N1cmUsIGJ1dCB3ZVxuICAgICAgICAvLyBuZWVkIHRvIHJlc3RvcmUgdGhlIGAuX2hhbmRsZWAgcHJvcGVydHkuXG4gICAgICAgIHRoaXNbX2hhbmRsZV0uX2hhbmRsZSA9IG5hdGl2ZUhhbmRsZVxuICAgICAgICBuYXRpdmVIYW5kbGUuY2xvc2UgPSBvcmlnaW5hbE5hdGl2ZUNsb3NlXG4gICAgICAgIHRoaXNbX2hhbmRsZV0uY2xvc2UgPSBvcmlnaW5hbENsb3NlXG4gICAgICAgIC8vIGBfcHJvY2Vzc0NodW5rKClgIGFkZHMgYW4gJ2Vycm9yJyBsaXN0ZW5lci4gSWYgd2UgZG9uJ3QgcmVtb3ZlIGl0XG4gICAgICAgIC8vIGFmdGVyIGVhY2ggY2FsbCwgdGhlc2UgaGFuZGxlcnMgc3RhcnQgcGlsaW5nIHVwLlxuICAgICAgICB0aGlzW19oYW5kbGVdLnJlbW92ZUFsbExpc3RlbmVycygnZXJyb3InKVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCB3cml0ZVJldHVyblxuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkgJiYgcmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gVGhlIGZpcnN0IGJ1ZmZlciBpcyBhbHdheXMgYGhhbmRsZS5fb3V0QnVmZmVyYCwgd2hpY2ggd291bGQgYmVcbiAgICAgICAgLy8gcmUtdXNlZCBmb3IgbGF0ZXIgaW52b2NhdGlvbnM7IHNvLCB3ZSBhbHdheXMgaGF2ZSB0byBjb3B5IHRoYXQgb25lLlxuICAgICAgICB3cml0ZVJldHVybiA9IHN1cGVyLndyaXRlKEJ1ZmZlci5mcm9tKHJlc3VsdFswXSkpXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgd3JpdGVSZXR1cm4gPSBzdXBlci53cml0ZShyZXN1bHRbaV0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlUmV0dXJuID0gc3VwZXIud3JpdGUoQnVmZmVyLmZyb20ocmVzdWx0KSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2IpXG4gICAgICBjYigpXG4gICAgcmV0dXJuIHdyaXRlUmV0dXJuXG4gIH1cbn1cblxuY2xhc3MgWmxpYiBleHRlbmRzIFpsaWJCYXNlIHtcbiAgY29uc3RydWN0b3IgKG9wdHMsIG1vZGUpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgb3B0cy5mbHVzaCA9IG9wdHMuZmx1c2ggfHwgY29uc3RhbnRzLlpfTk9fRkxVU0hcbiAgICBvcHRzLmZpbmlzaEZsdXNoID0gb3B0cy5maW5pc2hGbHVzaCB8fCBjb25zdGFudHMuWl9GSU5JU0hcbiAgICBzdXBlcihvcHRzLCBtb2RlKVxuXG4gICAgdGhpc1tfZnVsbEZsdXNoRmxhZ10gPSBjb25zdGFudHMuWl9GVUxMX0ZMVVNIXG4gICAgdGhpc1tfbGV2ZWxdID0gb3B0cy5sZXZlbFxuICAgIHRoaXNbX3N0cmF0ZWd5XSA9IG9wdHMuc3RyYXRlZ3lcbiAgfVxuXG4gIHBhcmFtcyAobGV2ZWwsIHN0cmF0ZWd5KSB7XG4gICAgaWYgKHRoaXNbX3Nhd0Vycm9yXSlcbiAgICAgIHJldHVyblxuXG4gICAgaWYgKCF0aGlzW19oYW5kbGVdKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3Qgc3dpdGNoIHBhcmFtcyB3aGVuIGJpbmRpbmcgaXMgY2xvc2VkJylcblxuICAgIC8vIG5vIHdheSB0byB0ZXN0IHRoaXMgd2l0aG91dCBhbHNvIG5vdCBzdXBwb3J0aW5nIHBhcmFtcyBhdCBhbGxcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXRoaXNbX2hhbmRsZV0ucGFyYW1zKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3Qgc3VwcG9ydGVkIGluIHRoaXMgaW1wbGVtZW50YXRpb24nKVxuXG4gICAgaWYgKHRoaXNbX2xldmVsXSAhPT0gbGV2ZWwgfHwgdGhpc1tfc3RyYXRlZ3ldICE9PSBzdHJhdGVneSkge1xuICAgICAgdGhpcy5mbHVzaChjb25zdGFudHMuWl9TWU5DX0ZMVVNIKVxuICAgICAgYXNzZXJ0KHRoaXNbX2hhbmRsZV0sICd6bGliIGJpbmRpbmcgY2xvc2VkJylcbiAgICAgIC8vIC5wYXJhbXMoKSBjYWxscyAuZmx1c2goKSwgYnV0IHRoZSBsYXR0ZXIgaXMgYWx3YXlzIGFzeW5jIGluIHRoZVxuICAgICAgLy8gY29yZSB6bGliLiBXZSBvdmVycmlkZSAuZmx1c2goKSB0ZW1wb3JhcmlseSB0byBpbnRlcmNlcHQgdGhhdCBhbmRcbiAgICAgIC8vIGZsdXNoIHN5bmNocm9ub3VzbHkuXG4gICAgICBjb25zdCBvcmlnRmx1c2ggPSB0aGlzW19oYW5kbGVdLmZsdXNoXG4gICAgICB0aGlzW19oYW5kbGVdLmZsdXNoID0gKGZsdXNoRmxhZywgY2IpID0+IHtcbiAgICAgICAgdGhpcy5mbHVzaChmbHVzaEZsYWcpXG4gICAgICAgIGNiKClcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXNbX2hhbmRsZV0ucGFyYW1zKGxldmVsLCBzdHJhdGVneSlcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXNbX2hhbmRsZV0uZmx1c2ggPSBvcmlnRmx1c2hcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAodGhpc1tfaGFuZGxlXSkge1xuICAgICAgICB0aGlzW19sZXZlbF0gPSBsZXZlbFxuICAgICAgICB0aGlzW19zdHJhdGVneV0gPSBzdHJhdGVneVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBtaW5pbWFsIDItYnl0ZSBoZWFkZXJcbmNsYXNzIERlZmxhdGUgZXh0ZW5kcyBabGliIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzLCAnRGVmbGF0ZScpXG4gIH1cbn1cblxuY2xhc3MgSW5mbGF0ZSBleHRlbmRzIFpsaWIge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMsICdJbmZsYXRlJylcbiAgfVxufVxuXG4vLyBnemlwIC0gYmlnZ2VyIGhlYWRlciwgc2FtZSBkZWZsYXRlIGNvbXByZXNzaW9uXG5jbGFzcyBHemlwIGV4dGVuZHMgWmxpYiB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIob3B0cywgJ0d6aXAnKVxuICB9XG59XG5cbmNsYXNzIEd1bnppcCBleHRlbmRzIFpsaWIge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMsICdHdW56aXAnKVxuICB9XG59XG5cbi8vIHJhdyAtIG5vIGhlYWRlclxuY2xhc3MgRGVmbGF0ZVJhdyBleHRlbmRzIFpsaWIge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMsICdEZWZsYXRlUmF3JylcbiAgfVxufVxuXG5jbGFzcyBJbmZsYXRlUmF3IGV4dGVuZHMgWmxpYiB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIob3B0cywgJ0luZmxhdGVSYXcnKVxuICB9XG59XG5cbi8vIGF1dG8tZGV0ZWN0IGhlYWRlci5cbmNsYXNzIFVuemlwIGV4dGVuZHMgWmxpYiB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIob3B0cywgJ1VuemlwJylcbiAgfVxufVxuXG5jbGFzcyBCcm90bGkgZXh0ZW5kcyBabGliQmFzZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzLCBtb2RlKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge31cblxuICAgIG9wdHMuZmx1c2ggPSBvcHRzLmZsdXNoIHx8IGNvbnN0YW50cy5CUk9UTElfT1BFUkFUSU9OX1BST0NFU1NcbiAgICBvcHRzLmZpbmlzaEZsdXNoID0gb3B0cy5maW5pc2hGbHVzaCB8fCBjb25zdGFudHMuQlJPVExJX09QRVJBVElPTl9GSU5JU0hcblxuICAgIHN1cGVyKG9wdHMsIG1vZGUpXG5cbiAgICB0aGlzW19mdWxsRmx1c2hGbGFnXSA9IGNvbnN0YW50cy5CUk9UTElfT1BFUkFUSU9OX0ZMVVNIXG4gIH1cbn1cblxuY2xhc3MgQnJvdGxpQ29tcHJlc3MgZXh0ZW5kcyBCcm90bGkge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMsICdCcm90bGlDb21wcmVzcycpXG4gIH1cbn1cblxuY2xhc3MgQnJvdGxpRGVjb21wcmVzcyBleHRlbmRzIEJyb3RsaSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIob3B0cywgJ0Jyb3RsaURlY29tcHJlc3MnKVxuICB9XG59XG5cbmV4cG9ydHMuRGVmbGF0ZSA9IERlZmxhdGVcbmV4cG9ydHMuSW5mbGF0ZSA9IEluZmxhdGVcbmV4cG9ydHMuR3ppcCA9IEd6aXBcbmV4cG9ydHMuR3VuemlwID0gR3VuemlwXG5leHBvcnRzLkRlZmxhdGVSYXcgPSBEZWZsYXRlUmF3XG5leHBvcnRzLkluZmxhdGVSYXcgPSBJbmZsYXRlUmF3XG5leHBvcnRzLlVuemlwID0gVW56aXBcbi8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5pZiAodHlwZW9mIHJlYWxabGliLkJyb3RsaUNvbXByZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gIGV4cG9ydHMuQnJvdGxpQ29tcHJlc3MgPSBCcm90bGlDb21wcmVzc1xuICBleHBvcnRzLkJyb3RsaURlY29tcHJlc3MgPSBCcm90bGlEZWNvbXByZXNzXG59IGVsc2Uge1xuICBleHBvcnRzLkJyb3RsaUNvbXByZXNzID0gZXhwb3J0cy5Ccm90bGlEZWNvbXByZXNzID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQnJvdGxpIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyB2ZXJzaW9uIG9mIE5vZGUuanMnKVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/minizlib/index.js\n");

/***/ })

};
;