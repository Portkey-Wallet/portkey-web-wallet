/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mock-fs";
exports.ids = ["vendor-chunks/mock-fs"];
exports.modules = {

/***/ "(ssr)/./node_modules/mock-fs/lib/binding.js":
/*!*********************************************!*\
  !*** ./node_modules/mock-fs/lib/binding.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst path = __webpack_require__(/*! path */ \"path\");\n\nconst File = __webpack_require__(/*! ./file */ \"(ssr)/./node_modules/mock-fs/lib/file.js\");\nconst FileDescriptor = __webpack_require__(/*! ./descriptor */ \"(ssr)/./node_modules/mock-fs/lib/descriptor.js\");\nconst Directory = __webpack_require__(/*! ./directory */ \"(ssr)/./node_modules/mock-fs/lib/directory.js\");\nconst SymbolicLink = __webpack_require__(/*! ./symlink */ \"(ssr)/./node_modules/mock-fs/lib/symlink.js\");\nconst FSError = __webpack_require__(/*! ./error */ \"(ssr)/./node_modules/mock-fs/lib/error.js\");\nconst constants = __webpack_require__(/*! constants */ \"constants\");\nconst getPathParts = (__webpack_require__(/*! ./filesystem */ \"(ssr)/./node_modules/mock-fs/lib/filesystem.js\").getPathParts);\nconst bufferFrom = (__webpack_require__(/*! ./buffer */ \"(ssr)/./node_modules/mock-fs/lib/buffer.js\").from);\nconst bufferAlloc = (__webpack_require__(/*! ./buffer */ \"(ssr)/./node_modules/mock-fs/lib/buffer.js\").alloc);\n\nconst MODE_TO_KTYPE = {\n  [constants.S_IFREG]: constants.UV_DIRENT_FILE,\n  [constants.S_IFDIR]: constants.UV_DIRENT_DIR,\n  [constants.S_IFBLK]: constants.UV_DIRENT_BLOCK,\n  [constants.S_IFCHR]: constants.UV_DIRENT_CHAR,\n  [constants.S_IFLNK]: constants.UV_DIRENT_LINK,\n  [constants.S_IFIFO]: constants.UV_DIRENT_FIFO,\n  [constants.S_IFSOCK]: constants.UV_DIRENT_SOCKET\n};\n\n/** Workaround for optimizations in node 8+ */\nconst fsBinding = process.binding('fs');\nconst kUsePromises = fsBinding.kUsePromises;\nlet statValues;\nif (fsBinding.statValues) {\n  statValues = fsBinding.statValues; // node 10+\n} else if (fsBinding.getStatValues) {\n  statValues = fsBinding.getStatValues(); // node 8\n} else {\n  statValues = [];\n}\n\n// nodejs v6,8,10 and v12 before v12.10.0 has length 28\n// nodejs v12.10.0+ has length 36\nconst statContainsNs = statValues.length > 28;\n\n/** Introduction of BigUint64Array in 10.5 */\nlet BigUint64Array;\nif (global.BigUint64Array) {\n  BigUint64Array = global.BigUint64Array;\n} else {\n  BigUint64Array = function() {};\n}\n\nconst MAX_LINKS = 50;\n\n/**\n * Call the provided function and either return the result or call the callback\n * with it (depending on if a callback is provided).\n * @param {function()} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @param {Object} thisArg This argument for the following function.\n * @param {function()} func Function to call.\n * @return {*} Return (if callback is not provided).\n */\nfunction maybeCallback(callback, ctx, thisArg, func) {\n  let err = null;\n  let val;\n\n  if (kUsePromises && callback === kUsePromises) {\n    // support nodejs v10+ fs.promises\n    try {\n      val = func.call(thisArg);\n    } catch (e) {\n      err = e;\n    }\n    return new Promise(function(resolve, reject) {\n      process.nextTick(function() {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(val);\n        }\n      });\n    });\n  } else if (callback && typeof callback === 'function') {\n    try {\n      val = func.call(thisArg);\n    } catch (e) {\n      err = e;\n    }\n    process.nextTick(function() {\n      if (val === undefined) {\n        callback(err);\n      } else {\n        callback(err, val);\n      }\n    });\n  } else if (ctx && typeof ctx === 'object') {\n    try {\n      return func.call(thisArg);\n    } catch (e) {\n      // default to errno for UNKNOWN\n      ctx.code = e.code || 'UNKNOWN';\n      ctx.errno = e.errno || FSError.codes.UNKNOWN.errno;\n    }\n  } else {\n    return func.call(thisArg);\n  }\n}\n\n/**\n * set syscall property on context object, only for nodejs v10+.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @param {String} syscall Name of syscall.\n */\nfunction markSyscall(ctx, syscall) {\n  if (ctx && typeof ctx === 'object') {\n    ctx.syscall = syscall;\n  }\n}\n\n/**\n * Handle FSReqWrap oncomplete.\n * @param {Function} callback The callback.\n * @return {Function} The normalized callback.\n */\nfunction normalizeCallback(callback) {\n  if (callback && typeof callback.oncomplete === 'function') {\n    // Unpack callback from FSReqWrap\n    callback = callback.oncomplete.bind(callback);\n  }\n  return callback;\n}\n\n/**\n * Handle stat optimizations introduced in Node 8.\n * See https://github.com/nodejs/node/pull/11665.\n * @param {Function} callback The callback.\n * @return {Function} The wrapped callback.\n */\nfunction wrapStatsCallback(callback) {\n  if (callback && typeof callback.oncomplete === 'function') {\n    // Unpack callback from FSReqWrap\n    callback = callback.oncomplete.bind(callback);\n  }\n  if (typeof callback === 'function') {\n    return function(err, stats) {\n      if (stats) {\n        fillStatsArray(stats, statValues);\n      }\n      callback.apply(this, arguments);\n    };\n  } else {\n    return callback;\n  }\n}\n\nfunction getDirentType(mode) {\n  const ktype = MODE_TO_KTYPE[mode & constants.S_IFMT];\n\n  if (ktype === undefined) {\n    return constants.UV_DIRENT_UNKNOWN;\n  }\n\n  return ktype;\n}\n\nfunction notImplemented() {\n  throw new Error('Method not implemented');\n}\n\nfunction deBuffer(p) {\n  return Buffer.isBuffer(p) ? p.toString() : p;\n}\n\n/**\n * Create a new stats object.\n * @param {Object} config Stats properties.\n * @constructor\n */\nfunction Stats(config) {\n  for (const key in config) {\n    this[key] = config[key];\n  }\n  // node 10 expects an array internally\n  // see https://github.com/nodejs/node/pull/19714\n  fillStatsArray(config, this);\n}\n\n/**\n * Check if mode indicates property.\n * @param {number} property Property to check.\n * @return {boolean} Property matches mode.\n */\nStats.prototype._checkModeProperty = function(property) {\n  return (this.mode & constants.S_IFMT) === property;\n};\n\n/**\n * @return {Boolean} Is a directory.\n */\nStats.prototype.isDirectory = function() {\n  return this._checkModeProperty(constants.S_IFDIR);\n};\n\n/**\n * @return {Boolean} Is a regular file.\n */\nStats.prototype.isFile = function() {\n  return this._checkModeProperty(constants.S_IFREG);\n};\n\n/**\n * @return {Boolean} Is a block device.\n */\nStats.prototype.isBlockDevice = function() {\n  return this._checkModeProperty(constants.S_IFBLK);\n};\n\n/**\n * @return {Boolean} Is a character device.\n */\nStats.prototype.isCharacterDevice = function() {\n  return this._checkModeProperty(constants.S_IFCHR);\n};\n\n/**\n * @return {Boolean} Is a symbolic link.\n */\nStats.prototype.isSymbolicLink = function() {\n  return this._checkModeProperty(constants.S_IFLNK);\n};\n\n/**\n * @return {Boolean} Is a named pipe.\n */\nStats.prototype.isFIFO = function() {\n  return this._checkModeProperty(constants.S_IFIFO);\n};\n\n/**\n * @return {Boolean} Is a socket.\n */\nStats.prototype.isSocket = function() {\n  return this._checkModeProperty(constants.S_IFSOCK);\n};\n\n/**\n * Create a new binding with the given file system.\n * @param {FileSystem} system Mock file system.\n * @constructor\n */\nfunction Binding(system) {\n  /**\n   * Mock file system.\n   * @type {FileSystem}\n   */\n  this._system = system;\n\n  /**\n   * Stats constructor.\n   * @type {function}\n   */\n  this.Stats = Stats;\n\n  /**\n   * Lookup of open files.\n   * @type {Object.<number, FileDescriptor>}\n   */\n  this._openFiles = {};\n\n  /**\n   * Counter for file descriptors.\n   * @type {number}\n   */\n  this._counter = -1;\n\n  const stdin = new FileDescriptor(constants.O_RDWR);\n  stdin.setItem(new File.StandardInput());\n  this.trackDescriptor(stdin);\n\n  const stdout = new FileDescriptor(constants.O_RDWR);\n  stdout.setItem(new File.StandardOutput());\n  this.trackDescriptor(stdout);\n\n  const stderr = new FileDescriptor(constants.O_RDWR);\n  stderr.setItem(new File.StandardError());\n  this.trackDescriptor(stderr);\n}\n\n/**\n * Get the file system underlying this binding.\n * @return {FileSystem} The underlying file system.\n */\nBinding.prototype.getSystem = function() {\n  return this._system;\n};\n\n/**\n * Reset the file system underlying this binding.\n * @param {FileSystem} system The new file system.\n */\nBinding.prototype.setSystem = function(system) {\n  this._system = system;\n};\n\n/**\n * Get a file descriptor.\n * @param {number} fd File descriptor identifier.\n * @return {FileDescriptor} File descriptor.\n */\nBinding.prototype.getDescriptorById = function(fd) {\n  if (!this._openFiles.hasOwnProperty(fd)) {\n    throw new FSError('EBADF');\n  }\n  return this._openFiles[fd];\n};\n\n/**\n * Keep track of a file descriptor as open.\n * @param {FileDescriptor} descriptor The file descriptor.\n * @return {number} Identifier for file descriptor.\n */\nBinding.prototype.trackDescriptor = function(descriptor) {\n  const fd = ++this._counter;\n  this._openFiles[fd] = descriptor;\n  return fd;\n};\n\n/**\n * Stop tracking a file descriptor as open.\n * @param {number} fd Identifier for file descriptor.\n */\nBinding.prototype.untrackDescriptorById = function(fd) {\n  if (!this._openFiles.hasOwnProperty(fd)) {\n    throw new FSError('EBADF');\n  }\n  delete this._openFiles[fd];\n};\n\n/**\n * Resolve the canonicalized absolute pathname.\n * @param {string|Buffer} filepath The file path.\n * @param {string} encoding The encoding for the return.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {string|Buffer} The real path.\n */\nBinding.prototype.realpath = function(filepath, encoding, callback, ctx) {\n  markSyscall(ctx, 'realpath');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    let realPath;\n    filepath = deBuffer(filepath);\n    const resolved = path.resolve(filepath);\n    const parts = getPathParts(resolved);\n    let item = this._system.getRoot();\n    let itemPath = '/';\n    let name, i, ii;\n    for (i = 0, ii = parts.length; i < ii; ++i) {\n      name = parts[i];\n      while (item instanceof SymbolicLink) {\n        itemPath = path.resolve(path.dirname(itemPath), item.getPath());\n        item = this._system.getItem(itemPath);\n      }\n      if (!item) {\n        throw new FSError('ENOENT', filepath);\n      }\n      if (item instanceof Directory) {\n        itemPath = path.resolve(itemPath, name);\n        item = item.getItem(name);\n      } else {\n        throw new FSError('ENOTDIR', filepath);\n      }\n    }\n    if (item) {\n      while (item instanceof SymbolicLink) {\n        itemPath = path.resolve(path.dirname(itemPath), item.getPath());\n        item = this._system.getItem(itemPath);\n      }\n      realPath = itemPath;\n    } else {\n      throw new FSError('ENOENT', filepath);\n    }\n\n    if (process.platform === 'win32' && realPath.startsWith('\\\\\\\\?\\\\')) {\n      // Remove win32 file namespace prefix \\\\?\\\n      realPath = realPath.slice(4);\n    }\n\n    if (encoding === 'buffer') {\n      realPath = bufferFrom(realPath);\n    }\n\n    return realPath;\n  });\n};\n\n/**\n * Fill a Float64Array with stat information\n * This is based on the internal FillStatsArray function in Node.\n * https://github.com/nodejs/node/blob/4e05952a8a75af6df625415db612d3a9a1322682/src/node_file.cc#L533\n * @param {Object} stats An object with file stats\n * @param {Float64Array} statValues A Float64Array where stat values should be inserted\n * @returns {void}\n */\nfunction fillStatsArray(stats, statValues) {\n  statValues[0] = stats.dev;\n  statValues[1] = stats.mode;\n  statValues[2] = stats.nlink;\n  statValues[3] = stats.uid;\n  statValues[4] = stats.gid;\n  statValues[5] = stats.rdev;\n  statValues[6] = stats.blksize;\n  statValues[7] = stats.ino;\n  statValues[8] = stats.size;\n  statValues[9] = stats.blocks;\n\n  if (statContainsNs) {\n    // nodejs v12.10.0+\n    // This is based on the internal FillStatsArray function in Node.\n    // https://github.com/nodejs/node/blob/3a2e75d9a5c31d20e429d505b82dd182e33f459a/src/node_file.h#L153-L187\n    statValues[10] = Math.floor(stats.atimeMs / 1000);\n    statValues[11] = (stats.atimeMs % 1000) * 1000000;\n    statValues[12] = Math.floor(stats.mtimeMs / 1000);\n    statValues[13] = (stats.mtimeMs % 1000) * 1000000;\n    statValues[14] = Math.floor(stats.ctimeMs / 1000);\n    statValues[15] = (stats.ctimeMs % 1000) * 1000000;\n    statValues[16] = Math.floor(stats.birthtimeMs / 1000);\n    statValues[17] = (stats.birthtimeMs % 1000) * 1000000;\n  } else {\n    // nodejs before v12.10.0\n    // This is based on the internal FillStatsArray function in Node.\n    // https://github.com/nodejs/node/blob/4e05952a8a75af6df625415db612d3a9a1322682/src/node_file.cc#L533\n    statValues[10] = stats.atimeMs;\n    statValues[11] = stats.mtimeMs;\n    statValues[12] = stats.ctimeMs;\n    statValues[13] = stats.birthtimeMs;\n  }\n}\n\n/**\n * Stat an item.\n * @param {string} filepath Path.\n * @param {function(Error, Stats)|Float64Array|BigUint64Array} callback Callback (optional). In Node 7.7.0+ this will be a Float64Array\n * that should be filled with stat values.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {Stats|undefined} Stats or undefined (if sync).\n */\nBinding.prototype.stat = function(filepath, options, callback, ctx) {\n  // this seems wound not happen in nodejs v10+\n  if (arguments.length < 3) {\n    callback = options;\n    options = {};\n  }\n\n  markSyscall(ctx, 'stat');\n\n  return maybeCallback(wrapStatsCallback(callback), ctx, this, function() {\n    filepath = deBuffer(filepath);\n    let item = this._system.getItem(filepath);\n    if (item instanceof SymbolicLink) {\n      item = this._system.getItem(\n        path.resolve(path.dirname(filepath), item.getPath())\n      );\n    }\n    if (!item) {\n      throw new FSError('ENOENT', filepath);\n    }\n    const stats = item.getStats();\n\n    // In Node 7.7.0+, binding.stat accepts a Float64Array as the second argument,\n    // which should be filled with stat values.\n    // In prior versions of Node, binding.stat simply returns a Stats instance.\n    if (\n      callback instanceof Float64Array ||\n      callback instanceof BigUint64Array\n    ) {\n      fillStatsArray(stats, callback);\n    } else {\n      fillStatsArray(stats, statValues);\n      return new Stats(stats);\n    }\n  });\n};\n\n/**\n * Stat an item.\n * @param {number} fd File descriptor.\n * @param {function(Error, Stats)|Float64Array|BigUint64Array} callback Callback (optional). In Node 7.7.0+ this will be a Float64Array\n * that should be filled with stat values.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {Stats|undefined} Stats or undefined (if sync).\n */\nBinding.prototype.fstat = function(fd, options, callback, ctx) {\n  if (arguments.length < 3) {\n    callback = options;\n    options = {};\n  }\n\n  markSyscall(ctx, 'fstat');\n\n  return maybeCallback(wrapStatsCallback(callback), ctx, this, function() {\n    const descriptor = this.getDescriptorById(fd);\n    const item = descriptor.getItem();\n    const stats = item.getStats();\n\n    // In Node 7.7.0+, binding.stat accepts a Float64Array as the second argument,\n    // which should be filled with stat values.\n    // In prior versions of Node, binding.stat simply returns a Stats instance.\n    if (\n      callback instanceof Float64Array ||\n      callback instanceof BigUint64Array\n    ) {\n      fillStatsArray(stats, callback);\n    } else {\n      fillStatsArray(stats, statValues);\n      return new Stats(stats);\n    }\n  });\n};\n\n/**\n * Close a file descriptor.\n * @param {number} fd File descriptor.\n * @param {function(Error)} callback Callback (optional).\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.close = function(fd, callback, ctx) {\n  markSyscall(ctx, 'close');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    this.untrackDescriptorById(fd);\n  });\n};\n\n/**\n * Open and possibly create a file.\n * @param {string} pathname File path.\n * @param {number} flags Flags.\n * @param {number} mode Mode.\n * @param {function(Error, string)} callback Callback (optional).\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {string} File descriptor (if sync).\n */\nBinding.prototype.open = function(pathname, flags, mode, callback, ctx) {\n  markSyscall(ctx, 'open');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    pathname = deBuffer(pathname);\n    const descriptor = new FileDescriptor(flags);\n    let item = this._system.getItem(pathname);\n    while (item instanceof SymbolicLink) {\n      item = this._system.getItem(\n        path.resolve(path.dirname(pathname), item.getPath())\n      );\n    }\n    if (descriptor.isExclusive() && item) {\n      throw new FSError('EEXIST', pathname);\n    }\n    if (descriptor.isCreate() && !item) {\n      const parent = this._system.getItem(path.dirname(pathname));\n      if (!parent) {\n        throw new FSError('ENOENT', pathname);\n      }\n      if (!(parent instanceof Directory)) {\n        throw new FSError('ENOTDIR', pathname);\n      }\n      item = new File();\n      if (mode) {\n        item.setMode(mode);\n      }\n      parent.addItem(path.basename(pathname), item);\n    }\n    if (descriptor.isRead()) {\n      if (!item) {\n        throw new FSError('ENOENT', pathname);\n      }\n      if (!item.canRead()) {\n        throw new FSError('EACCES', pathname);\n      }\n    }\n    if (descriptor.isWrite() && !item.canWrite()) {\n      throw new FSError('EACCES', pathname);\n    }\n    if (\n      item instanceof Directory &&\n      (descriptor.isTruncate() || descriptor.isAppend())\n    ) {\n      throw new FSError('EISDIR', pathname);\n    }\n    if (descriptor.isTruncate()) {\n      if (!(item instanceof File)) {\n        throw new FSError('EBADF');\n      }\n      item.setContent('');\n    }\n    if (descriptor.isTruncate() || descriptor.isAppend()) {\n      descriptor.setPosition(item.getContent().length);\n    }\n    descriptor.setItem(item);\n    return this.trackDescriptor(descriptor);\n  });\n};\n\n/**\n * Open a file handler. A new api in nodejs v10+ for fs.promises\n * @param {string} pathname File path.\n * @param {number} flags Flags.\n * @param {number} mode Mode.\n * @param {function} callback Callback (optional), expecting kUsePromises in nodejs v10+.\n */\nBinding.prototype.openFileHandle = function(pathname, flags, mode, callback) {\n  const self = this;\n\n  return this.open(pathname, flags, mode, kUsePromises).then(function(fd) {\n    // nodejs v10+ fs.promises FileHandler constructor only ask these three properties.\n    return {\n      getAsyncId: notImplemented,\n      fd: fd,\n      close: function() {\n        return self.close(fd, kUsePromises);\n      }\n    };\n  });\n};\n\n/**\n * Read from a file descriptor.\n * @param {string} fd File descriptor.\n * @param {Buffer} buffer Buffer that the contents will be written to.\n * @param {number} offset Offset in the buffer to start writing to.\n * @param {number} length Number of bytes to read.\n * @param {?number} position Where to begin reading in the file.  If null,\n *     data will be read from the current file position.\n * @param {function(Error, number, Buffer)} callback Callback (optional) called\n *     with any error, number of bytes read, and the buffer.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {number} Number of bytes read (if sync).\n */\nBinding.prototype.read = function(\n  fd,\n  buffer,\n  offset,\n  length,\n  position,\n  callback,\n  ctx\n) {\n  markSyscall(ctx, 'read');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    const descriptor = this.getDescriptorById(fd);\n    if (!descriptor.isRead()) {\n      throw new FSError('EBADF');\n    }\n    const file = descriptor.getItem();\n    if (file instanceof Directory) {\n      throw new FSError('EISDIR');\n    }\n    if (!(file instanceof File)) {\n      // deleted or not a regular file\n      throw new FSError('EBADF');\n    }\n    if (typeof position !== 'number' || position < 0) {\n      position = descriptor.getPosition();\n    }\n    const content = file.getContent();\n    const start = Math.min(position, content.length);\n    const end = Math.min(position + length, content.length);\n    const read = start < end ? content.copy(buffer, offset, start, end) : 0;\n    descriptor.setPosition(position + read);\n    return read;\n  });\n};\n\n/**\n * Write to a file descriptor given a buffer.\n * @param {string} src Source file.\n * @param {string} dest Destination file.\n * @param {number} flags Modifiers for copy operation.\n * @param {function(Error)} callback Callback (optional) called\n *     with any error.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.copyFile = function(src, dest, flags, callback, ctx) {\n  markSyscall(ctx, 'copyfile');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    src = deBuffer(src);\n    dest = deBuffer(dest);\n    const srcFd = this.open(src, constants.O_RDONLY);\n\n    try {\n      const srcDescriptor = this.getDescriptorById(srcFd);\n      if (!srcDescriptor.isRead()) {\n        throw new FSError('EBADF');\n      }\n      const srcFile = srcDescriptor.getItem();\n      if (!(srcFile instanceof File)) {\n        throw new FSError('EBADF');\n      }\n      const srcContent = srcFile.getContent();\n\n      let destFlags =\n        constants.O_WRONLY | constants.O_CREAT | constants.O_TRUNC;\n\n      if ((flags & constants.COPYFILE_EXCL) === constants.COPYFILE_EXCL) {\n        destFlags |= constants.O_EXCL;\n      }\n\n      const destFd = this.open(dest, destFlags);\n\n      try {\n        this.write(destFd, srcContent, 0, srcContent.length, 0);\n      } finally {\n        this.close(destFd);\n      }\n    } finally {\n      this.close(srcFd);\n    }\n  });\n};\n\n/**\n * Write to a file descriptor given a buffer.\n * @param {string} fd File descriptor.\n * @param {Array<Buffer>} buffers Array of buffers with contents to write.\n * @param {?number} position Where to begin writing in the file.  If null,\n *     data will be written to the current file position.\n * @param {function(Error, number, Buffer)} callback Callback (optional) called\n *     with any error, number of bytes written, and the buffer.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {number} Number of bytes written (if sync).\n */\nBinding.prototype.writeBuffers = function(\n  fd,\n  buffers,\n  position,\n  callback,\n  ctx\n) {\n  markSyscall(ctx, 'write');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    const descriptor = this.getDescriptorById(fd);\n    if (!descriptor.isWrite()) {\n      throw new FSError('EBADF');\n    }\n    const file = descriptor.getItem();\n    if (!(file instanceof File)) {\n      // not a regular file\n      throw new FSError('EBADF');\n    }\n    if (typeof position !== 'number' || position < 0) {\n      position = descriptor.getPosition();\n    }\n    let content = file.getContent();\n    const newContent = Buffer.concat(buffers);\n    const newLength = position + newContent.length;\n    if (content.length < newLength) {\n      const tempContent = bufferAlloc(newLength);\n      content.copy(tempContent);\n      content = tempContent;\n    }\n    const written = newContent.copy(content, position);\n    file.setContent(content);\n    descriptor.setPosition(newLength);\n    return written;\n  });\n};\n\n/**\n * Write to a file descriptor given a buffer.\n * @param {string} fd File descriptor.\n * @param {Buffer} buffer Buffer with contents to write.\n * @param {number} offset Offset in the buffer to start writing from.\n * @param {number} length Number of bytes to write.\n * @param {?number} position Where to begin writing in the file.  If null,\n *     data will be written to the current file position.\n * @param {function(Error, number, Buffer)} callback Callback (optional) called\n *     with any error, number of bytes written, and the buffer.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {number} Number of bytes written (if sync).\n */\nBinding.prototype.writeBuffer = function(\n  fd,\n  buffer,\n  offset,\n  length,\n  position,\n  callback,\n  ctx\n) {\n  markSyscall(ctx, 'write');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    const descriptor = this.getDescriptorById(fd);\n    if (!descriptor.isWrite()) {\n      throw new FSError('EBADF');\n    }\n    const file = descriptor.getItem();\n    if (!(file instanceof File)) {\n      // not a regular file\n      throw new FSError('EBADF');\n    }\n    if (typeof position !== 'number' || position < 0) {\n      position = descriptor.getPosition();\n    }\n    let content = file.getContent();\n    const newLength = position + length;\n    if (content.length < newLength) {\n      const newContent = bufferAlloc(newLength);\n      content.copy(newContent);\n      content = newContent;\n    }\n    const sourceEnd = Math.min(offset + length, buffer.length);\n    const written = bufferFrom(buffer).copy(\n      content,\n      position,\n      offset,\n      sourceEnd\n    );\n    file.setContent(content);\n    descriptor.setPosition(newLength);\n    return written;\n  });\n};\n\n/**\n * Alias for writeBuffer (used in Node <= 0.10).\n * @param {string} fd File descriptor.\n * @param {Buffer} buffer Buffer with contents to write.\n * @param {number} offset Offset in the buffer to start writing from.\n * @param {number} length Number of bytes to write.\n * @param {?number} position Where to begin writing in the file.  If null,\n *     data will be written to the current file position.\n * @param {function(Error, number, Buffer)} callback Callback (optional) called\n *     with any error, number of bytes written, and the buffer.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {number} Number of bytes written (if sync).\n */\nBinding.prototype.write = Binding.prototype.writeBuffer;\n\n/**\n * Write to a file descriptor given a string.\n * @param {string} fd File descriptor.\n * @param {string} string String with contents to write.\n * @param {number} position Where to begin writing in the file.  If null,\n *     data will be written to the current file position.\n * @param {string} encoding String encoding.\n * @param {function(Error, number, string)} callback Callback (optional) called\n *     with any error, number of bytes written, and the string.\n * @return {number} Number of bytes written (if sync).\n */\nBinding.prototype.writeString = function(\n  fd,\n  string,\n  position,\n  encoding,\n  callback,\n  ctx\n) {\n  markSyscall(ctx, 'write');\n\n  const buffer = bufferFrom(string, encoding);\n  let wrapper;\n  if (callback && callback !== kUsePromises) {\n    if (callback.oncomplete) {\n      callback = callback.oncomplete.bind(callback);\n    }\n    wrapper = function(err, written, returned) {\n      callback(err, written, returned && string);\n    };\n  }\n  return this.writeBuffer(fd, buffer, 0, string.length, position, wrapper, ctx);\n};\n\n/**\n * Rename a file.\n * @param {string} oldPath Old pathname.\n * @param {string} newPath New pathname.\n * @param {function(Error)} callback Callback (optional).\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {undefined}\n */\nBinding.prototype.rename = function(oldPath, newPath, callback, ctx) {\n  markSyscall(ctx, 'rename');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    oldPath = deBuffer(oldPath);\n    newPath = deBuffer(newPath);\n    const oldItem = this._system.getItem(oldPath);\n    if (!oldItem) {\n      throw new FSError('ENOENT', oldPath);\n    }\n    const oldParent = this._system.getItem(path.dirname(oldPath));\n    const oldName = path.basename(oldPath);\n    const newItem = this._system.getItem(newPath);\n    const newParent = this._system.getItem(path.dirname(newPath));\n    const newName = path.basename(newPath);\n    if (newItem) {\n      // make sure they are the same type\n      if (oldItem instanceof File) {\n        if (newItem instanceof Directory) {\n          throw new FSError('EISDIR', newPath);\n        }\n      } else if (oldItem instanceof Directory) {\n        if (!(newItem instanceof Directory)) {\n          throw new FSError('ENOTDIR', newPath);\n        }\n        if (newItem.list().length > 0) {\n          throw new FSError('ENOTEMPTY', newPath);\n        }\n      }\n      newParent.removeItem(newName);\n    } else {\n      if (!newParent) {\n        throw new FSError('ENOENT', newPath);\n      }\n      if (!(newParent instanceof Directory)) {\n        throw new FSError('ENOTDIR', newPath);\n      }\n    }\n    oldParent.removeItem(oldName);\n    newParent.addItem(newName, oldItem);\n  });\n};\n\n/**\n * Read a directory.\n * @param {string} dirpath Path to directory.\n * @param {string} encoding The encoding ('utf-8' or 'buffer').\n * @param {boolean} withFileTypes whether or not to return fs.Dirent objects\n * @param {function(Error, (Array.<string>|Array.<Buffer>)} callback Callback\n *     (optional) called with any error or array of items in the directory.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {Array.<string>|Array.<Buffer>} Array of items in directory (if sync).\n */\nBinding.prototype.readdir = function(\n  dirpath,\n  encoding,\n  withFileTypes,\n  callback,\n  ctx\n) {\n  // again, the shorter arguments would not happen in nodejs v10+\n  if (arguments.length === 2) {\n    callback = encoding;\n    encoding = 'utf-8';\n  } else if (arguments.length === 3) {\n    callback = withFileTypes;\n  }\n\n  markSyscall(ctx, 'scandir');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    dirpath = deBuffer(dirpath);\n    let dpath = dirpath;\n    let dir = this._system.getItem(dirpath);\n    while (dir instanceof SymbolicLink) {\n      dpath = path.resolve(path.dirname(dpath), dir.getPath());\n      dir = this._system.getItem(dpath);\n    }\n    if (!dir) {\n      throw new FSError('ENOENT', dirpath);\n    }\n    if (!(dir instanceof Directory)) {\n      throw new FSError('ENOTDIR', dirpath);\n    }\n    if (!dir.canRead()) {\n      throw new FSError('EACCES', dirpath);\n    }\n\n    let list = dir.list();\n    if (encoding === 'buffer') {\n      list = list.map(function(item) {\n        return bufferFrom(item);\n      });\n    }\n\n    if (withFileTypes === true) {\n      const types = list.map(function(name) {\n        const stats = dir.getItem(name).getStats();\n\n        return getDirentType(stats.mode);\n      });\n      list = [list, types];\n    }\n\n    return list;\n  });\n};\n\n/**\n * Create a directory.\n * @param {string} pathname Path to new directory.\n * @param {number} mode Permissions.\n * @param {boolean} recursive Recursively create deep directory. (added in nodejs v10+)\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.mkdir = function(pathname, mode, recursive, callback, ctx) {\n  if (typeof recursive !== 'boolean') {\n    // when running nodejs < 10\n    ctx = callback;\n    callback = recursive;\n    recursive = false;\n  }\n\n  markSyscall(ctx, 'mkdir');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    pathname = deBuffer(pathname);\n    const item = this._system.getItem(pathname);\n    if (item) {\n      if (recursive && item instanceof Directory) {\n        // silently pass existing folder in recursive mode\n        return;\n      }\n      throw new FSError('EEXIST', pathname);\n    }\n\n    const _mkdir = function(_pathname) {\n      const parentDir = path.dirname(_pathname);\n      let parent = this._system.getItem(parentDir);\n      if (!parent) {\n        if (!recursive) {\n          throw new FSError('ENOENT', _pathname);\n        }\n        parent = _mkdir(parentDir, true);\n      }\n      this.access(parentDir, parseInt('0002', 8));\n      const dir = new Directory();\n      if (mode) {\n        dir.setMode(mode);\n      }\n      return parent.addItem(path.basename(_pathname), dir);\n    }.bind(this);\n\n    _mkdir(pathname);\n  });\n};\n\n/**\n * Remove a directory.\n * @param {string} pathname Path to directory.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.rmdir = function(pathname, callback, ctx) {\n  markSyscall(ctx, 'rmdir');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    pathname = deBuffer(pathname);\n    const item = this._system.getItem(pathname);\n    if (!item) {\n      throw new FSError('ENOENT', pathname);\n    }\n    if (!(item instanceof Directory)) {\n      throw new FSError('ENOTDIR', pathname);\n    }\n    if (item.list().length > 0) {\n      throw new FSError('ENOTEMPTY', pathname);\n    }\n    this.access(path.dirname(pathname), parseInt('0002', 8));\n    const parent = this._system.getItem(path.dirname(pathname));\n    parent.removeItem(path.basename(pathname));\n  });\n};\n\nconst PATH_CHARS =\n  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n\nconst MAX_ATTEMPTS = 62 * 62 * 62;\n\n/**\n * Create a directory based on a template.\n * See http://web.mit.edu/freebsd/head/lib/libc/stdio/mktemp.c\n * @param {string} template Path template (trailing Xs will be replaced).\n * @param {string} encoding The encoding ('utf-8' or 'buffer').\n * @param {function(Error, string)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.mkdtemp = function(prefix, encoding, callback, ctx) {\n  if (encoding && typeof encoding !== 'string') {\n    callback = encoding;\n    encoding = 'utf-8';\n  }\n\n  markSyscall(ctx, 'mkdtemp');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    prefix = prefix.replace(/X{0,6}$/, 'XXXXXX');\n    const parentPath = path.dirname(prefix);\n    const parent = this._system.getItem(parentPath);\n    if (!parent) {\n      throw new FSError('ENOENT', prefix);\n    }\n    if (!(parent instanceof Directory)) {\n      throw new FSError('ENOTDIR', prefix);\n    }\n    this.access(parentPath, parseInt('0002', 8));\n    const template = path.basename(prefix);\n    let unique = false;\n    let count = 0;\n    let name;\n    while (!unique && count < MAX_ATTEMPTS) {\n      let position = template.length - 1;\n      let replacement = '';\n      while (template.charAt(position) === 'X') {\n        replacement += PATH_CHARS.charAt(\n          Math.floor(PATH_CHARS.length * Math.random())\n        );\n        position -= 1;\n      }\n      const candidate = template.slice(0, position + 1) + replacement;\n      if (!parent.getItem(candidate)) {\n        name = candidate;\n        unique = true;\n      }\n      count += 1;\n    }\n    if (!name) {\n      throw new FSError('EEXIST', prefix);\n    }\n    const dir = new Directory();\n    parent.addItem(name, dir);\n    let uniquePath = path.join(parentPath, name);\n    if (encoding === 'buffer') {\n      uniquePath = bufferFrom(uniquePath);\n    }\n    return uniquePath;\n  });\n};\n\n/**\n * Truncate a file.\n * @param {number} fd File descriptor.\n * @param {number} len Number of bytes.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.ftruncate = function(fd, len, callback, ctx) {\n  markSyscall(ctx, 'ftruncate');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    const descriptor = this.getDescriptorById(fd);\n    if (!descriptor.isWrite()) {\n      throw new FSError('EINVAL');\n    }\n    const file = descriptor.getItem();\n    if (!(file instanceof File)) {\n      throw new FSError('EINVAL');\n    }\n    const content = file.getContent();\n    const newContent = bufferAlloc(len);\n    content.copy(newContent);\n    file.setContent(newContent);\n  });\n};\n\n/**\n * Legacy support.\n * @param {number} fd File descriptor.\n * @param {number} len Number of bytes.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.truncate = Binding.prototype.ftruncate;\n\n/**\n * Change user and group owner.\n * @param {string} pathname Path.\n * @param {number} uid User id.\n * @param {number} gid Group id.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.chown = function(pathname, uid, gid, callback, ctx) {\n  markSyscall(ctx, 'chown');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    pathname = deBuffer(pathname);\n    const item = this._system.getItem(pathname);\n    if (!item) {\n      throw new FSError('ENOENT', pathname);\n    }\n    item.setUid(uid);\n    item.setGid(gid);\n  });\n};\n\n/**\n * Change user and group owner.\n * @param {number} fd File descriptor.\n * @param {number} uid User id.\n * @param {number} gid Group id.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.fchown = function(fd, uid, gid, callback, ctx) {\n  markSyscall(ctx, 'fchown');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    const descriptor = this.getDescriptorById(fd);\n    const item = descriptor.getItem();\n    item.setUid(uid);\n    item.setGid(gid);\n  });\n};\n\n/**\n * Change permissions.\n * @param {string} pathname Path.\n * @param {number} mode Mode.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.chmod = function(pathname, mode, callback, ctx) {\n  markSyscall(ctx, 'chmod');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    pathname = deBuffer(pathname);\n    const item = this._system.getItem(pathname);\n    if (!item) {\n      throw new FSError('ENOENT', pathname);\n    }\n    item.setMode(mode);\n  });\n};\n\n/**\n * Change permissions.\n * @param {number} fd File descriptor.\n * @param {number} mode Mode.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.fchmod = function(fd, mode, callback, ctx) {\n  markSyscall(ctx, 'fchmod');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    const descriptor = this.getDescriptorById(fd);\n    const item = descriptor.getItem();\n    item.setMode(mode);\n  });\n};\n\n/**\n * Delete a named item.\n * @param {string} pathname Path to item.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.unlink = function(pathname, callback, ctx) {\n  markSyscall(ctx, 'unlink');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    pathname = deBuffer(pathname);\n    const item = this._system.getItem(pathname);\n    if (!item) {\n      throw new FSError('ENOENT', pathname);\n    }\n    if (item instanceof Directory) {\n      throw new FSError('EPERM', pathname);\n    }\n    const parent = this._system.getItem(path.dirname(pathname));\n    parent.removeItem(path.basename(pathname));\n  });\n};\n\n/**\n * Update timestamps.\n * @param {string} pathname Path to item.\n * @param {number} atime Access time (in seconds).\n * @param {number} mtime Modification time (in seconds).\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.utimes = function(pathname, atime, mtime, callback, ctx) {\n  markSyscall(ctx, 'utimes');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    pathname = deBuffer(pathname);\n    const item = this._system.getItem(pathname);\n    if (!item) {\n      throw new FSError('ENOENT', pathname);\n    }\n    item.setATime(new Date(atime * 1000));\n    item.setMTime(new Date(mtime * 1000));\n  });\n};\n\n/**\n * Update timestamps.\n * @param {number} fd File descriptor.\n * @param {number} atime Access time (in seconds).\n * @param {number} mtime Modification time (in seconds).\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.futimes = function(fd, atime, mtime, callback, ctx) {\n  markSyscall(ctx, 'futimes');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    const descriptor = this.getDescriptorById(fd);\n    const item = descriptor.getItem();\n    item.setATime(new Date(atime * 1000));\n    item.setMTime(new Date(mtime * 1000));\n  });\n};\n\n/**\n * Synchronize in-core state with storage device.\n * @param {number} fd File descriptor.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.fsync = function(fd, callback, ctx) {\n  markSyscall(ctx, 'fsync');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    this.getDescriptorById(fd);\n  });\n};\n\n/**\n * Synchronize in-core metadata state with storage device.\n * @param {number} fd File descriptor.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.fdatasync = function(fd, callback, ctx) {\n  markSyscall(ctx, 'fdatasync');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    this.getDescriptorById(fd);\n  });\n};\n\n/**\n * Create a hard link.\n * @param {string} srcPath The existing file.\n * @param {string} destPath The new link to create.\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.link = function(srcPath, destPath, callback, ctx) {\n  markSyscall(ctx, 'link');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    srcPath = deBuffer(srcPath);\n    destPath = deBuffer(destPath);\n    const item = this._system.getItem(srcPath);\n    if (!item) {\n      throw new FSError('ENOENT', srcPath);\n    }\n    if (item instanceof Directory) {\n      throw new FSError('EPERM', srcPath);\n    }\n    if (this._system.getItem(destPath)) {\n      throw new FSError('EEXIST', destPath);\n    }\n    const parent = this._system.getItem(path.dirname(destPath));\n    if (!parent) {\n      throw new FSError('ENOENT', destPath);\n    }\n    if (!(parent instanceof Directory)) {\n      throw new FSError('ENOTDIR', destPath);\n    }\n    parent.addItem(path.basename(destPath), item);\n  });\n};\n\n/**\n * Create a symbolic link.\n * @param {string} srcPath Path from link to the source file.\n * @param {string} destPath Path for the generated link.\n * @param {string} type Ignored (used for Windows only).\n * @param {function(Error)} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.symlink = function(srcPath, destPath, type, callback, ctx) {\n  markSyscall(ctx, 'symlink');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    srcPath = deBuffer(srcPath);\n    destPath = deBuffer(destPath);\n    if (this._system.getItem(destPath)) {\n      throw new FSError('EEXIST', destPath);\n    }\n    const parent = this._system.getItem(path.dirname(destPath));\n    if (!parent) {\n      throw new FSError('ENOENT', destPath);\n    }\n    if (!(parent instanceof Directory)) {\n      throw new FSError('ENOTDIR', destPath);\n    }\n    const link = new SymbolicLink();\n    link.setPath(srcPath);\n    parent.addItem(path.basename(destPath), link);\n  });\n};\n\n/**\n * Read the contents of a symbolic link.\n * @param {string} pathname Path to symbolic link.\n * @param {string} encoding The encoding ('utf-8' or 'buffer').\n * @param {function(Error, (string|Buffer))} callback Optional callback.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {string|Buffer} Symbolic link contents (path to source).\n */\nBinding.prototype.readlink = function(pathname, encoding, callback, ctx) {\n  if (encoding && typeof encoding !== 'string') {\n    // this would not happend in nodejs v10+\n    callback = encoding;\n    encoding = 'utf-8';\n  }\n\n  markSyscall(ctx, 'readlink');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    pathname = deBuffer(pathname);\n    const link = this._system.getItem(pathname);\n    if (!link) {\n      throw new FSError('ENOENT', pathname);\n    }\n    if (!(link instanceof SymbolicLink)) {\n      throw new FSError('EINVAL', pathname);\n    }\n    let linkPath = link.getPath();\n    if (encoding === 'buffer') {\n      linkPath = bufferFrom(linkPath);\n    }\n    return linkPath;\n  });\n};\n\n/**\n * Stat an item.\n * @param {string} filepath Path.\n * @param {function(Error, Stats)|Float64Array|BigUint64Array} callback Callback (optional). In Node 7.7.0+ this will be a Float64Array\n * that should be filled with stat values.\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n * @return {Stats|undefined} Stats or undefined (if sync).\n */\nBinding.prototype.lstat = function(filepath, options, callback, ctx) {\n  if (arguments.length < 3) {\n    // this would not happend in nodejs v10+\n    callback = options;\n    options = {};\n  }\n\n  markSyscall(ctx, 'lstat');\n\n  return maybeCallback(wrapStatsCallback(callback), ctx, this, function() {\n    filepath = deBuffer(filepath);\n    const item = this._system.getItem(filepath);\n    if (!item) {\n      throw new FSError('ENOENT', filepath);\n    }\n    const stats = item.getStats();\n\n    // In Node 7.7.0+, binding.stat accepts a Float64Array as the second argument,\n    // which should be filled with stat values.\n    // In prior versions of Node, binding.stat simply returns a Stats instance.\n    if (\n      callback instanceof Float64Array ||\n      callback instanceof BigUint64Array\n    ) {\n      fillStatsArray(stats, callback);\n    } else {\n      fillStatsArray(stats, statValues);\n      return new Stats(item.getStats());\n    }\n  });\n};\n\n/**\n * Tests user permissions.\n * @param {string} filepath Path.\n * @param {number} mode Mode.\n * @param {function(Error)} callback Callback (optional).\n * @param {Object} ctx Context object (optional), only for nodejs v10+.\n */\nBinding.prototype.access = function(filepath, mode, callback, ctx) {\n  markSyscall(ctx, 'access');\n\n  return maybeCallback(normalizeCallback(callback), ctx, this, function() {\n    filepath = deBuffer(filepath);\n    let item = this._system.getItem(filepath);\n    let links = 0;\n    while (item instanceof SymbolicLink) {\n      if (links > MAX_LINKS) {\n        throw new FSError('ELOOP', filepath);\n      }\n      filepath = path.resolve(path.dirname(filepath), item.getPath());\n      item = this._system.getItem(filepath);\n      ++links;\n    }\n    if (!item) {\n      throw new FSError('ENOENT', filepath);\n    }\n    if (mode && process.getuid && process.getgid) {\n      const itemMode = item.getMode();\n      if (item.getUid() === process.getuid()) {\n        if ((itemMode & (mode * 64)) !== mode * 64) {\n          throw new FSError('EACCES', filepath);\n        }\n      } else if (item.getGid() === process.getgid()) {\n        if ((itemMode & (mode * 8)) !== mode * 8) {\n          throw new FSError('EACCES', filepath);\n        }\n      } else {\n        if ((itemMode & mode) !== mode) {\n          throw new FSError('EACCES', filepath);\n        }\n      }\n    }\n  });\n};\n\n/**\n * Not yet implemented.\n * @type {function()}\n */\nBinding.prototype.StatWatcher = notImplemented;\n\n/**\n * Export the binding constructor.\n * @type {function()}\n */\nexports = module.exports = Binding;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvYmluZGluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCLGFBQWEsbUJBQU8sQ0FBQyx3REFBUTtBQUM3Qix1QkFBdUIsbUJBQU8sQ0FBQyxvRUFBYztBQUM3QyxrQkFBa0IsbUJBQU8sQ0FBQyxrRUFBYTtBQUN2QyxxQkFBcUIsbUJBQU8sQ0FBQyw4REFBVztBQUN4QyxnQkFBZ0IsbUJBQU8sQ0FBQywwREFBUztBQUNqQyxrQkFBa0IsbUJBQU8sQ0FBQyw0QkFBVztBQUNyQyxxQkFBcUIsd0dBQW9DO0FBQ3pELG1CQUFtQix3RkFBd0I7QUFDM0Msb0JBQW9CLHlGQUF5Qjs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsRUFBRTtBQUNGLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFlBQVk7QUFDdkIsWUFBWSxHQUFHO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGNBQWM7QUFDekIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxvREFBb0Q7QUFDL0Q7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxvREFBb0Q7QUFDL0Q7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLHlCQUF5QjtBQUNwQyxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUM7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLGlDQUFpQztBQUM1QztBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUM7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUM7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUNBQWlDO0FBQzVDO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsaURBQWlEO0FBQzVEO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksK0JBQStCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyx5QkFBeUI7QUFDcEMsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLCtCQUErQixJQUFJO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsa0NBQWtDO0FBQzdDLFdBQVcsUUFBUTtBQUNuQixZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsb0RBQW9EO0FBQy9EO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcG9ydGtleS9uZXh0LWV4YW1wbGUvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvYmluZGluZy5qcz9lYzVjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxuY29uc3QgRmlsZSA9IHJlcXVpcmUoJy4vZmlsZScpO1xuY29uc3QgRmlsZURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL2Rlc2NyaXB0b3InKTtcbmNvbnN0IERpcmVjdG9yeSA9IHJlcXVpcmUoJy4vZGlyZWN0b3J5Jyk7XG5jb25zdCBTeW1ib2xpY0xpbmsgPSByZXF1aXJlKCcuL3N5bWxpbmsnKTtcbmNvbnN0IEZTRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yJyk7XG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCdjb25zdGFudHMnKTtcbmNvbnN0IGdldFBhdGhQYXJ0cyA9IHJlcXVpcmUoJy4vZmlsZXN5c3RlbScpLmdldFBhdGhQYXJ0cztcbmNvbnN0IGJ1ZmZlckZyb20gPSByZXF1aXJlKCcuL2J1ZmZlcicpLmZyb207XG5jb25zdCBidWZmZXJBbGxvYyA9IHJlcXVpcmUoJy4vYnVmZmVyJykuYWxsb2M7XG5cbmNvbnN0IE1PREVfVE9fS1RZUEUgPSB7XG4gIFtjb25zdGFudHMuU19JRlJFR106IGNvbnN0YW50cy5VVl9ESVJFTlRfRklMRSxcbiAgW2NvbnN0YW50cy5TX0lGRElSXTogY29uc3RhbnRzLlVWX0RJUkVOVF9ESVIsXG4gIFtjb25zdGFudHMuU19JRkJMS106IGNvbnN0YW50cy5VVl9ESVJFTlRfQkxPQ0ssXG4gIFtjb25zdGFudHMuU19JRkNIUl06IGNvbnN0YW50cy5VVl9ESVJFTlRfQ0hBUixcbiAgW2NvbnN0YW50cy5TX0lGTE5LXTogY29uc3RhbnRzLlVWX0RJUkVOVF9MSU5LLFxuICBbY29uc3RhbnRzLlNfSUZJRk9dOiBjb25zdGFudHMuVVZfRElSRU5UX0ZJRk8sXG4gIFtjb25zdGFudHMuU19JRlNPQ0tdOiBjb25zdGFudHMuVVZfRElSRU5UX1NPQ0tFVFxufTtcblxuLyoqIFdvcmthcm91bmQgZm9yIG9wdGltaXphdGlvbnMgaW4gbm9kZSA4KyAqL1xuY29uc3QgZnNCaW5kaW5nID0gcHJvY2Vzcy5iaW5kaW5nKCdmcycpO1xuY29uc3Qga1VzZVByb21pc2VzID0gZnNCaW5kaW5nLmtVc2VQcm9taXNlcztcbmxldCBzdGF0VmFsdWVzO1xuaWYgKGZzQmluZGluZy5zdGF0VmFsdWVzKSB7XG4gIHN0YXRWYWx1ZXMgPSBmc0JpbmRpbmcuc3RhdFZhbHVlczsgLy8gbm9kZSAxMCtcbn0gZWxzZSBpZiAoZnNCaW5kaW5nLmdldFN0YXRWYWx1ZXMpIHtcbiAgc3RhdFZhbHVlcyA9IGZzQmluZGluZy5nZXRTdGF0VmFsdWVzKCk7IC8vIG5vZGUgOFxufSBlbHNlIHtcbiAgc3RhdFZhbHVlcyA9IFtdO1xufVxuXG4vLyBub2RlanMgdjYsOCwxMCBhbmQgdjEyIGJlZm9yZSB2MTIuMTAuMCBoYXMgbGVuZ3RoIDI4XG4vLyBub2RlanMgdjEyLjEwLjArIGhhcyBsZW5ndGggMzZcbmNvbnN0IHN0YXRDb250YWluc05zID0gc3RhdFZhbHVlcy5sZW5ndGggPiAyODtcblxuLyoqIEludHJvZHVjdGlvbiBvZiBCaWdVaW50NjRBcnJheSBpbiAxMC41ICovXG5sZXQgQmlnVWludDY0QXJyYXk7XG5pZiAoZ2xvYmFsLkJpZ1VpbnQ2NEFycmF5KSB7XG4gIEJpZ1VpbnQ2NEFycmF5ID0gZ2xvYmFsLkJpZ1VpbnQ2NEFycmF5O1xufSBlbHNlIHtcbiAgQmlnVWludDY0QXJyYXkgPSBmdW5jdGlvbigpIHt9O1xufVxuXG5jb25zdCBNQVhfTElOS1MgPSA1MDtcblxuLyoqXG4gKiBDYWxsIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBhbmQgZWl0aGVyIHJldHVybiB0aGUgcmVzdWx0IG9yIGNhbGwgdGhlIGNhbGxiYWNrXG4gKiB3aXRoIGl0IChkZXBlbmRpbmcgb24gaWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGNhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoaXMgYXJndW1lbnQgZm9yIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGZ1bmMgRnVuY3Rpb24gdG8gY2FsbC5cbiAqIEByZXR1cm4geyp9IFJldHVybiAoaWYgY2FsbGJhY2sgaXMgbm90IHByb3ZpZGVkKS5cbiAqL1xuZnVuY3Rpb24gbWF5YmVDYWxsYmFjayhjYWxsYmFjaywgY3R4LCB0aGlzQXJnLCBmdW5jKSB7XG4gIGxldCBlcnIgPSBudWxsO1xuICBsZXQgdmFsO1xuXG4gIGlmIChrVXNlUHJvbWlzZXMgJiYgY2FsbGJhY2sgPT09IGtVc2VQcm9taXNlcykge1xuICAgIC8vIHN1cHBvcnQgbm9kZWpzIHYxMCsgZnMucHJvbWlzZXNcbiAgICB0cnkge1xuICAgICAgdmFsID0gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVyciA9IGU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGNhbGxiYWNrICYmIHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICB2YWwgPSBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyID0gZTtcbiAgICB9XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2soZXJyLCB2YWwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKGN0eCAmJiB0eXBlb2YgY3R4ID09PSAnb2JqZWN0Jykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGRlZmF1bHQgdG8gZXJybm8gZm9yIFVOS05PV05cbiAgICAgIGN0eC5jb2RlID0gZS5jb2RlIHx8ICdVTktOT1dOJztcbiAgICAgIGN0eC5lcnJubyA9IGUuZXJybm8gfHwgRlNFcnJvci5jb2Rlcy5VTktOT1dOLmVycm5vO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICB9XG59XG5cbi8qKlxuICogc2V0IHN5c2NhbGwgcHJvcGVydHkgb24gY29udGV4dCBvYmplY3QsIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzeXNjYWxsIE5hbWUgb2Ygc3lzY2FsbC5cbiAqL1xuZnVuY3Rpb24gbWFya1N5c2NhbGwoY3R4LCBzeXNjYWxsKSB7XG4gIGlmIChjdHggJiYgdHlwZW9mIGN0eCA9PT0gJ29iamVjdCcpIHtcbiAgICBjdHguc3lzY2FsbCA9IHN5c2NhbGw7XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGUgRlNSZXFXcmFwIG9uY29tcGxldGUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2suXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIG5vcm1hbGl6ZWQgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjayAmJiB0eXBlb2YgY2FsbGJhY2sub25jb21wbGV0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVucGFjayBjYWxsYmFjayBmcm9tIEZTUmVxV3JhcFxuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sub25jb21wbGV0ZS5iaW5kKGNhbGxiYWNrKTtcbiAgfVxuICByZXR1cm4gY2FsbGJhY2s7XG59XG5cbi8qKlxuICogSGFuZGxlIHN0YXQgb3B0aW1pemF0aW9ucyBpbnRyb2R1Y2VkIGluIE5vZGUgOC5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8xMTY2NS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjay5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgd3JhcHBlZCBjYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gd3JhcFN0YXRzQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrICYmIHR5cGVvZiBjYWxsYmFjay5vbmNvbXBsZXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVW5wYWNrIGNhbGxiYWNrIGZyb20gRlNSZXFXcmFwXG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjay5vbmNvbXBsZXRlLmJpbmQoY2FsbGJhY2spO1xuICB9XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZXJyLCBzdGF0cykge1xuICAgICAgaWYgKHN0YXRzKSB7XG4gICAgICAgIGZpbGxTdGF0c0FycmF5KHN0YXRzLCBzdGF0VmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY2FsbGJhY2s7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGlyZW50VHlwZShtb2RlKSB7XG4gIGNvbnN0IGt0eXBlID0gTU9ERV9UT19LVFlQRVttb2RlICYgY29uc3RhbnRzLlNfSUZNVF07XG5cbiAgaWYgKGt0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY29uc3RhbnRzLlVWX0RJUkVOVF9VTktOT1dOO1xuICB9XG5cbiAgcmV0dXJuIGt0eXBlO1xufVxuXG5mdW5jdGlvbiBub3RJbXBsZW1lbnRlZCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkJyk7XG59XG5cbmZ1bmN0aW9uIGRlQnVmZmVyKHApIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihwKSA/IHAudG9TdHJpbmcoKSA6IHA7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0YXRzIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgU3RhdHMgcHJvcGVydGllcy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBTdGF0cyhjb25maWcpIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gY29uZmlnKSB7XG4gICAgdGhpc1trZXldID0gY29uZmlnW2tleV07XG4gIH1cbiAgLy8gbm9kZSAxMCBleHBlY3RzIGFuIGFycmF5IGludGVybmFsbHlcbiAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzE5NzE0XG4gIGZpbGxTdGF0c0FycmF5KGNvbmZpZywgdGhpcyk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgbW9kZSBpbmRpY2F0ZXMgcHJvcGVydHkuXG4gKiBAcGFyYW0ge251bWJlcn0gcHJvcGVydHkgUHJvcGVydHkgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBQcm9wZXJ0eSBtYXRjaGVzIG1vZGUuXG4gKi9cblN0YXRzLnByb3RvdHlwZS5fY2hlY2tNb2RlUHJvcGVydHkgPSBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICByZXR1cm4gKHRoaXMubW9kZSAmIGNvbnN0YW50cy5TX0lGTVQpID09PSBwcm9wZXJ0eTtcbn07XG5cbi8qKlxuICogQHJldHVybiB7Qm9vbGVhbn0gSXMgYSBkaXJlY3RvcnkuXG4gKi9cblN0YXRzLnByb3RvdHlwZS5pc0RpcmVjdG9yeSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY2hlY2tNb2RlUHJvcGVydHkoY29uc3RhbnRzLlNfSUZESVIpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtCb29sZWFufSBJcyBhIHJlZ3VsYXIgZmlsZS5cbiAqL1xuU3RhdHMucHJvdG90eXBlLmlzRmlsZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY2hlY2tNb2RlUHJvcGVydHkoY29uc3RhbnRzLlNfSUZSRUcpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtCb29sZWFufSBJcyBhIGJsb2NrIGRldmljZS5cbiAqL1xuU3RhdHMucHJvdG90eXBlLmlzQmxvY2tEZXZpY2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2NoZWNrTW9kZVByb3BlcnR5KGNvbnN0YW50cy5TX0lGQkxLKTtcbn07XG5cbi8qKlxuICogQHJldHVybiB7Qm9vbGVhbn0gSXMgYSBjaGFyYWN0ZXIgZGV2aWNlLlxuICovXG5TdGF0cy5wcm90b3R5cGUuaXNDaGFyYWN0ZXJEZXZpY2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2NoZWNrTW9kZVByb3BlcnR5KGNvbnN0YW50cy5TX0lGQ0hSKTtcbn07XG5cbi8qKlxuICogQHJldHVybiB7Qm9vbGVhbn0gSXMgYSBzeW1ib2xpYyBsaW5rLlxuICovXG5TdGF0cy5wcm90b3R5cGUuaXNTeW1ib2xpY0xpbmsgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2NoZWNrTW9kZVByb3BlcnR5KGNvbnN0YW50cy5TX0lGTE5LKTtcbn07XG5cbi8qKlxuICogQHJldHVybiB7Qm9vbGVhbn0gSXMgYSBuYW1lZCBwaXBlLlxuICovXG5TdGF0cy5wcm90b3R5cGUuaXNGSUZPID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jaGVja01vZGVQcm9wZXJ0eShjb25zdGFudHMuU19JRklGTyk7XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge0Jvb2xlYW59IElzIGEgc29ja2V0LlxuICovXG5TdGF0cy5wcm90b3R5cGUuaXNTb2NrZXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2NoZWNrTW9kZVByb3BlcnR5KGNvbnN0YW50cy5TX0lGU09DSyk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBiaW5kaW5nIHdpdGggdGhlIGdpdmVuIGZpbGUgc3lzdGVtLlxuICogQHBhcmFtIHtGaWxlU3lzdGVtfSBzeXN0ZW0gTW9jayBmaWxlIHN5c3RlbS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBCaW5kaW5nKHN5c3RlbSkge1xuICAvKipcbiAgICogTW9jayBmaWxlIHN5c3RlbS5cbiAgICogQHR5cGUge0ZpbGVTeXN0ZW19XG4gICAqL1xuICB0aGlzLl9zeXN0ZW0gPSBzeXN0ZW07XG5cbiAgLyoqXG4gICAqIFN0YXRzIGNvbnN0cnVjdG9yLlxuICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAqL1xuICB0aGlzLlN0YXRzID0gU3RhdHM7XG5cbiAgLyoqXG4gICAqIExvb2t1cCBvZiBvcGVuIGZpbGVzLlxuICAgKiBAdHlwZSB7T2JqZWN0LjxudW1iZXIsIEZpbGVEZXNjcmlwdG9yPn1cbiAgICovXG4gIHRoaXMuX29wZW5GaWxlcyA9IHt9O1xuXG4gIC8qKlxuICAgKiBDb3VudGVyIGZvciBmaWxlIGRlc2NyaXB0b3JzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5fY291bnRlciA9IC0xO1xuXG4gIGNvbnN0IHN0ZGluID0gbmV3IEZpbGVEZXNjcmlwdG9yKGNvbnN0YW50cy5PX1JEV1IpO1xuICBzdGRpbi5zZXRJdGVtKG5ldyBGaWxlLlN0YW5kYXJkSW5wdXQoKSk7XG4gIHRoaXMudHJhY2tEZXNjcmlwdG9yKHN0ZGluKTtcblxuICBjb25zdCBzdGRvdXQgPSBuZXcgRmlsZURlc2NyaXB0b3IoY29uc3RhbnRzLk9fUkRXUik7XG4gIHN0ZG91dC5zZXRJdGVtKG5ldyBGaWxlLlN0YW5kYXJkT3V0cHV0KCkpO1xuICB0aGlzLnRyYWNrRGVzY3JpcHRvcihzdGRvdXQpO1xuXG4gIGNvbnN0IHN0ZGVyciA9IG5ldyBGaWxlRGVzY3JpcHRvcihjb25zdGFudHMuT19SRFdSKTtcbiAgc3RkZXJyLnNldEl0ZW0obmV3IEZpbGUuU3RhbmRhcmRFcnJvcigpKTtcbiAgdGhpcy50cmFja0Rlc2NyaXB0b3Ioc3RkZXJyKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGZpbGUgc3lzdGVtIHVuZGVybHlpbmcgdGhpcyBiaW5kaW5nLlxuICogQHJldHVybiB7RmlsZVN5c3RlbX0gVGhlIHVuZGVybHlpbmcgZmlsZSBzeXN0ZW0uXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLmdldFN5c3RlbSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fc3lzdGVtO1xufTtcblxuLyoqXG4gKiBSZXNldCB0aGUgZmlsZSBzeXN0ZW0gdW5kZXJseWluZyB0aGlzIGJpbmRpbmcuXG4gKiBAcGFyYW0ge0ZpbGVTeXN0ZW19IHN5c3RlbSBUaGUgbmV3IGZpbGUgc3lzdGVtLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5zZXRTeXN0ZW0gPSBmdW5jdGlvbihzeXN0ZW0pIHtcbiAgdGhpcy5fc3lzdGVtID0gc3lzdGVtO1xufTtcblxuLyoqXG4gKiBHZXQgYSBmaWxlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZmQgRmlsZSBkZXNjcmlwdG9yIGlkZW50aWZpZXIuXG4gKiBAcmV0dXJuIHtGaWxlRGVzY3JpcHRvcn0gRmlsZSBkZXNjcmlwdG9yLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5nZXREZXNjcmlwdG9yQnlJZCA9IGZ1bmN0aW9uKGZkKSB7XG4gIGlmICghdGhpcy5fb3BlbkZpbGVzLmhhc093blByb3BlcnR5KGZkKSkge1xuICAgIHRocm93IG5ldyBGU0Vycm9yKCdFQkFERicpO1xuICB9XG4gIHJldHVybiB0aGlzLl9vcGVuRmlsZXNbZmRdO1xufTtcblxuLyoqXG4gKiBLZWVwIHRyYWNrIG9mIGEgZmlsZSBkZXNjcmlwdG9yIGFzIG9wZW4uXG4gKiBAcGFyYW0ge0ZpbGVEZXNjcmlwdG9yfSBkZXNjcmlwdG9yIFRoZSBmaWxlIGRlc2NyaXB0b3IuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IElkZW50aWZpZXIgZm9yIGZpbGUgZGVzY3JpcHRvci5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUudHJhY2tEZXNjcmlwdG9yID0gZnVuY3Rpb24oZGVzY3JpcHRvcikge1xuICBjb25zdCBmZCA9ICsrdGhpcy5fY291bnRlcjtcbiAgdGhpcy5fb3BlbkZpbGVzW2ZkXSA9IGRlc2NyaXB0b3I7XG4gIHJldHVybiBmZDtcbn07XG5cbi8qKlxuICogU3RvcCB0cmFja2luZyBhIGZpbGUgZGVzY3JpcHRvciBhcyBvcGVuLlxuICogQHBhcmFtIHtudW1iZXJ9IGZkIElkZW50aWZpZXIgZm9yIGZpbGUgZGVzY3JpcHRvci5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUudW50cmFja0Rlc2NyaXB0b3JCeUlkID0gZnVuY3Rpb24oZmQpIHtcbiAgaWYgKCF0aGlzLl9vcGVuRmlsZXMuaGFzT3duUHJvcGVydHkoZmQpKSB7XG4gICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VCQURGJyk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX29wZW5GaWxlc1tmZF07XG59O1xuXG4vKipcbiAqIFJlc29sdmUgdGhlIGNhbm9uaWNhbGl6ZWQgYWJzb2x1dGUgcGF0aG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ9IGZpbGVwYXRoIFRoZSBmaWxlIHBhdGguXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RpbmcgVGhlIGVuY29kaW5nIGZvciB0aGUgcmV0dXJuLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqIEByZXR1cm4ge3N0cmluZ3xCdWZmZXJ9IFRoZSByZWFsIHBhdGguXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLnJlYWxwYXRoID0gZnVuY3Rpb24oZmlsZXBhdGgsIGVuY29kaW5nLCBjYWxsYmFjaywgY3R4KSB7XG4gIG1hcmtTeXNjYWxsKGN0eCwgJ3JlYWxwYXRoJyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sobm9ybWFsaXplQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIGxldCByZWFsUGF0aDtcbiAgICBmaWxlcGF0aCA9IGRlQnVmZmVyKGZpbGVwYXRoKTtcbiAgICBjb25zdCByZXNvbHZlZCA9IHBhdGgucmVzb2x2ZShmaWxlcGF0aCk7XG4gICAgY29uc3QgcGFydHMgPSBnZXRQYXRoUGFydHMocmVzb2x2ZWQpO1xuICAgIGxldCBpdGVtID0gdGhpcy5fc3lzdGVtLmdldFJvb3QoKTtcbiAgICBsZXQgaXRlbVBhdGggPSAnLyc7XG4gICAgbGV0IG5hbWUsIGksIGlpO1xuICAgIGZvciAoaSA9IDAsIGlpID0gcGFydHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgbmFtZSA9IHBhcnRzW2ldO1xuICAgICAgd2hpbGUgKGl0ZW0gaW5zdGFuY2VvZiBTeW1ib2xpY0xpbmspIHtcbiAgICAgICAgaXRlbVBhdGggPSBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKGl0ZW1QYXRoKSwgaXRlbS5nZXRQYXRoKCkpO1xuICAgICAgICBpdGVtID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0oaXRlbVBhdGgpO1xuICAgICAgfVxuICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9FTlQnLCBmaWxlcGF0aCk7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIERpcmVjdG9yeSkge1xuICAgICAgICBpdGVtUGF0aCA9IHBhdGgucmVzb2x2ZShpdGVtUGF0aCwgbmFtZSk7XG4gICAgICAgIGl0ZW0gPSBpdGVtLmdldEl0ZW0obmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PVERJUicsIGZpbGVwYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHdoaWxlIChpdGVtIGluc3RhbmNlb2YgU3ltYm9saWNMaW5rKSB7XG4gICAgICAgIGl0ZW1QYXRoID0gcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZShpdGVtUGF0aCksIGl0ZW0uZ2V0UGF0aCgpKTtcbiAgICAgICAgaXRlbSA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKGl0ZW1QYXRoKTtcbiAgICAgIH1cbiAgICAgIHJlYWxQYXRoID0gaXRlbVBhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9FTlQnLCBmaWxlcGF0aCk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgJiYgcmVhbFBhdGguc3RhcnRzV2l0aCgnXFxcXFxcXFw/XFxcXCcpKSB7XG4gICAgICAvLyBSZW1vdmUgd2luMzIgZmlsZSBuYW1lc3BhY2UgcHJlZml4IFxcXFw/XFxcbiAgICAgIHJlYWxQYXRoID0gcmVhbFBhdGguc2xpY2UoNCk7XG4gICAgfVxuXG4gICAgaWYgKGVuY29kaW5nID09PSAnYnVmZmVyJykge1xuICAgICAgcmVhbFBhdGggPSBidWZmZXJGcm9tKHJlYWxQYXRoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVhbFBhdGg7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBGaWxsIGEgRmxvYXQ2NEFycmF5IHdpdGggc3RhdCBpbmZvcm1hdGlvblxuICogVGhpcyBpcyBiYXNlZCBvbiB0aGUgaW50ZXJuYWwgRmlsbFN0YXRzQXJyYXkgZnVuY3Rpb24gaW4gTm9kZS5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iLzRlMDU5NTJhOGE3NWFmNmRmNjI1NDE1ZGI2MTJkM2E5YTEzMjI2ODIvc3JjL25vZGVfZmlsZS5jYyNMNTMzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdHMgQW4gb2JqZWN0IHdpdGggZmlsZSBzdGF0c1xuICogQHBhcmFtIHtGbG9hdDY0QXJyYXl9IHN0YXRWYWx1ZXMgQSBGbG9hdDY0QXJyYXkgd2hlcmUgc3RhdCB2YWx1ZXMgc2hvdWxkIGJlIGluc2VydGVkXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gZmlsbFN0YXRzQXJyYXkoc3RhdHMsIHN0YXRWYWx1ZXMpIHtcbiAgc3RhdFZhbHVlc1swXSA9IHN0YXRzLmRldjtcbiAgc3RhdFZhbHVlc1sxXSA9IHN0YXRzLm1vZGU7XG4gIHN0YXRWYWx1ZXNbMl0gPSBzdGF0cy5ubGluaztcbiAgc3RhdFZhbHVlc1szXSA9IHN0YXRzLnVpZDtcbiAgc3RhdFZhbHVlc1s0XSA9IHN0YXRzLmdpZDtcbiAgc3RhdFZhbHVlc1s1XSA9IHN0YXRzLnJkZXY7XG4gIHN0YXRWYWx1ZXNbNl0gPSBzdGF0cy5ibGtzaXplO1xuICBzdGF0VmFsdWVzWzddID0gc3RhdHMuaW5vO1xuICBzdGF0VmFsdWVzWzhdID0gc3RhdHMuc2l6ZTtcbiAgc3RhdFZhbHVlc1s5XSA9IHN0YXRzLmJsb2NrcztcblxuICBpZiAoc3RhdENvbnRhaW5zTnMpIHtcbiAgICAvLyBub2RlanMgdjEyLjEwLjArXG4gICAgLy8gVGhpcyBpcyBiYXNlZCBvbiB0aGUgaW50ZXJuYWwgRmlsbFN0YXRzQXJyYXkgZnVuY3Rpb24gaW4gTm9kZS5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi8zYTJlNzVkOWE1YzMxZDIwZTQyOWQ1MDViODJkZDE4MmUzM2Y0NTlhL3NyYy9ub2RlX2ZpbGUuaCNMMTUzLUwxODdcbiAgICBzdGF0VmFsdWVzWzEwXSA9IE1hdGguZmxvb3Ioc3RhdHMuYXRpbWVNcyAvIDEwMDApO1xuICAgIHN0YXRWYWx1ZXNbMTFdID0gKHN0YXRzLmF0aW1lTXMgJSAxMDAwKSAqIDEwMDAwMDA7XG4gICAgc3RhdFZhbHVlc1sxMl0gPSBNYXRoLmZsb29yKHN0YXRzLm10aW1lTXMgLyAxMDAwKTtcbiAgICBzdGF0VmFsdWVzWzEzXSA9IChzdGF0cy5tdGltZU1zICUgMTAwMCkgKiAxMDAwMDAwO1xuICAgIHN0YXRWYWx1ZXNbMTRdID0gTWF0aC5mbG9vcihzdGF0cy5jdGltZU1zIC8gMTAwMCk7XG4gICAgc3RhdFZhbHVlc1sxNV0gPSAoc3RhdHMuY3RpbWVNcyAlIDEwMDApICogMTAwMDAwMDtcbiAgICBzdGF0VmFsdWVzWzE2XSA9IE1hdGguZmxvb3Ioc3RhdHMuYmlydGh0aW1lTXMgLyAxMDAwKTtcbiAgICBzdGF0VmFsdWVzWzE3XSA9IChzdGF0cy5iaXJ0aHRpbWVNcyAlIDEwMDApICogMTAwMDAwMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBub2RlanMgYmVmb3JlIHYxMi4xMC4wXG4gICAgLy8gVGhpcyBpcyBiYXNlZCBvbiB0aGUgaW50ZXJuYWwgRmlsbFN0YXRzQXJyYXkgZnVuY3Rpb24gaW4gTm9kZS5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi80ZTA1OTUyYThhNzVhZjZkZjYyNTQxNWRiNjEyZDNhOWExMzIyNjgyL3NyYy9ub2RlX2ZpbGUuY2MjTDUzM1xuICAgIHN0YXRWYWx1ZXNbMTBdID0gc3RhdHMuYXRpbWVNcztcbiAgICBzdGF0VmFsdWVzWzExXSA9IHN0YXRzLm10aW1lTXM7XG4gICAgc3RhdFZhbHVlc1sxMl0gPSBzdGF0cy5jdGltZU1zO1xuICAgIHN0YXRWYWx1ZXNbMTNdID0gc3RhdHMuYmlydGh0aW1lTXM7XG4gIH1cbn1cblxuLyoqXG4gKiBTdGF0IGFuIGl0ZW0uXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZXBhdGggUGF0aC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIFN0YXRzKXxGbG9hdDY0QXJyYXl8QmlnVWludDY0QXJyYXl9IGNhbGxiYWNrIENhbGxiYWNrIChvcHRpb25hbCkuIEluIE5vZGUgNy43LjArIHRoaXMgd2lsbCBiZSBhIEZsb2F0NjRBcnJheVxuICogdGhhdCBzaG91bGQgYmUgZmlsbGVkIHdpdGggc3RhdCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICogQHJldHVybiB7U3RhdHN8dW5kZWZpbmVkfSBTdGF0cyBvciB1bmRlZmluZWQgKGlmIHN5bmMpLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5zdGF0ID0gZnVuY3Rpb24oZmlsZXBhdGgsIG9wdGlvbnMsIGNhbGxiYWNrLCBjdHgpIHtcbiAgLy8gdGhpcyBzZWVtcyB3b3VuZCBub3QgaGFwcGVuIGluIG5vZGVqcyB2MTArXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBtYXJrU3lzY2FsbChjdHgsICdzdGF0Jyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sod3JhcFN0YXRzQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIGZpbGVwYXRoID0gZGVCdWZmZXIoZmlsZXBhdGgpO1xuICAgIGxldCBpdGVtID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0oZmlsZXBhdGgpO1xuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgU3ltYm9saWNMaW5rKSB7XG4gICAgICBpdGVtID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0oXG4gICAgICAgIHBhdGgucmVzb2x2ZShwYXRoLmRpcm5hbWUoZmlsZXBhdGgpLCBpdGVtLmdldFBhdGgoKSlcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghaXRlbSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT0VOVCcsIGZpbGVwYXRoKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhdHMgPSBpdGVtLmdldFN0YXRzKCk7XG5cbiAgICAvLyBJbiBOb2RlIDcuNy4wKywgYmluZGluZy5zdGF0IGFjY2VwdHMgYSBGbG9hdDY0QXJyYXkgYXMgdGhlIHNlY29uZCBhcmd1bWVudCxcbiAgICAvLyB3aGljaCBzaG91bGQgYmUgZmlsbGVkIHdpdGggc3RhdCB2YWx1ZXMuXG4gICAgLy8gSW4gcHJpb3IgdmVyc2lvbnMgb2YgTm9kZSwgYmluZGluZy5zdGF0IHNpbXBseSByZXR1cm5zIGEgU3RhdHMgaW5zdGFuY2UuXG4gICAgaWYgKFxuICAgICAgY2FsbGJhY2sgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkgfHxcbiAgICAgIGNhbGxiYWNrIGluc3RhbmNlb2YgQmlnVWludDY0QXJyYXlcbiAgICApIHtcbiAgICAgIGZpbGxTdGF0c0FycmF5KHN0YXRzLCBjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbGxTdGF0c0FycmF5KHN0YXRzLCBzdGF0VmFsdWVzKTtcbiAgICAgIHJldHVybiBuZXcgU3RhdHMoc3RhdHMpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIFN0YXQgYW4gaXRlbS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZCBGaWxlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBTdGF0cyl8RmxvYXQ2NEFycmF5fEJpZ1VpbnQ2NEFycmF5fSBjYWxsYmFjayBDYWxsYmFjayAob3B0aW9uYWwpLiBJbiBOb2RlIDcuNy4wKyB0aGlzIHdpbGwgYmUgYSBGbG9hdDY0QXJyYXlcbiAqIHRoYXQgc2hvdWxkIGJlIGZpbGxlZCB3aXRoIHN0YXQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqIEByZXR1cm4ge1N0YXRzfHVuZGVmaW5lZH0gU3RhdHMgb3IgdW5kZWZpbmVkIChpZiBzeW5jKS5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUuZnN0YXQgPSBmdW5jdGlvbihmZCwgb3B0aW9ucywgY2FsbGJhY2ssIGN0eCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgbWFya1N5c2NhbGwoY3R4LCAnZnN0YXQnKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayh3cmFwU3RhdHNDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IHRoaXMuZ2V0RGVzY3JpcHRvckJ5SWQoZmQpO1xuICAgIGNvbnN0IGl0ZW0gPSBkZXNjcmlwdG9yLmdldEl0ZW0oKTtcbiAgICBjb25zdCBzdGF0cyA9IGl0ZW0uZ2V0U3RhdHMoKTtcblxuICAgIC8vIEluIE5vZGUgNy43LjArLCBiaW5kaW5nLnN0YXQgYWNjZXB0cyBhIEZsb2F0NjRBcnJheSBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LFxuICAgIC8vIHdoaWNoIHNob3VsZCBiZSBmaWxsZWQgd2l0aCBzdGF0IHZhbHVlcy5cbiAgICAvLyBJbiBwcmlvciB2ZXJzaW9ucyBvZiBOb2RlLCBiaW5kaW5nLnN0YXQgc2ltcGx5IHJldHVybnMgYSBTdGF0cyBpbnN0YW5jZS5cbiAgICBpZiAoXG4gICAgICBjYWxsYmFjayBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSB8fFxuICAgICAgY2FsbGJhY2sgaW5zdGFuY2VvZiBCaWdVaW50NjRBcnJheVxuICAgICkge1xuICAgICAgZmlsbFN0YXRzQXJyYXkoc3RhdHMsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmlsbFN0YXRzQXJyYXkoc3RhdHMsIHN0YXRWYWx1ZXMpO1xuICAgICAgcmV0dXJuIG5ldyBTdGF0cyhzdGF0cyk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogQ2xvc2UgYSBmaWxlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZmQgRmlsZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrIENhbGxiYWNrIChvcHRpb25hbCkuXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKGZkLCBjYWxsYmFjaywgY3R4KSB7XG4gIG1hcmtTeXNjYWxsKGN0eCwgJ2Nsb3NlJyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sobm9ybWFsaXplQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudW50cmFja0Rlc2NyaXB0b3JCeUlkKGZkKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIE9wZW4gYW5kIHBvc3NpYmx5IGNyZWF0ZSBhIGZpbGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aG5hbWUgRmlsZSBwYXRoLlxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzIEZsYWdzLlxuICogQHBhcmFtIHtudW1iZXJ9IG1vZGUgTW9kZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIHN0cmluZyl9IGNhbGxiYWNrIENhbGxiYWNrIChvcHRpb25hbCkuXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICogQHJldHVybiB7c3RyaW5nfSBGaWxlIGRlc2NyaXB0b3IgKGlmIHN5bmMpLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24ocGF0aG5hbWUsIGZsYWdzLCBtb2RlLCBjYWxsYmFjaywgY3R4KSB7XG4gIG1hcmtTeXNjYWxsKGN0eCwgJ29wZW4nKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgcGF0aG5hbWUgPSBkZUJ1ZmZlcihwYXRobmFtZSk7XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IG5ldyBGaWxlRGVzY3JpcHRvcihmbGFncyk7XG4gICAgbGV0IGl0ZW0gPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShwYXRobmFtZSk7XG4gICAgd2hpbGUgKGl0ZW0gaW5zdGFuY2VvZiBTeW1ib2xpY0xpbmspIHtcbiAgICAgIGl0ZW0gPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShcbiAgICAgICAgcGF0aC5yZXNvbHZlKHBhdGguZGlybmFtZShwYXRobmFtZSksIGl0ZW0uZ2V0UGF0aCgpKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGRlc2NyaXB0b3IuaXNFeGNsdXNpdmUoKSAmJiBpdGVtKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUVYSVNUJywgcGF0aG5hbWUpO1xuICAgIH1cbiAgICBpZiAoZGVzY3JpcHRvci5pc0NyZWF0ZSgpICYmICFpdGVtKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShwYXRoLmRpcm5hbWUocGF0aG5hbWUpKTtcbiAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9FTlQnLCBwYXRobmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAoIShwYXJlbnQgaW5zdGFuY2VvZiBEaXJlY3RvcnkpKSB7XG4gICAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9URElSJywgcGF0aG5hbWUpO1xuICAgICAgfVxuICAgICAgaXRlbSA9IG5ldyBGaWxlKCk7XG4gICAgICBpZiAobW9kZSkge1xuICAgICAgICBpdGVtLnNldE1vZGUobW9kZSk7XG4gICAgICB9XG4gICAgICBwYXJlbnQuYWRkSXRlbShwYXRoLmJhc2VuYW1lKHBhdGhuYW1lKSwgaXRlbSk7XG4gICAgfVxuICAgIGlmIChkZXNjcmlwdG9yLmlzUmVhZCgpKSB7XG4gICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT0VOVCcsIHBhdGhuYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXRlbS5jYW5SZWFkKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VBQ0NFUycsIHBhdGhuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlc2NyaXB0b3IuaXNXcml0ZSgpICYmICFpdGVtLmNhbldyaXRlKCkpIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFQUNDRVMnLCBwYXRobmFtZSk7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIGl0ZW0gaW5zdGFuY2VvZiBEaXJlY3RvcnkgJiZcbiAgICAgIChkZXNjcmlwdG9yLmlzVHJ1bmNhdGUoKSB8fCBkZXNjcmlwdG9yLmlzQXBwZW5kKCkpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUlTRElSJywgcGF0aG5hbWUpO1xuICAgIH1cbiAgICBpZiAoZGVzY3JpcHRvci5pc1RydW5jYXRlKCkpIHtcbiAgICAgIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBGaWxlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUJBREYnKTtcbiAgICAgIH1cbiAgICAgIGl0ZW0uc2V0Q29udGVudCgnJyk7XG4gICAgfVxuICAgIGlmIChkZXNjcmlwdG9yLmlzVHJ1bmNhdGUoKSB8fCBkZXNjcmlwdG9yLmlzQXBwZW5kKCkpIHtcbiAgICAgIGRlc2NyaXB0b3Iuc2V0UG9zaXRpb24oaXRlbS5nZXRDb250ZW50KCkubGVuZ3RoKTtcbiAgICB9XG4gICAgZGVzY3JpcHRvci5zZXRJdGVtKGl0ZW0pO1xuICAgIHJldHVybiB0aGlzLnRyYWNrRGVzY3JpcHRvcihkZXNjcmlwdG9yKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIE9wZW4gYSBmaWxlIGhhbmRsZXIuIEEgbmV3IGFwaSBpbiBub2RlanMgdjEwKyBmb3IgZnMucHJvbWlzZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRobmFtZSBGaWxlIHBhdGguXG4gKiBAcGFyYW0ge251bWJlcn0gZmxhZ3MgRmxhZ3MuXG4gKiBAcGFyYW0ge251bWJlcn0gbW9kZSBNb2RlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgKG9wdGlvbmFsKSwgZXhwZWN0aW5nIGtVc2VQcm9taXNlcyBpbiBub2RlanMgdjEwKy5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUub3BlbkZpbGVIYW5kbGUgPSBmdW5jdGlvbihwYXRobmFtZSwgZmxhZ3MsIG1vZGUsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gIHJldHVybiB0aGlzLm9wZW4ocGF0aG5hbWUsIGZsYWdzLCBtb2RlLCBrVXNlUHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oZmQpIHtcbiAgICAvLyBub2RlanMgdjEwKyBmcy5wcm9taXNlcyBGaWxlSGFuZGxlciBjb25zdHJ1Y3RvciBvbmx5IGFzayB0aGVzZSB0aHJlZSBwcm9wZXJ0aWVzLlxuICAgIHJldHVybiB7XG4gICAgICBnZXRBc3luY0lkOiBub3RJbXBsZW1lbnRlZCxcbiAgICAgIGZkOiBmZCxcbiAgICAgIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuY2xvc2UoZmQsIGtVc2VQcm9taXNlcyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJlYWQgZnJvbSBhIGZpbGUgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmZCBGaWxlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIEJ1ZmZlciB0aGF0IHRoZSBjb250ZW50cyB3aWxsIGJlIHdyaXR0ZW4gdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldCBpbiB0aGUgYnVmZmVyIHRvIHN0YXJ0IHdyaXRpbmcgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIE51bWJlciBvZiBieXRlcyB0byByZWFkLlxuICogQHBhcmFtIHs/bnVtYmVyfSBwb3NpdGlvbiBXaGVyZSB0byBiZWdpbiByZWFkaW5nIGluIHRoZSBmaWxlLiAgSWYgbnVsbCxcbiAqICAgICBkYXRhIHdpbGwgYmUgcmVhZCBmcm9tIHRoZSBjdXJyZW50IGZpbGUgcG9zaXRpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCBudW1iZXIsIEJ1ZmZlcil9IGNhbGxiYWNrIENhbGxiYWNrIChvcHRpb25hbCkgY2FsbGVkXG4gKiAgICAgd2l0aCBhbnkgZXJyb3IsIG51bWJlciBvZiBieXRlcyByZWFkLCBhbmQgdGhlIGJ1ZmZlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE51bWJlciBvZiBieXRlcyByZWFkIChpZiBzeW5jKS5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uKFxuICBmZCxcbiAgYnVmZmVyLFxuICBvZmZzZXQsXG4gIGxlbmd0aCxcbiAgcG9zaXRpb24sXG4gIGNhbGxiYWNrLFxuICBjdHhcbikge1xuICBtYXJrU3lzY2FsbChjdHgsICdyZWFkJyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sobm9ybWFsaXplQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB0aGlzLmdldERlc2NyaXB0b3JCeUlkKGZkKTtcbiAgICBpZiAoIWRlc2NyaXB0b3IuaXNSZWFkKCkpIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFQkFERicpO1xuICAgIH1cbiAgICBjb25zdCBmaWxlID0gZGVzY3JpcHRvci5nZXRJdGVtKCk7XG4gICAgaWYgKGZpbGUgaW5zdGFuY2VvZiBEaXJlY3RvcnkpIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFSVNESVInKTtcbiAgICB9XG4gICAgaWYgKCEoZmlsZSBpbnN0YW5jZW9mIEZpbGUpKSB7XG4gICAgICAvLyBkZWxldGVkIG9yIG5vdCBhIHJlZ3VsYXIgZmlsZVxuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VCQURGJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcG9zaXRpb24gIT09ICdudW1iZXInIHx8IHBvc2l0aW9uIDwgMCkge1xuICAgICAgcG9zaXRpb24gPSBkZXNjcmlwdG9yLmdldFBvc2l0aW9uKCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRlbnQgPSBmaWxlLmdldENvbnRlbnQoKTtcbiAgICBjb25zdCBzdGFydCA9IE1hdGgubWluKHBvc2l0aW9uLCBjb250ZW50Lmxlbmd0aCk7XG4gICAgY29uc3QgZW5kID0gTWF0aC5taW4ocG9zaXRpb24gKyBsZW5ndGgsIGNvbnRlbnQubGVuZ3RoKTtcbiAgICBjb25zdCByZWFkID0gc3RhcnQgPCBlbmQgPyBjb250ZW50LmNvcHkoYnVmZmVyLCBvZmZzZXQsIHN0YXJ0LCBlbmQpIDogMDtcbiAgICBkZXNjcmlwdG9yLnNldFBvc2l0aW9uKHBvc2l0aW9uICsgcmVhZCk7XG4gICAgcmV0dXJuIHJlYWQ7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBXcml0ZSB0byBhIGZpbGUgZGVzY3JpcHRvciBnaXZlbiBhIGJ1ZmZlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgU291cmNlIGZpbGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdCBEZXN0aW5hdGlvbiBmaWxlLlxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzIE1vZGlmaWVycyBmb3IgY29weSBvcGVyYXRpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2sgQ2FsbGJhY2sgKG9wdGlvbmFsKSBjYWxsZWRcbiAqICAgICB3aXRoIGFueSBlcnJvci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLmNvcHlGaWxlID0gZnVuY3Rpb24oc3JjLCBkZXN0LCBmbGFncywgY2FsbGJhY2ssIGN0eCkge1xuICBtYXJrU3lzY2FsbChjdHgsICdjb3B5ZmlsZScpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBzcmMgPSBkZUJ1ZmZlcihzcmMpO1xuICAgIGRlc3QgPSBkZUJ1ZmZlcihkZXN0KTtcbiAgICBjb25zdCBzcmNGZCA9IHRoaXMub3BlbihzcmMsIGNvbnN0YW50cy5PX1JET05MWSk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3JjRGVzY3JpcHRvciA9IHRoaXMuZ2V0RGVzY3JpcHRvckJ5SWQoc3JjRmQpO1xuICAgICAgaWYgKCFzcmNEZXNjcmlwdG9yLmlzUmVhZCgpKSB7XG4gICAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFQkFERicpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3JjRmlsZSA9IHNyY0Rlc2NyaXB0b3IuZ2V0SXRlbSgpO1xuICAgICAgaWYgKCEoc3JjRmlsZSBpbnN0YW5jZW9mIEZpbGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFQkFERicpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3JjQ29udGVudCA9IHNyY0ZpbGUuZ2V0Q29udGVudCgpO1xuXG4gICAgICBsZXQgZGVzdEZsYWdzID1cbiAgICAgICAgY29uc3RhbnRzLk9fV1JPTkxZIHwgY29uc3RhbnRzLk9fQ1JFQVQgfCBjb25zdGFudHMuT19UUlVOQztcblxuICAgICAgaWYgKChmbGFncyAmIGNvbnN0YW50cy5DT1BZRklMRV9FWENMKSA9PT0gY29uc3RhbnRzLkNPUFlGSUxFX0VYQ0wpIHtcbiAgICAgICAgZGVzdEZsYWdzIHw9IGNvbnN0YW50cy5PX0VYQ0w7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRlc3RGZCA9IHRoaXMub3BlbihkZXN0LCBkZXN0RmxhZ3MpO1xuXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLndyaXRlKGRlc3RGZCwgc3JjQ29udGVudCwgMCwgc3JjQ29udGVudC5sZW5ndGgsIDApO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5jbG9zZShkZXN0RmQpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmNsb3NlKHNyY0ZkKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBXcml0ZSB0byBhIGZpbGUgZGVzY3JpcHRvciBnaXZlbiBhIGJ1ZmZlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmZCBGaWxlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge0FycmF5PEJ1ZmZlcj59IGJ1ZmZlcnMgQXJyYXkgb2YgYnVmZmVycyB3aXRoIGNvbnRlbnRzIHRvIHdyaXRlLlxuICogQHBhcmFtIHs/bnVtYmVyfSBwb3NpdGlvbiBXaGVyZSB0byBiZWdpbiB3cml0aW5nIGluIHRoZSBmaWxlLiAgSWYgbnVsbCxcbiAqICAgICBkYXRhIHdpbGwgYmUgd3JpdHRlbiB0byB0aGUgY3VycmVudCBmaWxlIHBvc2l0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgbnVtYmVyLCBCdWZmZXIpfSBjYWxsYmFjayBDYWxsYmFjayAob3B0aW9uYWwpIGNhbGxlZFxuICogICAgIHdpdGggYW55IGVycm9yLCBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiwgYW5kIHRoZSBidWZmZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICogQHJldHVybiB7bnVtYmVyfSBOdW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiAoaWYgc3luYykuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLndyaXRlQnVmZmVycyA9IGZ1bmN0aW9uKFxuICBmZCxcbiAgYnVmZmVycyxcbiAgcG9zaXRpb24sXG4gIGNhbGxiYWNrLFxuICBjdHhcbikge1xuICBtYXJrU3lzY2FsbChjdHgsICd3cml0ZScpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gdGhpcy5nZXREZXNjcmlwdG9yQnlJZChmZCk7XG4gICAgaWYgKCFkZXNjcmlwdG9yLmlzV3JpdGUoKSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VCQURGJyk7XG4gICAgfVxuICAgIGNvbnN0IGZpbGUgPSBkZXNjcmlwdG9yLmdldEl0ZW0oKTtcbiAgICBpZiAoIShmaWxlIGluc3RhbmNlb2YgRmlsZSkpIHtcbiAgICAgIC8vIG5vdCBhIHJlZ3VsYXIgZmlsZVxuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VCQURGJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcG9zaXRpb24gIT09ICdudW1iZXInIHx8IHBvc2l0aW9uIDwgMCkge1xuICAgICAgcG9zaXRpb24gPSBkZXNjcmlwdG9yLmdldFBvc2l0aW9uKCk7XG4gICAgfVxuICAgIGxldCBjb250ZW50ID0gZmlsZS5nZXRDb250ZW50KCk7XG4gICAgY29uc3QgbmV3Q29udGVudCA9IEJ1ZmZlci5jb25jYXQoYnVmZmVycyk7XG4gICAgY29uc3QgbmV3TGVuZ3RoID0gcG9zaXRpb24gKyBuZXdDb250ZW50Lmxlbmd0aDtcbiAgICBpZiAoY29udGVudC5sZW5ndGggPCBuZXdMZW5ndGgpIHtcbiAgICAgIGNvbnN0IHRlbXBDb250ZW50ID0gYnVmZmVyQWxsb2MobmV3TGVuZ3RoKTtcbiAgICAgIGNvbnRlbnQuY29weSh0ZW1wQ29udGVudCk7XG4gICAgICBjb250ZW50ID0gdGVtcENvbnRlbnQ7XG4gICAgfVxuICAgIGNvbnN0IHdyaXR0ZW4gPSBuZXdDb250ZW50LmNvcHkoY29udGVudCwgcG9zaXRpb24pO1xuICAgIGZpbGUuc2V0Q29udGVudChjb250ZW50KTtcbiAgICBkZXNjcmlwdG9yLnNldFBvc2l0aW9uKG5ld0xlbmd0aCk7XG4gICAgcmV0dXJuIHdyaXR0ZW47XG4gIH0pO1xufTtcblxuLyoqXG4gKiBXcml0ZSB0byBhIGZpbGUgZGVzY3JpcHRvciBnaXZlbiBhIGJ1ZmZlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmZCBGaWxlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIEJ1ZmZlciB3aXRoIGNvbnRlbnRzIHRvIHdyaXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBPZmZzZXQgaW4gdGhlIGJ1ZmZlciB0byBzdGFydCB3cml0aW5nIGZyb20uXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIE51bWJlciBvZiBieXRlcyB0byB3cml0ZS5cbiAqIEBwYXJhbSB7P251bWJlcn0gcG9zaXRpb24gV2hlcmUgdG8gYmVnaW4gd3JpdGluZyBpbiB0aGUgZmlsZS4gIElmIG51bGwsXG4gKiAgICAgZGF0YSB3aWxsIGJlIHdyaXR0ZW4gdG8gdGhlIGN1cnJlbnQgZmlsZSBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIG51bWJlciwgQnVmZmVyKX0gY2FsbGJhY2sgQ2FsbGJhY2sgKG9wdGlvbmFsKSBjYWxsZWRcbiAqICAgICB3aXRoIGFueSBlcnJvciwgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4sIGFuZCB0aGUgYnVmZmVyLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqIEByZXR1cm4ge251bWJlcn0gTnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4gKGlmIHN5bmMpLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS53cml0ZUJ1ZmZlciA9IGZ1bmN0aW9uKFxuICBmZCxcbiAgYnVmZmVyLFxuICBvZmZzZXQsXG4gIGxlbmd0aCxcbiAgcG9zaXRpb24sXG4gIGNhbGxiYWNrLFxuICBjdHhcbikge1xuICBtYXJrU3lzY2FsbChjdHgsICd3cml0ZScpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gdGhpcy5nZXREZXNjcmlwdG9yQnlJZChmZCk7XG4gICAgaWYgKCFkZXNjcmlwdG9yLmlzV3JpdGUoKSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VCQURGJyk7XG4gICAgfVxuICAgIGNvbnN0IGZpbGUgPSBkZXNjcmlwdG9yLmdldEl0ZW0oKTtcbiAgICBpZiAoIShmaWxlIGluc3RhbmNlb2YgRmlsZSkpIHtcbiAgICAgIC8vIG5vdCBhIHJlZ3VsYXIgZmlsZVxuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VCQURGJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcG9zaXRpb24gIT09ICdudW1iZXInIHx8IHBvc2l0aW9uIDwgMCkge1xuICAgICAgcG9zaXRpb24gPSBkZXNjcmlwdG9yLmdldFBvc2l0aW9uKCk7XG4gICAgfVxuICAgIGxldCBjb250ZW50ID0gZmlsZS5nZXRDb250ZW50KCk7XG4gICAgY29uc3QgbmV3TGVuZ3RoID0gcG9zaXRpb24gKyBsZW5ndGg7XG4gICAgaWYgKGNvbnRlbnQubGVuZ3RoIDwgbmV3TGVuZ3RoKSB7XG4gICAgICBjb25zdCBuZXdDb250ZW50ID0gYnVmZmVyQWxsb2MobmV3TGVuZ3RoKTtcbiAgICAgIGNvbnRlbnQuY29weShuZXdDb250ZW50KTtcbiAgICAgIGNvbnRlbnQgPSBuZXdDb250ZW50O1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VFbmQgPSBNYXRoLm1pbihvZmZzZXQgKyBsZW5ndGgsIGJ1ZmZlci5sZW5ndGgpO1xuICAgIGNvbnN0IHdyaXR0ZW4gPSBidWZmZXJGcm9tKGJ1ZmZlcikuY29weShcbiAgICAgIGNvbnRlbnQsXG4gICAgICBwb3NpdGlvbixcbiAgICAgIG9mZnNldCxcbiAgICAgIHNvdXJjZUVuZFxuICAgICk7XG4gICAgZmlsZS5zZXRDb250ZW50KGNvbnRlbnQpO1xuICAgIGRlc2NyaXB0b3Iuc2V0UG9zaXRpb24obmV3TGVuZ3RoKTtcbiAgICByZXR1cm4gd3JpdHRlbjtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB3cml0ZUJ1ZmZlciAodXNlZCBpbiBOb2RlIDw9IDAuMTApLlxuICogQHBhcmFtIHtzdHJpbmd9IGZkIEZpbGUgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgQnVmZmVyIHdpdGggY29udGVudHMgdG8gd3JpdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IE9mZnNldCBpbiB0aGUgYnVmZmVyIHRvIHN0YXJ0IHdyaXRpbmcgZnJvbS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggTnVtYmVyIG9mIGJ5dGVzIHRvIHdyaXRlLlxuICogQHBhcmFtIHs/bnVtYmVyfSBwb3NpdGlvbiBXaGVyZSB0byBiZWdpbiB3cml0aW5nIGluIHRoZSBmaWxlLiAgSWYgbnVsbCxcbiAqICAgICBkYXRhIHdpbGwgYmUgd3JpdHRlbiB0byB0aGUgY3VycmVudCBmaWxlIHBvc2l0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgbnVtYmVyLCBCdWZmZXIpfSBjYWxsYmFjayBDYWxsYmFjayAob3B0aW9uYWwpIGNhbGxlZFxuICogICAgIHdpdGggYW55IGVycm9yLCBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiwgYW5kIHRoZSBidWZmZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICogQHJldHVybiB7bnVtYmVyfSBOdW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiAoaWYgc3luYykuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLndyaXRlID0gQmluZGluZy5wcm90b3R5cGUud3JpdGVCdWZmZXI7XG5cbi8qKlxuICogV3JpdGUgdG8gYSBmaWxlIGRlc2NyaXB0b3IgZ2l2ZW4gYSBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmQgRmlsZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTdHJpbmcgd2l0aCBjb250ZW50cyB0byB3cml0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiBXaGVyZSB0byBiZWdpbiB3cml0aW5nIGluIHRoZSBmaWxlLiAgSWYgbnVsbCxcbiAqICAgICBkYXRhIHdpbGwgYmUgd3JpdHRlbiB0byB0aGUgY3VycmVudCBmaWxlIHBvc2l0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nIFN0cmluZyBlbmNvZGluZy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIG51bWJlciwgc3RyaW5nKX0gY2FsbGJhY2sgQ2FsbGJhY2sgKG9wdGlvbmFsKSBjYWxsZWRcbiAqICAgICB3aXRoIGFueSBlcnJvciwgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4sIGFuZCB0aGUgc3RyaW5nLlxuICogQHJldHVybiB7bnVtYmVyfSBOdW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiAoaWYgc3luYykuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLndyaXRlU3RyaW5nID0gZnVuY3Rpb24oXG4gIGZkLFxuICBzdHJpbmcsXG4gIHBvc2l0aW9uLFxuICBlbmNvZGluZyxcbiAgY2FsbGJhY2ssXG4gIGN0eFxuKSB7XG4gIG1hcmtTeXNjYWxsKGN0eCwgJ3dyaXRlJyk7XG5cbiAgY29uc3QgYnVmZmVyID0gYnVmZmVyRnJvbShzdHJpbmcsIGVuY29kaW5nKTtcbiAgbGV0IHdyYXBwZXI7XG4gIGlmIChjYWxsYmFjayAmJiBjYWxsYmFjayAhPT0ga1VzZVByb21pc2VzKSB7XG4gICAgaWYgKGNhbGxiYWNrLm9uY29tcGxldGUpIHtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sub25jb21wbGV0ZS5iaW5kKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgd3JhcHBlciA9IGZ1bmN0aW9uKGVyciwgd3JpdHRlbiwgcmV0dXJuZWQpIHtcbiAgICAgIGNhbGxiYWNrKGVyciwgd3JpdHRlbiwgcmV0dXJuZWQgJiYgc3RyaW5nKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiB0aGlzLndyaXRlQnVmZmVyKGZkLCBidWZmZXIsIDAsIHN0cmluZy5sZW5ndGgsIHBvc2l0aW9uLCB3cmFwcGVyLCBjdHgpO1xufTtcblxuLyoqXG4gKiBSZW5hbWUgYSBmaWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IG9sZFBhdGggT2xkIHBhdGhuYW1lLlxuICogQHBhcmFtIHtzdHJpbmd9IG5ld1BhdGggTmV3IHBhdGhuYW1lLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrIENhbGxiYWNrIChvcHRpb25hbCkuXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5yZW5hbWUgPSBmdW5jdGlvbihvbGRQYXRoLCBuZXdQYXRoLCBjYWxsYmFjaywgY3R4KSB7XG4gIG1hcmtTeXNjYWxsKGN0eCwgJ3JlbmFtZScpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBvbGRQYXRoID0gZGVCdWZmZXIob2xkUGF0aCk7XG4gICAgbmV3UGF0aCA9IGRlQnVmZmVyKG5ld1BhdGgpO1xuICAgIGNvbnN0IG9sZEl0ZW0gPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShvbGRQYXRoKTtcbiAgICBpZiAoIW9sZEl0ZW0pIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9FTlQnLCBvbGRQYXRoKTtcbiAgICB9XG4gICAgY29uc3Qgb2xkUGFyZW50ID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0ocGF0aC5kaXJuYW1lKG9sZFBhdGgpKTtcbiAgICBjb25zdCBvbGROYW1lID0gcGF0aC5iYXNlbmFtZShvbGRQYXRoKTtcbiAgICBjb25zdCBuZXdJdGVtID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0obmV3UGF0aCk7XG4gICAgY29uc3QgbmV3UGFyZW50ID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0ocGF0aC5kaXJuYW1lKG5ld1BhdGgpKTtcbiAgICBjb25zdCBuZXdOYW1lID0gcGF0aC5iYXNlbmFtZShuZXdQYXRoKTtcbiAgICBpZiAobmV3SXRlbSkge1xuICAgICAgLy8gbWFrZSBzdXJlIHRoZXkgYXJlIHRoZSBzYW1lIHR5cGVcbiAgICAgIGlmIChvbGRJdGVtIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICBpZiAobmV3SXRlbSBpbnN0YW5jZW9mIERpcmVjdG9yeSkge1xuICAgICAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFSVNESVInLCBuZXdQYXRoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvbGRJdGVtIGluc3RhbmNlb2YgRGlyZWN0b3J5KSB7XG4gICAgICAgIGlmICghKG5ld0l0ZW0gaW5zdGFuY2VvZiBEaXJlY3RvcnkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT1RESVInLCBuZXdQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3SXRlbS5saXN0KCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9URU1QVFknLCBuZXdQYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmV3UGFyZW50LnJlbW92ZUl0ZW0obmV3TmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghbmV3UGFyZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9FTlQnLCBuZXdQYXRoKTtcbiAgICAgIH1cbiAgICAgIGlmICghKG5ld1BhcmVudCBpbnN0YW5jZW9mIERpcmVjdG9yeSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT1RESVInLCBuZXdQYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgb2xkUGFyZW50LnJlbW92ZUl0ZW0ob2xkTmFtZSk7XG4gICAgbmV3UGFyZW50LmFkZEl0ZW0obmV3TmFtZSwgb2xkSXRlbSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZWFkIGEgZGlyZWN0b3J5LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpcnBhdGggUGF0aCB0byBkaXJlY3RvcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RpbmcgVGhlIGVuY29kaW5nICgndXRmLTgnIG9yICdidWZmZXInKS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gd2l0aEZpbGVUeXBlcyB3aGV0aGVyIG9yIG5vdCB0byByZXR1cm4gZnMuRGlyZW50IG9iamVjdHNcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIChBcnJheS48c3RyaW5nPnxBcnJheS48QnVmZmVyPil9IGNhbGxiYWNrIENhbGxiYWNrXG4gKiAgICAgKG9wdGlvbmFsKSBjYWxsZWQgd2l0aCBhbnkgZXJyb3Igb3IgYXJyYXkgb2YgaXRlbXMgaW4gdGhlIGRpcmVjdG9yeS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKiBAcmV0dXJuIHtBcnJheS48c3RyaW5nPnxBcnJheS48QnVmZmVyPn0gQXJyYXkgb2YgaXRlbXMgaW4gZGlyZWN0b3J5IChpZiBzeW5jKS5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUucmVhZGRpciA9IGZ1bmN0aW9uKFxuICBkaXJwYXRoLFxuICBlbmNvZGluZyxcbiAgd2l0aEZpbGVUeXBlcyxcbiAgY2FsbGJhY2ssXG4gIGN0eFxuKSB7XG4gIC8vIGFnYWluLCB0aGUgc2hvcnRlciBhcmd1bWVudHMgd291bGQgbm90IGhhcHBlbiBpbiBub2RlanMgdjEwK1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIGNhbGxiYWNrID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSAndXRmLTgnO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBjYWxsYmFjayA9IHdpdGhGaWxlVHlwZXM7XG4gIH1cblxuICBtYXJrU3lzY2FsbChjdHgsICdzY2FuZGlyJyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sobm9ybWFsaXplQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIGRpcnBhdGggPSBkZUJ1ZmZlcihkaXJwYXRoKTtcbiAgICBsZXQgZHBhdGggPSBkaXJwYXRoO1xuICAgIGxldCBkaXIgPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShkaXJwYXRoKTtcbiAgICB3aGlsZSAoZGlyIGluc3RhbmNlb2YgU3ltYm9saWNMaW5rKSB7XG4gICAgICBkcGF0aCA9IHBhdGgucmVzb2x2ZShwYXRoLmRpcm5hbWUoZHBhdGgpLCBkaXIuZ2V0UGF0aCgpKTtcbiAgICAgIGRpciA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKGRwYXRoKTtcbiAgICB9XG4gICAgaWYgKCFkaXIpIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9FTlQnLCBkaXJwYXRoKTtcbiAgICB9XG4gICAgaWYgKCEoZGlyIGluc3RhbmNlb2YgRGlyZWN0b3J5KSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT1RESVInLCBkaXJwYXRoKTtcbiAgICB9XG4gICAgaWYgKCFkaXIuY2FuUmVhZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUFDQ0VTJywgZGlycGF0aCk7XG4gICAgfVxuXG4gICAgbGV0IGxpc3QgPSBkaXIubGlzdCgpO1xuICAgIGlmIChlbmNvZGluZyA9PT0gJ2J1ZmZlcicpIHtcbiAgICAgIGxpc3QgPSBsaXN0Lm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHJldHVybiBidWZmZXJGcm9tKGl0ZW0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHdpdGhGaWxlVHlwZXMgPT09IHRydWUpIHtcbiAgICAgIGNvbnN0IHR5cGVzID0gbGlzdC5tYXAoZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBjb25zdCBzdGF0cyA9IGRpci5nZXRJdGVtKG5hbWUpLmdldFN0YXRzKCk7XG5cbiAgICAgICAgcmV0dXJuIGdldERpcmVudFR5cGUoc3RhdHMubW9kZSk7XG4gICAgICB9KTtcbiAgICAgIGxpc3QgPSBbbGlzdCwgdHlwZXNdO1xuICAgIH1cblxuICAgIHJldHVybiBsaXN0O1xuICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgZGlyZWN0b3J5LlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhuYW1lIFBhdGggdG8gbmV3IGRpcmVjdG9yeS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtb2RlIFBlcm1pc3Npb25zLlxuICogQHBhcmFtIHtib29sZWFufSByZWN1cnNpdmUgUmVjdXJzaXZlbHkgY3JlYXRlIGRlZXAgZGlyZWN0b3J5LiAoYWRkZWQgaW4gbm9kZWpzIHYxMCspXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2sgT3B0aW9uYWwgY2FsbGJhY2suXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5ta2RpciA9IGZ1bmN0aW9uKHBhdGhuYW1lLCBtb2RlLCByZWN1cnNpdmUsIGNhbGxiYWNrLCBjdHgpIHtcbiAgaWYgKHR5cGVvZiByZWN1cnNpdmUgIT09ICdib29sZWFuJykge1xuICAgIC8vIHdoZW4gcnVubmluZyBub2RlanMgPCAxMFxuICAgIGN0eCA9IGNhbGxiYWNrO1xuICAgIGNhbGxiYWNrID0gcmVjdXJzaXZlO1xuICAgIHJlY3Vyc2l2ZSA9IGZhbHNlO1xuICB9XG5cbiAgbWFya1N5c2NhbGwoY3R4LCAnbWtkaXInKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgcGF0aG5hbWUgPSBkZUJ1ZmZlcihwYXRobmFtZSk7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKHBhdGhuYW1lKTtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgaWYgKHJlY3Vyc2l2ZSAmJiBpdGVtIGluc3RhbmNlb2YgRGlyZWN0b3J5KSB7XG4gICAgICAgIC8vIHNpbGVudGx5IHBhc3MgZXhpc3RpbmcgZm9sZGVyIGluIHJlY3Vyc2l2ZSBtb2RlXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFRVhJU1QnLCBwYXRobmFtZSk7XG4gICAgfVxuXG4gICAgY29uc3QgX21rZGlyID0gZnVuY3Rpb24oX3BhdGhuYW1lKSB7XG4gICAgICBjb25zdCBwYXJlbnREaXIgPSBwYXRoLmRpcm5hbWUoX3BhdGhuYW1lKTtcbiAgICAgIGxldCBwYXJlbnQgPSB0aGlzLl9zeXN0ZW0uZ2V0SXRlbShwYXJlbnREaXIpO1xuICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgaWYgKCFyZWN1cnNpdmUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PRU5UJywgX3BhdGhuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQgPSBfbWtkaXIocGFyZW50RGlyLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWNjZXNzKHBhcmVudERpciwgcGFyc2VJbnQoJzAwMDInLCA4KSk7XG4gICAgICBjb25zdCBkaXIgPSBuZXcgRGlyZWN0b3J5KCk7XG4gICAgICBpZiAobW9kZSkge1xuICAgICAgICBkaXIuc2V0TW9kZShtb2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJlbnQuYWRkSXRlbShwYXRoLmJhc2VuYW1lKF9wYXRobmFtZSksIGRpcik7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgX21rZGlyKHBhdGhuYW1lKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIGRpcmVjdG9yeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRobmFtZSBQYXRoIHRvIGRpcmVjdG9yeS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFjayBPcHRpb25hbCBjYWxsYmFjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLnJtZGlyID0gZnVuY3Rpb24ocGF0aG5hbWUsIGNhbGxiYWNrLCBjdHgpIHtcbiAgbWFya1N5c2NhbGwoY3R4LCAncm1kaXInKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgcGF0aG5hbWUgPSBkZUJ1ZmZlcihwYXRobmFtZSk7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKHBhdGhuYW1lKTtcbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9FTlQnLCBwYXRobmFtZSk7XG4gICAgfVxuICAgIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBEaXJlY3RvcnkpKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PVERJUicsIHBhdGhuYW1lKTtcbiAgICB9XG4gICAgaWYgKGl0ZW0ubGlzdCgpLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9URU1QVFknLCBwYXRobmFtZSk7XG4gICAgfVxuICAgIHRoaXMuYWNjZXNzKHBhdGguZGlybmFtZShwYXRobmFtZSksIHBhcnNlSW50KCcwMDAyJywgOCkpO1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKHBhdGguZGlybmFtZShwYXRobmFtZSkpO1xuICAgIHBhcmVudC5yZW1vdmVJdGVtKHBhdGguYmFzZW5hbWUocGF0aG5hbWUpKTtcbiAgfSk7XG59O1xuXG5jb25zdCBQQVRIX0NIQVJTID1cbiAgJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVowMTIzNDU2Nzg5JztcblxuY29uc3QgTUFYX0FUVEVNUFRTID0gNjIgKiA2MiAqIDYyO1xuXG4vKipcbiAqIENyZWF0ZSBhIGRpcmVjdG9yeSBiYXNlZCBvbiBhIHRlbXBsYXRlLlxuICogU2VlIGh0dHA6Ly93ZWIubWl0LmVkdS9mcmVlYnNkL2hlYWQvbGliL2xpYmMvc3RkaW8vbWt0ZW1wLmNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZSBQYXRoIHRlbXBsYXRlICh0cmFpbGluZyBYcyB3aWxsIGJlIHJlcGxhY2VkKS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZyBUaGUgZW5jb2RpbmcgKCd1dGYtOCcgb3IgJ2J1ZmZlcicpLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvciwgc3RyaW5nKX0gY2FsbGJhY2sgT3B0aW9uYWwgY2FsbGJhY2suXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5ta2R0ZW1wID0gZnVuY3Rpb24ocHJlZml4LCBlbmNvZGluZywgY2FsbGJhY2ssIGN0eCkge1xuICBpZiAoZW5jb2RpbmcgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgIGNhbGxiYWNrID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSAndXRmLTgnO1xuICB9XG5cbiAgbWFya1N5c2NhbGwoY3R4LCAnbWtkdGVtcCcpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBwcmVmaXggPSBwcmVmaXgucmVwbGFjZSgvWHswLDZ9JC8sICdYWFhYWFgnKTtcbiAgICBjb25zdCBwYXJlbnRQYXRoID0gcGF0aC5kaXJuYW1lKHByZWZpeCk7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0ocGFyZW50UGF0aCk7XG4gICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9FTlQnLCBwcmVmaXgpO1xuICAgIH1cbiAgICBpZiAoIShwYXJlbnQgaW5zdGFuY2VvZiBEaXJlY3RvcnkpKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PVERJUicsIHByZWZpeCk7XG4gICAgfVxuICAgIHRoaXMuYWNjZXNzKHBhcmVudFBhdGgsIHBhcnNlSW50KCcwMDAyJywgOCkpO1xuICAgIGNvbnN0IHRlbXBsYXRlID0gcGF0aC5iYXNlbmFtZShwcmVmaXgpO1xuICAgIGxldCB1bmlxdWUgPSBmYWxzZTtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGxldCBuYW1lO1xuICAgIHdoaWxlICghdW5pcXVlICYmIGNvdW50IDwgTUFYX0FUVEVNUFRTKSB7XG4gICAgICBsZXQgcG9zaXRpb24gPSB0ZW1wbGF0ZS5sZW5ndGggLSAxO1xuICAgICAgbGV0IHJlcGxhY2VtZW50ID0gJyc7XG4gICAgICB3aGlsZSAodGVtcGxhdGUuY2hhckF0KHBvc2l0aW9uKSA9PT0gJ1gnKSB7XG4gICAgICAgIHJlcGxhY2VtZW50ICs9IFBBVEhfQ0hBUlMuY2hhckF0KFxuICAgICAgICAgIE1hdGguZmxvb3IoUEFUSF9DSEFSUy5sZW5ndGggKiBNYXRoLnJhbmRvbSgpKVxuICAgICAgICApO1xuICAgICAgICBwb3NpdGlvbiAtPSAxO1xuICAgICAgfVxuICAgICAgY29uc3QgY2FuZGlkYXRlID0gdGVtcGxhdGUuc2xpY2UoMCwgcG9zaXRpb24gKyAxKSArIHJlcGxhY2VtZW50O1xuICAgICAgaWYgKCFwYXJlbnQuZ2V0SXRlbShjYW5kaWRhdGUpKSB7XG4gICAgICAgIG5hbWUgPSBjYW5kaWRhdGU7XG4gICAgICAgIHVuaXF1ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFRVhJU1QnLCBwcmVmaXgpO1xuICAgIH1cbiAgICBjb25zdCBkaXIgPSBuZXcgRGlyZWN0b3J5KCk7XG4gICAgcGFyZW50LmFkZEl0ZW0obmFtZSwgZGlyKTtcbiAgICBsZXQgdW5pcXVlUGF0aCA9IHBhdGguam9pbihwYXJlbnRQYXRoLCBuYW1lKTtcbiAgICBpZiAoZW5jb2RpbmcgPT09ICdidWZmZXInKSB7XG4gICAgICB1bmlxdWVQYXRoID0gYnVmZmVyRnJvbSh1bmlxdWVQYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuaXF1ZVBhdGg7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBUcnVuY2F0ZSBhIGZpbGUuXG4gKiBAcGFyYW0ge251bWJlcn0gZmQgRmlsZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBOdW1iZXIgb2YgYnl0ZXMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2sgT3B0aW9uYWwgY2FsbGJhY2suXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5mdHJ1bmNhdGUgPSBmdW5jdGlvbihmZCwgbGVuLCBjYWxsYmFjaywgY3R4KSB7XG4gIG1hcmtTeXNjYWxsKGN0eCwgJ2Z0cnVuY2F0ZScpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gdGhpcy5nZXREZXNjcmlwdG9yQnlJZChmZCk7XG4gICAgaWYgKCFkZXNjcmlwdG9yLmlzV3JpdGUoKSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VJTlZBTCcpO1xuICAgIH1cbiAgICBjb25zdCBmaWxlID0gZGVzY3JpcHRvci5nZXRJdGVtKCk7XG4gICAgaWYgKCEoZmlsZSBpbnN0YW5jZW9mIEZpbGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUlOVkFMJyk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRlbnQgPSBmaWxlLmdldENvbnRlbnQoKTtcbiAgICBjb25zdCBuZXdDb250ZW50ID0gYnVmZmVyQWxsb2MobGVuKTtcbiAgICBjb250ZW50LmNvcHkobmV3Q29udGVudCk7XG4gICAgZmlsZS5zZXRDb250ZW50KG5ld0NvbnRlbnQpO1xuICB9KTtcbn07XG5cbi8qKlxuICogTGVnYWN5IHN1cHBvcnQuXG4gKiBAcGFyYW0ge251bWJlcn0gZmQgRmlsZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBOdW1iZXIgb2YgYnl0ZXMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2sgT3B0aW9uYWwgY2FsbGJhY2suXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS50cnVuY2F0ZSA9IEJpbmRpbmcucHJvdG90eXBlLmZ0cnVuY2F0ZTtcblxuLyoqXG4gKiBDaGFuZ2UgdXNlciBhbmQgZ3JvdXAgb3duZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aG5hbWUgUGF0aC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB1aWQgVXNlciBpZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBnaWQgR3JvdXAgaWQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2sgT3B0aW9uYWwgY2FsbGJhY2suXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5jaG93biA9IGZ1bmN0aW9uKHBhdGhuYW1lLCB1aWQsIGdpZCwgY2FsbGJhY2ssIGN0eCkge1xuICBtYXJrU3lzY2FsbChjdHgsICdjaG93bicpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBwYXRobmFtZSA9IGRlQnVmZmVyKHBhdGhuYW1lKTtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0ocGF0aG5hbWUpO1xuICAgIGlmICghaXRlbSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT0VOVCcsIHBhdGhuYW1lKTtcbiAgICB9XG4gICAgaXRlbS5zZXRVaWQodWlkKTtcbiAgICBpdGVtLnNldEdpZChnaWQpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQ2hhbmdlIHVzZXIgYW5kIGdyb3VwIG93bmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGZkIEZpbGUgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB1aWQgVXNlciBpZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBnaWQgR3JvdXAgaWQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2sgT3B0aW9uYWwgY2FsbGJhY2suXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5mY2hvd24gPSBmdW5jdGlvbihmZCwgdWlkLCBnaWQsIGNhbGxiYWNrLCBjdHgpIHtcbiAgbWFya1N5c2NhbGwoY3R4LCAnZmNob3duJyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sobm9ybWFsaXplQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB0aGlzLmdldERlc2NyaXB0b3JCeUlkKGZkKTtcbiAgICBjb25zdCBpdGVtID0gZGVzY3JpcHRvci5nZXRJdGVtKCk7XG4gICAgaXRlbS5zZXRVaWQodWlkKTtcbiAgICBpdGVtLnNldEdpZChnaWQpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQ2hhbmdlIHBlcm1pc3Npb25zLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhuYW1lIFBhdGguXG4gKiBAcGFyYW0ge251bWJlcn0gbW9kZSBNb2RlLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUuY2htb2QgPSBmdW5jdGlvbihwYXRobmFtZSwgbW9kZSwgY2FsbGJhY2ssIGN0eCkge1xuICBtYXJrU3lzY2FsbChjdHgsICdjaG1vZCcpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBwYXRobmFtZSA9IGRlQnVmZmVyKHBhdGhuYW1lKTtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0ocGF0aG5hbWUpO1xuICAgIGlmICghaXRlbSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT0VOVCcsIHBhdGhuYW1lKTtcbiAgICB9XG4gICAgaXRlbS5zZXRNb2RlKG1vZGUpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQ2hhbmdlIHBlcm1pc3Npb25zLlxuICogQHBhcmFtIHtudW1iZXJ9IGZkIEZpbGUgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtb2RlIE1vZGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2sgT3B0aW9uYWwgY2FsbGJhY2suXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5mY2htb2QgPSBmdW5jdGlvbihmZCwgbW9kZSwgY2FsbGJhY2ssIGN0eCkge1xuICBtYXJrU3lzY2FsbChjdHgsICdmY2htb2QnKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IHRoaXMuZ2V0RGVzY3JpcHRvckJ5SWQoZmQpO1xuICAgIGNvbnN0IGl0ZW0gPSBkZXNjcmlwdG9yLmdldEl0ZW0oKTtcbiAgICBpdGVtLnNldE1vZGUobW9kZSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBEZWxldGUgYSBuYW1lZCBpdGVtLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhuYW1lIFBhdGggdG8gaXRlbS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFjayBPcHRpb25hbCBjYWxsYmFjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLnVubGluayA9IGZ1bmN0aW9uKHBhdGhuYW1lLCBjYWxsYmFjaywgY3R4KSB7XG4gIG1hcmtTeXNjYWxsKGN0eCwgJ3VubGluaycpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBwYXRobmFtZSA9IGRlQnVmZmVyKHBhdGhuYW1lKTtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0ocGF0aG5hbWUpO1xuICAgIGlmICghaXRlbSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT0VOVCcsIHBhdGhuYW1lKTtcbiAgICB9XG4gICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBEaXJlY3RvcnkpIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFUEVSTScsIHBhdGhuYW1lKTtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0ocGF0aC5kaXJuYW1lKHBhdGhuYW1lKSk7XG4gICAgcGFyZW50LnJlbW92ZUl0ZW0ocGF0aC5iYXNlbmFtZShwYXRobmFtZSkpO1xuICB9KTtcbn07XG5cbi8qKlxuICogVXBkYXRlIHRpbWVzdGFtcHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aG5hbWUgUGF0aCB0byBpdGVtLlxuICogQHBhcmFtIHtudW1iZXJ9IGF0aW1lIEFjY2VzcyB0aW1lIChpbiBzZWNvbmRzKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtdGltZSBNb2RpZmljYXRpb24gdGltZSAoaW4gc2Vjb25kcykuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2sgT3B0aW9uYWwgY2FsbGJhY2suXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS51dGltZXMgPSBmdW5jdGlvbihwYXRobmFtZSwgYXRpbWUsIG10aW1lLCBjYWxsYmFjaywgY3R4KSB7XG4gIG1hcmtTeXNjYWxsKGN0eCwgJ3V0aW1lcycpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBwYXRobmFtZSA9IGRlQnVmZmVyKHBhdGhuYW1lKTtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0ocGF0aG5hbWUpO1xuICAgIGlmICghaXRlbSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VOT0VOVCcsIHBhdGhuYW1lKTtcbiAgICB9XG4gICAgaXRlbS5zZXRBVGltZShuZXcgRGF0ZShhdGltZSAqIDEwMDApKTtcbiAgICBpdGVtLnNldE1UaW1lKG5ldyBEYXRlKG10aW1lICogMTAwMCkpO1xuICB9KTtcbn07XG5cbi8qKlxuICogVXBkYXRlIHRpbWVzdGFtcHMuXG4gKiBAcGFyYW0ge251bWJlcn0gZmQgRmlsZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGF0aW1lIEFjY2VzcyB0aW1lIChpbiBzZWNvbmRzKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtdGltZSBNb2RpZmljYXRpb24gdGltZSAoaW4gc2Vjb25kcykuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2sgT3B0aW9uYWwgY2FsbGJhY2suXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5mdXRpbWVzID0gZnVuY3Rpb24oZmQsIGF0aW1lLCBtdGltZSwgY2FsbGJhY2ssIGN0eCkge1xuICBtYXJrU3lzY2FsbChjdHgsICdmdXRpbWVzJyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sobm9ybWFsaXplQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB0aGlzLmdldERlc2NyaXB0b3JCeUlkKGZkKTtcbiAgICBjb25zdCBpdGVtID0gZGVzY3JpcHRvci5nZXRJdGVtKCk7XG4gICAgaXRlbS5zZXRBVGltZShuZXcgRGF0ZShhdGltZSAqIDEwMDApKTtcbiAgICBpdGVtLnNldE1UaW1lKG5ldyBEYXRlKG10aW1lICogMTAwMCkpO1xuICB9KTtcbn07XG5cbi8qKlxuICogU3luY2hyb25pemUgaW4tY29yZSBzdGF0ZSB3aXRoIHN0b3JhZ2UgZGV2aWNlLlxuICogQHBhcmFtIHtudW1iZXJ9IGZkIEZpbGUgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFjayBPcHRpb25hbCBjYWxsYmFjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLmZzeW5jID0gZnVuY3Rpb24oZmQsIGNhbGxiYWNrLCBjdHgpIHtcbiAgbWFya1N5c2NhbGwoY3R4LCAnZnN5bmMnKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5nZXREZXNjcmlwdG9yQnlJZChmZCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBTeW5jaHJvbml6ZSBpbi1jb3JlIG1ldGFkYXRhIHN0YXRlIHdpdGggc3RvcmFnZSBkZXZpY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gZmQgRmlsZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihFcnJvcil9IGNhbGxiYWNrIE9wdGlvbmFsIGNhbGxiYWNrLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUuZmRhdGFzeW5jID0gZnVuY3Rpb24oZmQsIGNhbGxiYWNrLCBjdHgpIHtcbiAgbWFya1N5c2NhbGwoY3R4LCAnZmRhdGFzeW5jJyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sobm9ybWFsaXplQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZ2V0RGVzY3JpcHRvckJ5SWQoZmQpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgaGFyZCBsaW5rLlxuICogQHBhcmFtIHtzdHJpbmd9IHNyY1BhdGggVGhlIGV4aXN0aW5nIGZpbGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdFBhdGggVGhlIG5ldyBsaW5rIHRvIGNyZWF0ZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFjayBPcHRpb25hbCBjYWxsYmFjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLmxpbmsgPSBmdW5jdGlvbihzcmNQYXRoLCBkZXN0UGF0aCwgY2FsbGJhY2ssIGN0eCkge1xuICBtYXJrU3lzY2FsbChjdHgsICdsaW5rJyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sobm9ybWFsaXplQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIHNyY1BhdGggPSBkZUJ1ZmZlcihzcmNQYXRoKTtcbiAgICBkZXN0UGF0aCA9IGRlQnVmZmVyKGRlc3RQYXRoKTtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0oc3JjUGF0aCk7XG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PRU5UJywgc3JjUGF0aCk7XG4gICAgfVxuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRGlyZWN0b3J5KSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRVBFUk0nLCBzcmNQYXRoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N5c3RlbS5nZXRJdGVtKGRlc3RQYXRoKSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VFWElTVCcsIGRlc3RQYXRoKTtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0ocGF0aC5kaXJuYW1lKGRlc3RQYXRoKSk7XG4gICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9FTlQnLCBkZXN0UGF0aCk7XG4gICAgfVxuICAgIGlmICghKHBhcmVudCBpbnN0YW5jZW9mIERpcmVjdG9yeSkpIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9URElSJywgZGVzdFBhdGgpO1xuICAgIH1cbiAgICBwYXJlbnQuYWRkSXRlbShwYXRoLmJhc2VuYW1lKGRlc3RQYXRoKSwgaXRlbSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBzeW1ib2xpYyBsaW5rLlxuICogQHBhcmFtIHtzdHJpbmd9IHNyY1BhdGggUGF0aCBmcm9tIGxpbmsgdG8gdGhlIHNvdXJjZSBmaWxlLlxuICogQHBhcmFtIHtzdHJpbmd9IGRlc3RQYXRoIFBhdGggZm9yIHRoZSBnZW5lcmF0ZWQgbGluay5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIElnbm9yZWQgKHVzZWQgZm9yIFdpbmRvd3Mgb25seSkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yKX0gY2FsbGJhY2sgT3B0aW9uYWwgY2FsbGJhY2suXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5zeW1saW5rID0gZnVuY3Rpb24oc3JjUGF0aCwgZGVzdFBhdGgsIHR5cGUsIGNhbGxiYWNrLCBjdHgpIHtcbiAgbWFya1N5c2NhbGwoY3R4LCAnc3ltbGluaycpO1xuXG4gIHJldHVybiBtYXliZUNhbGxiYWNrKG5vcm1hbGl6ZUNhbGxiYWNrKGNhbGxiYWNrKSwgY3R4LCB0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBzcmNQYXRoID0gZGVCdWZmZXIoc3JjUGF0aCk7XG4gICAgZGVzdFBhdGggPSBkZUJ1ZmZlcihkZXN0UGF0aCk7XG4gICAgaWYgKHRoaXMuX3N5c3RlbS5nZXRJdGVtKGRlc3RQYXRoKSkge1xuICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VFWElTVCcsIGRlc3RQYXRoKTtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0ocGF0aC5kaXJuYW1lKGRlc3RQYXRoKSk7XG4gICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9FTlQnLCBkZXN0UGF0aCk7XG4gICAgfVxuICAgIGlmICghKHBhcmVudCBpbnN0YW5jZW9mIERpcmVjdG9yeSkpIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9URElSJywgZGVzdFBhdGgpO1xuICAgIH1cbiAgICBjb25zdCBsaW5rID0gbmV3IFN5bWJvbGljTGluaygpO1xuICAgIGxpbmsuc2V0UGF0aChzcmNQYXRoKTtcbiAgICBwYXJlbnQuYWRkSXRlbShwYXRoLmJhc2VuYW1lKGRlc3RQYXRoKSwgbGluayk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZWFkIHRoZSBjb250ZW50cyBvZiBhIHN5bWJvbGljIGxpbmsuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aG5hbWUgUGF0aCB0byBzeW1ib2xpYyBsaW5rLlxuICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nIFRoZSBlbmNvZGluZyAoJ3V0Zi04JyBvciAnYnVmZmVyJykuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEVycm9yLCAoc3RyaW5nfEJ1ZmZlcikpfSBjYWxsYmFjayBPcHRpb25hbCBjYWxsYmFjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggQ29udGV4dCBvYmplY3QgKG9wdGlvbmFsKSwgb25seSBmb3Igbm9kZWpzIHYxMCsuXG4gKiBAcmV0dXJuIHtzdHJpbmd8QnVmZmVyfSBTeW1ib2xpYyBsaW5rIGNvbnRlbnRzIChwYXRoIHRvIHNvdXJjZSkuXG4gKi9cbkJpbmRpbmcucHJvdG90eXBlLnJlYWRsaW5rID0gZnVuY3Rpb24ocGF0aG5hbWUsIGVuY29kaW5nLCBjYWxsYmFjaywgY3R4KSB7XG4gIGlmIChlbmNvZGluZyAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gdGhpcyB3b3VsZCBub3QgaGFwcGVuZCBpbiBub2RlanMgdjEwK1xuICAgIGNhbGxiYWNrID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSAndXRmLTgnO1xuICB9XG5cbiAgbWFya1N5c2NhbGwoY3R4LCAncmVhZGxpbmsnKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayhub3JtYWxpemVDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgcGF0aG5hbWUgPSBkZUJ1ZmZlcihwYXRobmFtZSk7XG4gICAgY29uc3QgbGluayA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKHBhdGhuYW1lKTtcbiAgICBpZiAoIWxpbmspIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9FTlQnLCBwYXRobmFtZSk7XG4gICAgfVxuICAgIGlmICghKGxpbmsgaW5zdGFuY2VvZiBTeW1ib2xpY0xpbmspKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUlOVkFMJywgcGF0aG5hbWUpO1xuICAgIH1cbiAgICBsZXQgbGlua1BhdGggPSBsaW5rLmdldFBhdGgoKTtcbiAgICBpZiAoZW5jb2RpbmcgPT09ICdidWZmZXInKSB7XG4gICAgICBsaW5rUGF0aCA9IGJ1ZmZlckZyb20obGlua1BhdGgpO1xuICAgIH1cbiAgICByZXR1cm4gbGlua1BhdGg7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBTdGF0IGFuIGl0ZW0uXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZXBhdGggUGF0aC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IsIFN0YXRzKXxGbG9hdDY0QXJyYXl8QmlnVWludDY0QXJyYXl9IGNhbGxiYWNrIENhbGxiYWNrIChvcHRpb25hbCkuIEluIE5vZGUgNy43LjArIHRoaXMgd2lsbCBiZSBhIEZsb2F0NjRBcnJheVxuICogdGhhdCBzaG91bGQgYmUgZmlsbGVkIHdpdGggc3RhdCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IENvbnRleHQgb2JqZWN0IChvcHRpb25hbCksIG9ubHkgZm9yIG5vZGVqcyB2MTArLlxuICogQHJldHVybiB7U3RhdHN8dW5kZWZpbmVkfSBTdGF0cyBvciB1bmRlZmluZWQgKGlmIHN5bmMpLlxuICovXG5CaW5kaW5nLnByb3RvdHlwZS5sc3RhdCA9IGZ1bmN0aW9uKGZpbGVwYXRoLCBvcHRpb25zLCBjYWxsYmFjaywgY3R4KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgIC8vIHRoaXMgd291bGQgbm90IGhhcHBlbmQgaW4gbm9kZWpzIHYxMCtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgbWFya1N5c2NhbGwoY3R4LCAnbHN0YXQnKTtcblxuICByZXR1cm4gbWF5YmVDYWxsYmFjayh3cmFwU3RhdHNDYWxsYmFjayhjYWxsYmFjayksIGN0eCwgdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgZmlsZXBhdGggPSBkZUJ1ZmZlcihmaWxlcGF0aCk7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX3N5c3RlbS5nZXRJdGVtKGZpbGVwYXRoKTtcbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFTk9FTlQnLCBmaWxlcGF0aCk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXRzID0gaXRlbS5nZXRTdGF0cygpO1xuXG4gICAgLy8gSW4gTm9kZSA3LjcuMCssIGJpbmRpbmcuc3RhdCBhY2NlcHRzIGEgRmxvYXQ2NEFycmF5IGFzIHRoZSBzZWNvbmQgYXJndW1lbnQsXG4gICAgLy8gd2hpY2ggc2hvdWxkIGJlIGZpbGxlZCB3aXRoIHN0YXQgdmFsdWVzLlxuICAgIC8vIEluIHByaW9yIHZlcnNpb25zIG9mIE5vZGUsIGJpbmRpbmcuc3RhdCBzaW1wbHkgcmV0dXJucyBhIFN0YXRzIGluc3RhbmNlLlxuICAgIGlmIChcbiAgICAgIGNhbGxiYWNrIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5IHx8XG4gICAgICBjYWxsYmFjayBpbnN0YW5jZW9mIEJpZ1VpbnQ2NEFycmF5XG4gICAgKSB7XG4gICAgICBmaWxsU3RhdHNBcnJheShzdGF0cywgY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaWxsU3RhdHNBcnJheShzdGF0cywgc3RhdFZhbHVlcyk7XG4gICAgICByZXR1cm4gbmV3IFN0YXRzKGl0ZW0uZ2V0U3RhdHMoKSk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogVGVzdHMgdXNlciBwZXJtaXNzaW9ucy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlcGF0aCBQYXRoLlxuICogQHBhcmFtIHtudW1iZXJ9IG1vZGUgTW9kZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRXJyb3IpfSBjYWxsYmFjayBDYWxsYmFjayAob3B0aW9uYWwpLlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBDb250ZXh0IG9iamVjdCAob3B0aW9uYWwpLCBvbmx5IGZvciBub2RlanMgdjEwKy5cbiAqL1xuQmluZGluZy5wcm90b3R5cGUuYWNjZXNzID0gZnVuY3Rpb24oZmlsZXBhdGgsIG1vZGUsIGNhbGxiYWNrLCBjdHgpIHtcbiAgbWFya1N5c2NhbGwoY3R4LCAnYWNjZXNzJyk7XG5cbiAgcmV0dXJuIG1heWJlQ2FsbGJhY2sobm9ybWFsaXplQ2FsbGJhY2soY2FsbGJhY2spLCBjdHgsIHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIGZpbGVwYXRoID0gZGVCdWZmZXIoZmlsZXBhdGgpO1xuICAgIGxldCBpdGVtID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0oZmlsZXBhdGgpO1xuICAgIGxldCBsaW5rcyA9IDA7XG4gICAgd2hpbGUgKGl0ZW0gaW5zdGFuY2VvZiBTeW1ib2xpY0xpbmspIHtcbiAgICAgIGlmIChsaW5rcyA+IE1BWF9MSU5LUykge1xuICAgICAgICB0aHJvdyBuZXcgRlNFcnJvcignRUxPT1AnLCBmaWxlcGF0aCk7XG4gICAgICB9XG4gICAgICBmaWxlcGF0aCA9IHBhdGgucmVzb2x2ZShwYXRoLmRpcm5hbWUoZmlsZXBhdGgpLCBpdGVtLmdldFBhdGgoKSk7XG4gICAgICBpdGVtID0gdGhpcy5fc3lzdGVtLmdldEl0ZW0oZmlsZXBhdGgpO1xuICAgICAgKytsaW5rcztcbiAgICB9XG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PRU5UJywgZmlsZXBhdGgpO1xuICAgIH1cbiAgICBpZiAobW9kZSAmJiBwcm9jZXNzLmdldHVpZCAmJiBwcm9jZXNzLmdldGdpZCkge1xuICAgICAgY29uc3QgaXRlbU1vZGUgPSBpdGVtLmdldE1vZGUoKTtcbiAgICAgIGlmIChpdGVtLmdldFVpZCgpID09PSBwcm9jZXNzLmdldHVpZCgpKSB7XG4gICAgICAgIGlmICgoaXRlbU1vZGUgJiAobW9kZSAqIDY0KSkgIT09IG1vZGUgKiA2NCkge1xuICAgICAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFQUNDRVMnLCBmaWxlcGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXRlbS5nZXRHaWQoKSA9PT0gcHJvY2Vzcy5nZXRnaWQoKSkge1xuICAgICAgICBpZiAoKGl0ZW1Nb2RlICYgKG1vZGUgKiA4KSkgIT09IG1vZGUgKiA4KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VBQ0NFUycsIGZpbGVwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKChpdGVtTW9kZSAmIG1vZGUpICE9PSBtb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTRXJyb3IoJ0VBQ0NFUycsIGZpbGVwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIE5vdCB5ZXQgaW1wbGVtZW50ZWQuXG4gKiBAdHlwZSB7ZnVuY3Rpb24oKX1cbiAqL1xuQmluZGluZy5wcm90b3R5cGUuU3RhdFdhdGNoZXIgPSBub3RJbXBsZW1lbnRlZDtcblxuLyoqXG4gKiBFeHBvcnQgdGhlIGJpbmRpbmcgY29uc3RydWN0b3IuXG4gKiBAdHlwZSB7ZnVuY3Rpb24oKX1cbiAqL1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gQmluZGluZztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/binding.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mock-fs/lib/buffer.js":
/*!********************************************!*\
  !*** ./node_modules/mock-fs/lib/buffer.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("exports.from =\n  Buffer.from ||\n  function(value, encoding) {\n    if (encoding) {\n      return new Buffer(value, encoding);\n    }\n    return new Buffer(value);\n  };\n\nexports.alloc =\n  Buffer.alloc ||\n  function(size) {\n    return new Buffer(size);\n  };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvYnVmZmVyLmpzIiwibWFwcGluZ3MiOiJBQUFBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcG9ydGtleS9uZXh0LWV4YW1wbGUvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvYnVmZmVyLmpzPzhlODEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cy5mcm9tID1cbiAgQnVmZmVyLmZyb20gfHxcbiAgZnVuY3Rpb24odmFsdWUsIGVuY29kaW5nKSB7XG4gICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSk7XG4gIH07XG5cbmV4cG9ydHMuYWxsb2MgPVxuICBCdWZmZXIuYWxsb2MgfHxcbiAgZnVuY3Rpb24oc2l6ZSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKHNpemUpO1xuICB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/buffer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mock-fs/lib/bypass.js":
/*!********************************************!*\
  !*** ./node_modules/mock-fs/lib/bypass.js ***!
  \********************************************/
/***/ ((module, exports) => {

eval("const realBinding = process.binding('fs');\nlet storedBinding;\n\n/**\n * Perform action, bypassing mock FS\n * @example\n * // This file exists on the real FS, not on the mocked FS\n * const filePath = '/path/file.json';\n * const data = mock.bypass(() => fs.readFileSync(filePath, 'utf-8'));\n */\nexports = module.exports = function bypass(fn) {\n  if (typeof fn !== 'function') {\n    throw new Error(`Must provide a function to perform for mock.bypass()`);\n  }\n\n  disable();\n\n  let result;\n  try {\n    result = fn();\n  } finally {\n    if (result && typeof result.then === 'function') {\n      result.then(\n        r => {\n          enable();\n          return r;\n        },\n        err => {\n          enable();\n          throw err;\n        }\n      );\n    } else {\n      enable();\n    }\n  }\n\n  return result;\n};\n\n/**\n * Temporarily disable Mocked FS\n */\nfunction disable() {\n  if (realBinding._mockedBinding) {\n    storedBinding = realBinding._mockedBinding;\n    delete realBinding._mockedBinding;\n  }\n}\n\n/**\n * Enables Mocked FS after being disabled by disable()\n */\nfunction enable() {\n  if (storedBinding) {\n    realBinding._mockedBinding = storedBinding;\n    storedBinding = undefined;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvYnlwYXNzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcG9ydGtleS9uZXh0LWV4YW1wbGUvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvYnlwYXNzLmpzPzc0MjQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcmVhbEJpbmRpbmcgPSBwcm9jZXNzLmJpbmRpbmcoJ2ZzJyk7XG5sZXQgc3RvcmVkQmluZGluZztcblxuLyoqXG4gKiBQZXJmb3JtIGFjdGlvbiwgYnlwYXNzaW5nIG1vY2sgRlNcbiAqIEBleGFtcGxlXG4gKiAvLyBUaGlzIGZpbGUgZXhpc3RzIG9uIHRoZSByZWFsIEZTLCBub3Qgb24gdGhlIG1vY2tlZCBGU1xuICogY29uc3QgZmlsZVBhdGggPSAnL3BhdGgvZmlsZS5qc29uJztcbiAqIGNvbnN0IGRhdGEgPSBtb2NrLmJ5cGFzcygoKSA9PiBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsICd1dGYtOCcpKTtcbiAqL1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnlwYXNzKGZuKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE11c3QgcHJvdmlkZSBhIGZ1bmN0aW9uIHRvIHBlcmZvcm0gZm9yIG1vY2suYnlwYXNzKClgKTtcbiAgfVxuXG4gIGRpc2FibGUoKTtcblxuICBsZXQgcmVzdWx0O1xuICB0cnkge1xuICAgIHJlc3VsdCA9IGZuKCk7XG4gIH0gZmluYWxseSB7XG4gICAgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlc3VsdC50aGVuKFxuICAgICAgICByID0+IHtcbiAgICAgICAgICBlbmFibGUoKTtcbiAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyID0+IHtcbiAgICAgICAgICBlbmFibGUoKTtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuYWJsZSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFRlbXBvcmFyaWx5IGRpc2FibGUgTW9ja2VkIEZTXG4gKi9cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGlmIChyZWFsQmluZGluZy5fbW9ja2VkQmluZGluZykge1xuICAgIHN0b3JlZEJpbmRpbmcgPSByZWFsQmluZGluZy5fbW9ja2VkQmluZGluZztcbiAgICBkZWxldGUgcmVhbEJpbmRpbmcuX21vY2tlZEJpbmRpbmc7XG4gIH1cbn1cblxuLyoqXG4gKiBFbmFibGVzIE1vY2tlZCBGUyBhZnRlciBiZWluZyBkaXNhYmxlZCBieSBkaXNhYmxlKClcbiAqL1xuZnVuY3Rpb24gZW5hYmxlKCkge1xuICBpZiAoc3RvcmVkQmluZGluZykge1xuICAgIHJlYWxCaW5kaW5nLl9tb2NrZWRCaW5kaW5nID0gc3RvcmVkQmluZGluZztcbiAgICBzdG9yZWRCaW5kaW5nID0gdW5kZWZpbmVkO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/bypass.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mock-fs/lib/descriptor.js":
/*!************************************************!*\
  !*** ./node_modules/mock-fs/lib/descriptor.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst constants = __webpack_require__(/*! constants */ \"constants\");\n\n/**\n * Create a new file descriptor.\n * @param {number} flags Flags.\n * @constructor\n */\nfunction FileDescriptor(flags) {\n  /**\n   * Flags.\n   * @type {number}\n   */\n  this._flags = flags;\n\n  /**\n   * File system item.\n   * @type {Item}\n   */\n  this._item = null;\n\n  /**\n   * Current file position.\n   * @type {number}\n   */\n  this._position = 0;\n}\n\n/**\n * Set the item.\n * @param {Item} item File system item.\n */\nFileDescriptor.prototype.setItem = function(item) {\n  this._item = item;\n};\n\n/**\n * Get the item.\n * @return {Item} File system item.\n */\nFileDescriptor.prototype.getItem = function() {\n  return this._item;\n};\n\n/**\n * Get the current file position.\n * @return {number} File position.\n */\nFileDescriptor.prototype.getPosition = function() {\n  return this._position;\n};\n\n/**\n * Set the current file position.\n * @param {number} position File position.\n */\nFileDescriptor.prototype.setPosition = function(position) {\n  this._position = position;\n};\n\n/**\n * Check if file opened for appending.\n * @return {boolean} Opened for appending.\n */\nFileDescriptor.prototype.isAppend = function() {\n  return (this._flags & constants.O_APPEND) === constants.O_APPEND;\n};\n\n/**\n * Check if file opened for creation.\n * @return {boolean} Opened for creation.\n */\nFileDescriptor.prototype.isCreate = function() {\n  return (this._flags & constants.O_CREAT) === constants.O_CREAT;\n};\n\n/**\n * Check if file opened for reading.\n * @return {boolean} Opened for reading.\n */\nFileDescriptor.prototype.isRead = function() {\n  return (this._flags & constants.O_WRONLY) !== constants.O_WRONLY;\n};\n\n/**\n * Check if file opened for writing.\n * @return {boolean} Opened for writing.\n */\nFileDescriptor.prototype.isWrite = function() {\n  return (\n    (this._flags & constants.O_WRONLY) === constants.O_WRONLY ||\n    (this._flags & constants.O_RDWR) === constants.O_RDWR\n  );\n};\n\n/**\n * Check if file opened for truncating.\n * @return {boolean} Opened for truncating.\n */\nFileDescriptor.prototype.isTruncate = function() {\n  return (this._flags & constants.O_TRUNC) === constants.O_TRUNC;\n};\n\n/**\n * Check if file opened with exclusive flag.\n * @return {boolean} Opened with exclusive.\n */\nFileDescriptor.prototype.isExclusive = function() {\n  return (this._flags & constants.O_EXCL) === constants.O_EXCL;\n};\n\n/**\n * Export the constructor.\n * @type {function()}\n */\nexports = module.exports = FileDescriptor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvZGVzY3JpcHRvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixrQkFBa0IsbUJBQU8sQ0FBQyw0QkFBVzs7QUFFckM7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHBvcnRrZXkvbmV4dC1leGFtcGxlLy4vbm9kZV9tb2R1bGVzL21vY2stZnMvbGliL2Rlc2NyaXB0b3IuanM/NDJmMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJ2NvbnN0YW50cycpO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBmaWxlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZmxhZ3MgRmxhZ3MuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gRmlsZURlc2NyaXB0b3IoZmxhZ3MpIHtcbiAgLyoqXG4gICAqIEZsYWdzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5fZmxhZ3MgPSBmbGFncztcblxuICAvKipcbiAgICogRmlsZSBzeXN0ZW0gaXRlbS5cbiAgICogQHR5cGUge0l0ZW19XG4gICAqL1xuICB0aGlzLl9pdGVtID0gbnVsbDtcblxuICAvKipcbiAgICogQ3VycmVudCBmaWxlIHBvc2l0aW9uLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5fcG9zaXRpb24gPSAwO1xufVxuXG4vKipcbiAqIFNldCB0aGUgaXRlbS5cbiAqIEBwYXJhbSB7SXRlbX0gaXRlbSBGaWxlIHN5c3RlbSBpdGVtLlxuICovXG5GaWxlRGVzY3JpcHRvci5wcm90b3R5cGUuc2V0SXRlbSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgdGhpcy5faXRlbSA9IGl0ZW07XG59O1xuXG4vKipcbiAqIEdldCB0aGUgaXRlbS5cbiAqIEByZXR1cm4ge0l0ZW19IEZpbGUgc3lzdGVtIGl0ZW0uXG4gKi9cbkZpbGVEZXNjcmlwdG9yLnByb3RvdHlwZS5nZXRJdGVtID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9pdGVtO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgZmlsZSBwb3NpdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn0gRmlsZSBwb3NpdGlvbi5cbiAqL1xuRmlsZURlc2NyaXB0b3IucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9wb3NpdGlvbjtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjdXJyZW50IGZpbGUgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gRmlsZSBwb3NpdGlvbi5cbiAqL1xuRmlsZURlc2NyaXB0b3IucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgdGhpcy5fcG9zaXRpb24gPSBwb3NpdGlvbjtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgZmlsZSBvcGVuZWQgZm9yIGFwcGVuZGluZy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IE9wZW5lZCBmb3IgYXBwZW5kaW5nLlxuICovXG5GaWxlRGVzY3JpcHRvci5wcm90b3R5cGUuaXNBcHBlbmQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICh0aGlzLl9mbGFncyAmIGNvbnN0YW50cy5PX0FQUEVORCkgPT09IGNvbnN0YW50cy5PX0FQUEVORDtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgZmlsZSBvcGVuZWQgZm9yIGNyZWF0aW9uLlxuICogQHJldHVybiB7Ym9vbGVhbn0gT3BlbmVkIGZvciBjcmVhdGlvbi5cbiAqL1xuRmlsZURlc2NyaXB0b3IucHJvdG90eXBlLmlzQ3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAodGhpcy5fZmxhZ3MgJiBjb25zdGFudHMuT19DUkVBVCkgPT09IGNvbnN0YW50cy5PX0NSRUFUO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBmaWxlIG9wZW5lZCBmb3IgcmVhZGluZy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IE9wZW5lZCBmb3IgcmVhZGluZy5cbiAqL1xuRmlsZURlc2NyaXB0b3IucHJvdG90eXBlLmlzUmVhZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKHRoaXMuX2ZsYWdzICYgY29uc3RhbnRzLk9fV1JPTkxZKSAhPT0gY29uc3RhbnRzLk9fV1JPTkxZO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBmaWxlIG9wZW5lZCBmb3Igd3JpdGluZy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IE9wZW5lZCBmb3Igd3JpdGluZy5cbiAqL1xuRmlsZURlc2NyaXB0b3IucHJvdG90eXBlLmlzV3JpdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChcbiAgICAodGhpcy5fZmxhZ3MgJiBjb25zdGFudHMuT19XUk9OTFkpID09PSBjb25zdGFudHMuT19XUk9OTFkgfHxcbiAgICAodGhpcy5fZmxhZ3MgJiBjb25zdGFudHMuT19SRFdSKSA9PT0gY29uc3RhbnRzLk9fUkRXUlxuICApO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBmaWxlIG9wZW5lZCBmb3IgdHJ1bmNhdGluZy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IE9wZW5lZCBmb3IgdHJ1bmNhdGluZy5cbiAqL1xuRmlsZURlc2NyaXB0b3IucHJvdG90eXBlLmlzVHJ1bmNhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICh0aGlzLl9mbGFncyAmIGNvbnN0YW50cy5PX1RSVU5DKSA9PT0gY29uc3RhbnRzLk9fVFJVTkM7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGZpbGUgb3BlbmVkIHdpdGggZXhjbHVzaXZlIGZsYWcuXG4gKiBAcmV0dXJuIHtib29sZWFufSBPcGVuZWQgd2l0aCBleGNsdXNpdmUuXG4gKi9cbkZpbGVEZXNjcmlwdG9yLnByb3RvdHlwZS5pc0V4Y2x1c2l2ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKHRoaXMuX2ZsYWdzICYgY29uc3RhbnRzLk9fRVhDTCkgPT09IGNvbnN0YW50cy5PX0VYQ0w7XG59O1xuXG4vKipcbiAqIEV4cG9ydCB0aGUgY29uc3RydWN0b3IuXG4gKiBAdHlwZSB7ZnVuY3Rpb24oKX1cbiAqL1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gRmlsZURlc2NyaXB0b3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/descriptor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mock-fs/lib/directory.js":
/*!***********************************************!*\
  !*** ./node_modules/mock-fs/lib/directory.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst util = __webpack_require__(/*! util */ \"util\");\n\nconst Item = __webpack_require__(/*! ./item */ \"(ssr)/./node_modules/mock-fs/lib/item.js\");\n\nconst constants = __webpack_require__(/*! constants */ \"constants\");\n\n/**\n * A directory.\n * @constructor\n */\nfunction Directory() {\n  Item.call(this);\n\n  /**\n   * Items in this directory.\n   * @type {Object.<string, Item>}\n   */\n  this._items = {};\n\n  /**\n   * Permissions.\n   */\n  this._mode = 511; // 0777\n}\nutil.inherits(Directory, Item);\n\n/**\n * Add an item to the directory.\n * @param {string} name The name to give the item.\n * @param {Item} item The item to add.\n * @return {Item} The added item.\n */\nDirectory.prototype.addItem = function(name, item) {\n  if (this._items.hasOwnProperty(name)) {\n    throw new Error('Item with the same name already exists: ' + name);\n  }\n  this._items[name] = item;\n  ++item.links;\n  if (item instanceof Directory) {\n    // for '.' entry\n    ++item.links;\n    // for subdirectory\n    ++this.links;\n  }\n  this.setMTime(new Date());\n  return item;\n};\n\n/**\n * Get a named item.\n * @param {string} name Item name.\n * @return {Item} The named item (or null if none).\n */\nDirectory.prototype.getItem = function(name) {\n  let item = null;\n  if (this._items.hasOwnProperty(name)) {\n    item = this._items[name];\n  }\n  return item;\n};\n\n/**\n * Remove an item.\n * @param {string} name Name of item to remove.\n * @return {Item} The orphan item.\n */\nDirectory.prototype.removeItem = function(name) {\n  if (!this._items.hasOwnProperty(name)) {\n    throw new Error('Item does not exist in directory: ' + name);\n  }\n  const item = this._items[name];\n  delete this._items[name];\n  --item.links;\n  if (item instanceof Directory) {\n    // for '.' entry\n    --item.links;\n    // for subdirectory\n    --this.links;\n  }\n  this.setMTime(new Date());\n  return item;\n};\n\n/**\n * Get list of item names in this directory.\n * @return {Array.<string>} Item names.\n */\nDirectory.prototype.list = function() {\n  return Object.keys(this._items).sort();\n};\n\n/**\n * Get directory stats.\n * @return {Object} Stats properties.\n */\nDirectory.prototype.getStats = function() {\n  const stats = Item.prototype.getStats.call(this);\n  stats.mode = this.getMode() | constants.S_IFDIR;\n  stats.size = 1;\n  stats.blocks = 1;\n  return stats;\n};\n\n/**\n * Export the constructor.\n * @type {function()}\n */\nexports = module.exports = Directory;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvZGlyZWN0b3J5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFM0IsYUFBYSxtQkFBTyxDQUFDLHdEQUFROztBQUU3QixrQkFBa0IsbUJBQU8sQ0FBQyw0QkFBVzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsTUFBTTtBQUNqQixZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHBvcnRrZXkvbmV4dC1leGFtcGxlLy4vbm9kZV9tb2R1bGVzL21vY2stZnMvbGliL2RpcmVjdG9yeS5qcz8zY2YyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuY29uc3QgSXRlbSA9IHJlcXVpcmUoJy4vaXRlbScpO1xuXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCdjb25zdGFudHMnKTtcblxuLyoqXG4gKiBBIGRpcmVjdG9yeS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBEaXJlY3RvcnkoKSB7XG4gIEl0ZW0uY2FsbCh0aGlzKTtcblxuICAvKipcbiAgICogSXRlbXMgaW4gdGhpcyBkaXJlY3RvcnkuXG4gICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgSXRlbT59XG4gICAqL1xuICB0aGlzLl9pdGVtcyA9IHt9O1xuXG4gIC8qKlxuICAgKiBQZXJtaXNzaW9ucy5cbiAgICovXG4gIHRoaXMuX21vZGUgPSA1MTE7IC8vIDA3Nzdcbn1cbnV0aWwuaW5oZXJpdHMoRGlyZWN0b3J5LCBJdGVtKTtcblxuLyoqXG4gKiBBZGQgYW4gaXRlbSB0byB0aGUgZGlyZWN0b3J5LlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgdG8gZ2l2ZSB0aGUgaXRlbS5cbiAqIEBwYXJhbSB7SXRlbX0gaXRlbSBUaGUgaXRlbSB0byBhZGQuXG4gKiBAcmV0dXJuIHtJdGVtfSBUaGUgYWRkZWQgaXRlbS5cbiAqL1xuRGlyZWN0b3J5LnByb3RvdHlwZS5hZGRJdGVtID0gZnVuY3Rpb24obmFtZSwgaXRlbSkge1xuICBpZiAodGhpcy5faXRlbXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0l0ZW0gd2l0aCB0aGUgc2FtZSBuYW1lIGFscmVhZHkgZXhpc3RzOiAnICsgbmFtZSk7XG4gIH1cbiAgdGhpcy5faXRlbXNbbmFtZV0gPSBpdGVtO1xuICArK2l0ZW0ubGlua3M7XG4gIGlmIChpdGVtIGluc3RhbmNlb2YgRGlyZWN0b3J5KSB7XG4gICAgLy8gZm9yICcuJyBlbnRyeVxuICAgICsraXRlbS5saW5rcztcbiAgICAvLyBmb3Igc3ViZGlyZWN0b3J5XG4gICAgKyt0aGlzLmxpbmtzO1xuICB9XG4gIHRoaXMuc2V0TVRpbWUobmV3IERhdGUoKSk7XG4gIHJldHVybiBpdGVtO1xufTtcblxuLyoqXG4gKiBHZXQgYSBuYW1lZCBpdGVtLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgSXRlbSBuYW1lLlxuICogQHJldHVybiB7SXRlbX0gVGhlIG5hbWVkIGl0ZW0gKG9yIG51bGwgaWYgbm9uZSkuXG4gKi9cbkRpcmVjdG9yeS5wcm90b3R5cGUuZ2V0SXRlbSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgbGV0IGl0ZW0gPSBudWxsO1xuICBpZiAodGhpcy5faXRlbXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICBpdGVtID0gdGhpcy5faXRlbXNbbmFtZV07XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiBpdGVtIHRvIHJlbW92ZS5cbiAqIEByZXR1cm4ge0l0ZW19IFRoZSBvcnBoYW4gaXRlbS5cbiAqL1xuRGlyZWN0b3J5LnByb3RvdHlwZS5yZW1vdmVJdGVtID0gZnVuY3Rpb24obmFtZSkge1xuICBpZiAoIXRoaXMuX2l0ZW1zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJdGVtIGRvZXMgbm90IGV4aXN0IGluIGRpcmVjdG9yeTogJyArIG5hbWUpO1xuICB9XG4gIGNvbnN0IGl0ZW0gPSB0aGlzLl9pdGVtc1tuYW1lXTtcbiAgZGVsZXRlIHRoaXMuX2l0ZW1zW25hbWVdO1xuICAtLWl0ZW0ubGlua3M7XG4gIGlmIChpdGVtIGluc3RhbmNlb2YgRGlyZWN0b3J5KSB7XG4gICAgLy8gZm9yICcuJyBlbnRyeVxuICAgIC0taXRlbS5saW5rcztcbiAgICAvLyBmb3Igc3ViZGlyZWN0b3J5XG4gICAgLS10aGlzLmxpbmtzO1xuICB9XG4gIHRoaXMuc2V0TVRpbWUobmV3IERhdGUoKSk7XG4gIHJldHVybiBpdGVtO1xufTtcblxuLyoqXG4gKiBHZXQgbGlzdCBvZiBpdGVtIG5hbWVzIGluIHRoaXMgZGlyZWN0b3J5LlxuICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IEl0ZW0gbmFtZXMuXG4gKi9cbkRpcmVjdG9yeS5wcm90b3R5cGUubGlzdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5faXRlbXMpLnNvcnQoKTtcbn07XG5cbi8qKlxuICogR2V0IGRpcmVjdG9yeSBzdGF0cy5cbiAqIEByZXR1cm4ge09iamVjdH0gU3RhdHMgcHJvcGVydGllcy5cbiAqL1xuRGlyZWN0b3J5LnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBzdGF0cyA9IEl0ZW0ucHJvdG90eXBlLmdldFN0YXRzLmNhbGwodGhpcyk7XG4gIHN0YXRzLm1vZGUgPSB0aGlzLmdldE1vZGUoKSB8IGNvbnN0YW50cy5TX0lGRElSO1xuICBzdGF0cy5zaXplID0gMTtcbiAgc3RhdHMuYmxvY2tzID0gMTtcbiAgcmV0dXJuIHN0YXRzO1xufTtcblxuLyoqXG4gKiBFeHBvcnQgdGhlIGNvbnN0cnVjdG9yLlxuICogQHR5cGUge2Z1bmN0aW9uKCl9XG4gKi9cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IERpcmVjdG9yeTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/directory.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mock-fs/lib/error.js":
/*!*******************************************!*\
  !*** ./node_modules/mock-fs/lib/error.js ***!
  \*******************************************/
/***/ ((module, exports) => {

"use strict";
eval("\n\nconst uvBinding = process.binding('uv');\n/**\n * Error codes from libuv.\n * @enum {number}\n */\nconst codes = {};\n\nif (uvBinding.errmap) {\n  // nodejs v8+\n  uvBinding.errmap.forEach(function(value, errno) {\n    const code = value[0];\n    const message = value[1];\n    codes[code] = {errno: errno, message: message};\n  });\n} else {\n  // nodejs v4 and v6\n  Object.keys(uvBinding).forEach(function(key) {\n    if (key.startsWith('UV_')) {\n      const code = key.slice(3);\n      const errno = uvBinding[key];\n      codes[code] = {errno: errno, message: key};\n    }\n  });\n}\n\n/**\n * Create an error.\n * @param {string} code Error code.\n * @param {string} path Path (optional).\n * @constructor\n */\nfunction FSError(code, path) {\n  if (!codes.hasOwnProperty(code)) {\n    throw new Error('Programmer error, invalid error code: ' + code);\n  }\n  Error.call(this);\n  const details = codes[code];\n  let message = code + ', ' + details.message;\n  if (path) {\n    message += \" '\" + path + \"'\";\n  }\n  this.message = message;\n  this.code = code;\n  this.errno = details.errno;\n  if (path !== undefined) {\n    this.path = path;\n  }\n  Error.captureStackTrace(this, FSError);\n}\nFSError.prototype = new Error();\nFSError.codes = codes;\n\n/**\n * Error constructor.\n */\nexports = module.exports = FSError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcG9ydGtleS9uZXh0LWV4YW1wbGUvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvZXJyb3IuanM/ZGU5MiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHV2QmluZGluZyA9IHByb2Nlc3MuYmluZGluZygndXYnKTtcbi8qKlxuICogRXJyb3IgY29kZXMgZnJvbSBsaWJ1di5cbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmNvbnN0IGNvZGVzID0ge307XG5cbmlmICh1dkJpbmRpbmcuZXJybWFwKSB7XG4gIC8vIG5vZGVqcyB2OCtcbiAgdXZCaW5kaW5nLmVycm1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBlcnJubykge1xuICAgIGNvbnN0IGNvZGUgPSB2YWx1ZVswXTtcbiAgICBjb25zdCBtZXNzYWdlID0gdmFsdWVbMV07XG4gICAgY29kZXNbY29kZV0gPSB7ZXJybm86IGVycm5vLCBtZXNzYWdlOiBtZXNzYWdlfTtcbiAgfSk7XG59IGVsc2Uge1xuICAvLyBub2RlanMgdjQgYW5kIHY2XG4gIE9iamVjdC5rZXlzKHV2QmluZGluZykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoJ1VWXycpKSB7XG4gICAgICBjb25zdCBjb2RlID0ga2V5LnNsaWNlKDMpO1xuICAgICAgY29uc3QgZXJybm8gPSB1dkJpbmRpbmdba2V5XTtcbiAgICAgIGNvZGVzW2NvZGVdID0ge2Vycm5vOiBlcnJubywgbWVzc2FnZToga2V5fTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBlcnJvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIEVycm9yIGNvZGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIChvcHRpb25hbCkuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gRlNFcnJvcihjb2RlLCBwYXRoKSB7XG4gIGlmICghY29kZXMuaGFzT3duUHJvcGVydHkoY29kZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2dyYW1tZXIgZXJyb3IsIGludmFsaWQgZXJyb3IgY29kZTogJyArIGNvZGUpO1xuICB9XG4gIEVycm9yLmNhbGwodGhpcyk7XG4gIGNvbnN0IGRldGFpbHMgPSBjb2Rlc1tjb2RlXTtcbiAgbGV0IG1lc3NhZ2UgPSBjb2RlICsgJywgJyArIGRldGFpbHMubWVzc2FnZTtcbiAgaWYgKHBhdGgpIHtcbiAgICBtZXNzYWdlICs9IFwiICdcIiArIHBhdGggKyBcIidcIjtcbiAgfVxuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLmNvZGUgPSBjb2RlO1xuICB0aGlzLmVycm5vID0gZGV0YWlscy5lcnJubztcbiAgaWYgKHBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gIH1cbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgRlNFcnJvcik7XG59XG5GU0Vycm9yLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuRlNFcnJvci5jb2RlcyA9IGNvZGVzO1xuXG4vKipcbiAqIEVycm9yIGNvbnN0cnVjdG9yLlxuICovXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBGU0Vycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/error.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mock-fs/lib/file.js":
/*!******************************************!*\
  !*** ./node_modules/mock-fs/lib/file.js ***!
  \******************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst util = __webpack_require__(/*! util */ \"util\");\n\nconst Item = __webpack_require__(/*! ./item */ \"(ssr)/./node_modules/mock-fs/lib/item.js\");\nconst bufferFrom = (__webpack_require__(/*! ./buffer */ \"(ssr)/./node_modules/mock-fs/lib/buffer.js\").from);\nconst bufferAlloc = (__webpack_require__(/*! ./buffer */ \"(ssr)/./node_modules/mock-fs/lib/buffer.js\").alloc);\n\nconst EMPTY = bufferAlloc(0);\nconst constants = __webpack_require__(/*! constants */ \"constants\");\n\n/**\n * A file.\n * @constructor\n */\nfunction File() {\n  Item.call(this);\n\n  /**\n   * File content.\n   * @type {Buffer}\n   */\n  this._content = EMPTY;\n}\nutil.inherits(File, Item);\n\n/**\n * Get the file contents.\n * @return {Buffer} File contents.\n */\nFile.prototype.getContent = function() {\n  this.setATime(new Date());\n  return this._content;\n};\n\n/**\n * Set the file contents.\n * @param {string|Buffer} content File contents.\n */\nFile.prototype.setContent = function(content) {\n  if (typeof content === 'string') {\n    content = bufferFrom(content);\n  } else if (!Buffer.isBuffer(content)) {\n    throw new Error('File content must be a string or buffer');\n  }\n  this._content = content;\n  const now = Date.now();\n  this.setCTime(new Date(now));\n  this.setMTime(new Date(now));\n};\n\n/**\n * Get file stats.\n * @return {Object} Stats properties.\n */\nFile.prototype.getStats = function() {\n  const size = this._content.length;\n  const stats = Item.prototype.getStats.call(this);\n  stats.mode = this.getMode() | constants.S_IFREG;\n  stats.size = size;\n  stats.blocks = Math.ceil(size / 512);\n  return stats;\n};\n\n/**\n * Export the constructor.\n * @type {function()}\n */\nexports = module.exports = File;\n\n/**\n * Standard input.\n * @constructor\n */\nfunction StandardInput() {\n  File.call(this);\n  this.setMode(438); // 0666\n}\nutil.inherits(StandardInput, File);\n\nexports.StandardInput = StandardInput;\n\n/**\n * Standard output.\n * @constructor\n */\nfunction StandardOutput() {\n  File.call(this);\n  this.setMode(438); // 0666\n}\nutil.inherits(StandardOutput, File);\n\n/**\n * Write the contents to stdout.\n * @param {string|Buffer} content File contents.\n */\nStandardOutput.prototype.setContent = function(content) {\n  if (process.stdout.isTTY) {\n    process.stdout.write(content);\n  }\n};\n\nexports.StandardOutput = StandardOutput;\n\n/**\n * Standard error.\n * @constructor\n */\nfunction StandardError() {\n  File.call(this);\n  this.setMode(438); // 0666\n}\nutil.inherits(StandardError, File);\n\n/**\n * Write the contents to stderr.\n * @param {string|Buffer} content File contents.\n */\nStandardError.prototype.setContent = function(content) {\n  if (process.stderr.isTTY) {\n    process.stderr.write(content);\n  }\n};\n\nexports.StandardError = StandardError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvZmlsZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCLGFBQWEsbUJBQU8sQ0FBQyx3REFBUTtBQUM3QixtQkFBbUIsd0ZBQXdCO0FBQzNDLG9CQUFvQix5RkFBeUI7O0FBRTdDO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsNEJBQVc7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHBvcnRrZXkvbmV4dC1leGFtcGxlLy4vbm9kZV9tb2R1bGVzL21vY2stZnMvbGliL2ZpbGUuanM/YzRiOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmNvbnN0IEl0ZW0gPSByZXF1aXJlKCcuL2l0ZW0nKTtcbmNvbnN0IGJ1ZmZlckZyb20gPSByZXF1aXJlKCcuL2J1ZmZlcicpLmZyb207XG5jb25zdCBidWZmZXJBbGxvYyA9IHJlcXVpcmUoJy4vYnVmZmVyJykuYWxsb2M7XG5cbmNvbnN0IEVNUFRZID0gYnVmZmVyQWxsb2MoMCk7XG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCdjb25zdGFudHMnKTtcblxuLyoqXG4gKiBBIGZpbGUuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gRmlsZSgpIHtcbiAgSXRlbS5jYWxsKHRoaXMpO1xuXG4gIC8qKlxuICAgKiBGaWxlIGNvbnRlbnQuXG4gICAqIEB0eXBlIHtCdWZmZXJ9XG4gICAqL1xuICB0aGlzLl9jb250ZW50ID0gRU1QVFk7XG59XG51dGlsLmluaGVyaXRzKEZpbGUsIEl0ZW0pO1xuXG4vKipcbiAqIEdldCB0aGUgZmlsZSBjb250ZW50cy5cbiAqIEByZXR1cm4ge0J1ZmZlcn0gRmlsZSBjb250ZW50cy5cbiAqL1xuRmlsZS5wcm90b3R5cGUuZ2V0Q29udGVudCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNldEFUaW1lKG5ldyBEYXRlKCkpO1xuICByZXR1cm4gdGhpcy5fY29udGVudDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBmaWxlIGNvbnRlbnRzLlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSBjb250ZW50IEZpbGUgY29udGVudHMuXG4gKi9cbkZpbGUucHJvdG90eXBlLnNldENvbnRlbnQgPSBmdW5jdGlvbihjb250ZW50KSB7XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBjb250ZW50ID0gYnVmZmVyRnJvbShjb250ZW50KTtcbiAgfSBlbHNlIGlmICghQnVmZmVyLmlzQnVmZmVyKGNvbnRlbnQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGaWxlIGNvbnRlbnQgbXVzdCBiZSBhIHN0cmluZyBvciBidWZmZXInKTtcbiAgfVxuICB0aGlzLl9jb250ZW50ID0gY29udGVudDtcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgdGhpcy5zZXRDVGltZShuZXcgRGF0ZShub3cpKTtcbiAgdGhpcy5zZXRNVGltZShuZXcgRGF0ZShub3cpKTtcbn07XG5cbi8qKlxuICogR2V0IGZpbGUgc3RhdHMuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFN0YXRzIHByb3BlcnRpZXMuXG4gKi9cbkZpbGUucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IHNpemUgPSB0aGlzLl9jb250ZW50Lmxlbmd0aDtcbiAgY29uc3Qgc3RhdHMgPSBJdGVtLnByb3RvdHlwZS5nZXRTdGF0cy5jYWxsKHRoaXMpO1xuICBzdGF0cy5tb2RlID0gdGhpcy5nZXRNb2RlKCkgfCBjb25zdGFudHMuU19JRlJFRztcbiAgc3RhdHMuc2l6ZSA9IHNpemU7XG4gIHN0YXRzLmJsb2NrcyA9IE1hdGguY2VpbChzaXplIC8gNTEyKTtcbiAgcmV0dXJuIHN0YXRzO1xufTtcblxuLyoqXG4gKiBFeHBvcnQgdGhlIGNvbnN0cnVjdG9yLlxuICogQHR5cGUge2Z1bmN0aW9uKCl9XG4gKi9cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEZpbGU7XG5cbi8qKlxuICogU3RhbmRhcmQgaW5wdXQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gU3RhbmRhcmRJbnB1dCgpIHtcbiAgRmlsZS5jYWxsKHRoaXMpO1xuICB0aGlzLnNldE1vZGUoNDM4KTsgLy8gMDY2NlxufVxudXRpbC5pbmhlcml0cyhTdGFuZGFyZElucHV0LCBGaWxlKTtcblxuZXhwb3J0cy5TdGFuZGFyZElucHV0ID0gU3RhbmRhcmRJbnB1dDtcblxuLyoqXG4gKiBTdGFuZGFyZCBvdXRwdXQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gU3RhbmRhcmRPdXRwdXQoKSB7XG4gIEZpbGUuY2FsbCh0aGlzKTtcbiAgdGhpcy5zZXRNb2RlKDQzOCk7IC8vIDA2NjZcbn1cbnV0aWwuaW5oZXJpdHMoU3RhbmRhcmRPdXRwdXQsIEZpbGUpO1xuXG4vKipcbiAqIFdyaXRlIHRoZSBjb250ZW50cyB0byBzdGRvdXQuXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ9IGNvbnRlbnQgRmlsZSBjb250ZW50cy5cbiAqL1xuU3RhbmRhcmRPdXRwdXQucHJvdG90eXBlLnNldENvbnRlbnQgPSBmdW5jdGlvbihjb250ZW50KSB7XG4gIGlmIChwcm9jZXNzLnN0ZG91dC5pc1RUWSkge1xuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGNvbnRlbnQpO1xuICB9XG59O1xuXG5leHBvcnRzLlN0YW5kYXJkT3V0cHV0ID0gU3RhbmRhcmRPdXRwdXQ7XG5cbi8qKlxuICogU3RhbmRhcmQgZXJyb3IuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gU3RhbmRhcmRFcnJvcigpIHtcbiAgRmlsZS5jYWxsKHRoaXMpO1xuICB0aGlzLnNldE1vZGUoNDM4KTsgLy8gMDY2NlxufVxudXRpbC5pbmhlcml0cyhTdGFuZGFyZEVycm9yLCBGaWxlKTtcblxuLyoqXG4gKiBXcml0ZSB0aGUgY29udGVudHMgdG8gc3RkZXJyLlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSBjb250ZW50IEZpbGUgY29udGVudHMuXG4gKi9cblN0YW5kYXJkRXJyb3IucHJvdG90eXBlLnNldENvbnRlbnQgPSBmdW5jdGlvbihjb250ZW50KSB7XG4gIGlmIChwcm9jZXNzLnN0ZGVyci5pc1RUWSkge1xuICAgIHByb2Nlc3Muc3RkZXJyLndyaXRlKGNvbnRlbnQpO1xuICB9XG59O1xuXG5leHBvcnRzLlN0YW5kYXJkRXJyb3IgPSBTdGFuZGFyZEVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/file.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mock-fs/lib/filesystem.js":
/*!************************************************!*\
  !*** ./node_modules/mock-fs/lib/filesystem.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst os = __webpack_require__(/*! os */ \"os\");\nconst path = __webpack_require__(/*! path */ \"path\");\n\nconst Directory = __webpack_require__(/*! ./directory */ \"(ssr)/./node_modules/mock-fs/lib/directory.js\");\nconst File = __webpack_require__(/*! ./file */ \"(ssr)/./node_modules/mock-fs/lib/file.js\");\nconst FSError = __webpack_require__(/*! ./error */ \"(ssr)/./node_modules/mock-fs/lib/error.js\");\nconst SymbolicLink = __webpack_require__(/*! ./symlink */ \"(ssr)/./node_modules/mock-fs/lib/symlink.js\");\n\nconst isWindows = process.platform === 'win32';\n\nfunction toNamespacedPath(filePath) {\n  return path.toNamespacedPath\n    ? path.toNamespacedPath(filePath)\n    : path._makeLong(filePath);\n}\n\nfunction getPathParts(filepath) {\n  const parts = toNamespacedPath(path.resolve(filepath)).split(path.sep);\n  parts.shift();\n  if (isWindows) {\n    // parts currently looks like ['', '?', 'c:', ...]\n    parts.shift();\n    const q = parts.shift(); // should be '?'\n    const base = '\\\\\\\\' + q + '\\\\' + parts.shift().toLowerCase();\n    parts.unshift(base);\n  }\n  if (parts[parts.length - 1] === '') {\n    parts.pop();\n  }\n  return parts;\n}\n\n/**\n * Create a new file system.\n * @param {Object} options Any filesystem options.\n * @param {boolean} options.createCwd Create a directory for `process.cwd()`\n *     (defaults to `true`).\n * @param {boolean} options.createTmp Create a directory for `os.tmpdir()`\n *     (defaults to `true`).\n * @constructor\n */\nfunction FileSystem(options) {\n  options = options || {};\n\n  const createCwd = 'createCwd' in options ? options.createCwd : true;\n  const createTmp = 'createTmp' in options ? options.createTmp : true;\n\n  const root = new Directory();\n\n  // populate with default directories\n  const defaults = [];\n  if (createCwd) {\n    defaults.push(process.cwd());\n  }\n\n  if (createTmp) {\n    defaults.push((os.tmpdir && os.tmpdir()) || os.tmpDir());\n  }\n\n  defaults.forEach(function(dir) {\n    const parts = getPathParts(dir);\n    let directory = root;\n    for (let i = 0, ii = parts.length; i < ii; ++i) {\n      const name = parts[i];\n      const candidate = directory.getItem(name);\n      if (!candidate) {\n        directory = directory.addItem(name, new Directory());\n      } else if (candidate instanceof Directory) {\n        directory = candidate;\n      } else {\n        throw new Error('Failed to create directory: ' + dir);\n      }\n    }\n  });\n\n  /**\n   * Root directory.\n   * @type {Directory}\n   */\n  this._root = root;\n}\n\n/**\n * Get the root directory.\n * @return {Directory} The root directory.\n */\nFileSystem.prototype.getRoot = function() {\n  return this._root;\n};\n\n/**\n * Get a file system item.\n * @param {string} filepath Path to item.\n * @return {Item} The item (or null if not found).\n */\nFileSystem.prototype.getItem = function(filepath) {\n  const parts = getPathParts(filepath);\n  const currentParts = getPathParts(process.cwd());\n  let item = this._root;\n  let itemPath = '/';\n  for (let i = 0, ii = parts.length; i < ii; ++i) {\n    const name = parts[i];\n    while (item instanceof SymbolicLink) {\n      // Symbolic link being traversed as a directory --- If link targets\n      // another symbolic link, resolve target's path relative to the original\n      // link's target, otherwise relative to the current item.\n      itemPath = path.resolve(path.dirname(itemPath), item.getPath());\n      item = this.getItem(itemPath);\n    }\n    if (item) {\n      if (item instanceof Directory && name !== currentParts[i]) {\n        // make sure traversal is allowed\n        // This fails for Windows directories which do not have execute permission, by default. It may be a good idea\n        // to change this logic to windows-friendly. See notes in mock.createDirectoryInfoFromPaths()\n        if (!item.canExecute()) {\n          throw new FSError('EACCES', filepath);\n        }\n      }\n      if (item instanceof File) {\n        throw new FSError('ENOTDIR', filepath);\n      }\n      item = item.getItem(name);\n    }\n    if (!item) {\n      break;\n    }\n    itemPath = path.resolve(itemPath, name);\n  }\n  return item;\n};\n\n/**\n * Populate a directory with an item.\n * @param {Directory} directory The directory to populate.\n * @param {string} name The name of the item.\n * @param {string|Buffer|function|Object} obj Instructions for creating the\n *     item.\n */\nfunction populate(directory, name, obj) {\n  let item;\n  if (typeof obj === 'string' || Buffer.isBuffer(obj)) {\n    // contents for a file\n    item = new File();\n    item.setContent(obj);\n  } else if (typeof obj === 'function') {\n    // item factory\n    item = obj();\n  } else if (typeof obj === 'object') {\n    // directory with more to populate\n    item = new Directory();\n    for (const key in obj) {\n      populate(item, key, obj[key]);\n    }\n  } else {\n    throw new Error('Unsupported type: ' + typeof obj + ' of item ' + name);\n  }\n\n  /**\n   * Special exception for redundant adding of empty directories.\n   */\n  if (\n    item instanceof Directory &&\n    item.list().length === 0 &&\n    directory.getItem(name) instanceof Directory\n  ) {\n    // pass\n  } else {\n    directory.addItem(name, item);\n  }\n}\n\n/**\n * Configure a mock file system.\n * @param {Object} paths Config object.\n * @param {Object} options Any filesystem options.\n * @param {boolean} options.createCwd Create a directory for `process.cwd()`\n *     (defaults to `true`).\n * @param {boolean} options.createTmp Create a directory for `os.tmpdir()`\n *     (defaults to `true`).\n * @return {FileSystem} Mock file system.\n */\nFileSystem.create = function(paths, options) {\n  const system = new FileSystem(options);\n\n  for (const filepath in paths) {\n    const parts = getPathParts(filepath);\n    let directory = system._root;\n    for (let i = 0, ii = parts.length - 1; i < ii; ++i) {\n      const name = parts[i];\n      const candidate = directory.getItem(name);\n      if (!candidate) {\n        directory = directory.addItem(name, new Directory());\n      } else if (candidate instanceof Directory) {\n        directory = candidate;\n      } else {\n        throw new Error('Failed to create directory: ' + filepath);\n      }\n    }\n    populate(directory, parts[parts.length - 1], paths[filepath]);\n  }\n\n  return system;\n};\n\n/**\n * Generate a factory for new files.\n * @param {Object} config File config.\n * @return {function():File} Factory that creates a new file.\n */\nFileSystem.file = function(config) {\n  config = config || {};\n  return function() {\n    const file = new File();\n    if (config.hasOwnProperty('content')) {\n      file.setContent(config.content);\n    }\n    if (config.hasOwnProperty('mode')) {\n      file.setMode(config.mode);\n    } else {\n      file.setMode(438); // 0666\n    }\n    if (config.hasOwnProperty('uid')) {\n      file.setUid(config.uid);\n    }\n    if (config.hasOwnProperty('gid')) {\n      file.setGid(config.gid);\n    }\n    if (config.hasOwnProperty('atime')) {\n      file.setATime(config.atime);\n    }\n    if (config.hasOwnProperty('ctime')) {\n      file.setCTime(config.ctime);\n    }\n    if (config.hasOwnProperty('mtime')) {\n      file.setMTime(config.mtime);\n    }\n    if (config.hasOwnProperty('birthtime')) {\n      file.setBirthtime(config.birthtime);\n    }\n    return file;\n  };\n};\n\n/**\n * Generate a factory for new symbolic links.\n * @param {Object} config File config.\n * @return {function():File} Factory that creates a new symbolic link.\n */\nFileSystem.symlink = function(config) {\n  config = config || {};\n  return function() {\n    const link = new SymbolicLink();\n    if (config.hasOwnProperty('mode')) {\n      link.setMode(config.mode);\n    } else {\n      link.setMode(438); // 0666\n    }\n    if (config.hasOwnProperty('uid')) {\n      link.setUid(config.uid);\n    }\n    if (config.hasOwnProperty('gid')) {\n      link.setGid(config.gid);\n    }\n    if (config.hasOwnProperty('path')) {\n      link.setPath(config.path);\n    } else {\n      throw new Error('Missing \"path\" property');\n    }\n    if (config.hasOwnProperty('atime')) {\n      link.setATime(config.atime);\n    }\n    if (config.hasOwnProperty('ctime')) {\n      link.setCTime(config.ctime);\n    }\n    if (config.hasOwnProperty('mtime')) {\n      link.setMTime(config.mtime);\n    }\n    if (config.hasOwnProperty('birthtime')) {\n      link.setBirthtime(config.birthtime);\n    }\n    return link;\n  };\n};\n\n/**\n * Generate a factory for new directories.\n * @param {Object} config File config.\n * @return {function():Directory} Factory that creates a new directory.\n */\nFileSystem.directory = function(config) {\n  config = config || {};\n  return function() {\n    const dir = new Directory();\n    if (config.hasOwnProperty('mode')) {\n      dir.setMode(config.mode);\n    }\n    if (config.hasOwnProperty('uid')) {\n      dir.setUid(config.uid);\n    }\n    if (config.hasOwnProperty('gid')) {\n      dir.setGid(config.gid);\n    }\n    if (config.hasOwnProperty('items')) {\n      for (const name in config.items) {\n        populate(dir, name, config.items[name]);\n      }\n    }\n    if (config.hasOwnProperty('atime')) {\n      dir.setATime(config.atime);\n    }\n    if (config.hasOwnProperty('ctime')) {\n      dir.setCTime(config.ctime);\n    }\n    if (config.hasOwnProperty('mtime')) {\n      dir.setMTime(config.mtime);\n    }\n    if (config.hasOwnProperty('birthtime')) {\n      dir.setBirthtime(config.birthtime);\n    }\n    return dir;\n  };\n};\n\n/**\n * Module exports.\n * @type {function}\n */\nexports = module.exports = FileSystem;\nexports.getPathParts = getPathParts;\nexports.toNamespacedPath = toNamespacedPath;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvZmlsZXN5c3RlbS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCLGtCQUFrQixtQkFBTyxDQUFDLGtFQUFhO0FBQ3ZDLGFBQWEsbUJBQU8sQ0FBQyx3REFBUTtBQUM3QixnQkFBZ0IsbUJBQU8sQ0FBQywwREFBUztBQUNqQyxxQkFBcUIsbUJBQU8sQ0FBQyw4REFBVzs7QUFFeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLFFBQVE7QUFDbkIsV0FBVywrQkFBK0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04seUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04seUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLHdCQUF3QiIsInNvdXJjZXMiOlsid2VicGFjazovL0Bwb3J0a2V5L25leHQtZXhhbXBsZS8uL25vZGVfbW9kdWxlcy9tb2NrLWZzL2xpYi9maWxlc3lzdGVtLmpzP2M3YWMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG5jb25zdCBEaXJlY3RvcnkgPSByZXF1aXJlKCcuL2RpcmVjdG9yeScpO1xuY29uc3QgRmlsZSA9IHJlcXVpcmUoJy4vZmlsZScpO1xuY29uc3QgRlNFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3InKTtcbmNvbnN0IFN5bWJvbGljTGluayA9IHJlcXVpcmUoJy4vc3ltbGluaycpO1xuXG5jb25zdCBpc1dpbmRvd3MgPSBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInO1xuXG5mdW5jdGlvbiB0b05hbWVzcGFjZWRQYXRoKGZpbGVQYXRoKSB7XG4gIHJldHVybiBwYXRoLnRvTmFtZXNwYWNlZFBhdGhcbiAgICA/IHBhdGgudG9OYW1lc3BhY2VkUGF0aChmaWxlUGF0aClcbiAgICA6IHBhdGguX21ha2VMb25nKGZpbGVQYXRoKTtcbn1cblxuZnVuY3Rpb24gZ2V0UGF0aFBhcnRzKGZpbGVwYXRoKSB7XG4gIGNvbnN0IHBhcnRzID0gdG9OYW1lc3BhY2VkUGF0aChwYXRoLnJlc29sdmUoZmlsZXBhdGgpKS5zcGxpdChwYXRoLnNlcCk7XG4gIHBhcnRzLnNoaWZ0KCk7XG4gIGlmIChpc1dpbmRvd3MpIHtcbiAgICAvLyBwYXJ0cyBjdXJyZW50bHkgbG9va3MgbGlrZSBbJycsICc/JywgJ2M6JywgLi4uXVxuICAgIHBhcnRzLnNoaWZ0KCk7XG4gICAgY29uc3QgcSA9IHBhcnRzLnNoaWZ0KCk7IC8vIHNob3VsZCBiZSAnPydcbiAgICBjb25zdCBiYXNlID0gJ1xcXFxcXFxcJyArIHEgKyAnXFxcXCcgKyBwYXJ0cy5zaGlmdCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgcGFydHMudW5zaGlmdChiYXNlKTtcbiAgfVxuICBpZiAocGFydHNbcGFydHMubGVuZ3RoIC0gMV0gPT09ICcnKSB7XG4gICAgcGFydHMucG9wKCk7XG4gIH1cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBmaWxlIHN5c3RlbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFueSBmaWxlc3lzdGVtIG9wdGlvbnMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuY3JlYXRlQ3dkIENyZWF0ZSBhIGRpcmVjdG9yeSBmb3IgYHByb2Nlc3MuY3dkKClgXG4gKiAgICAgKGRlZmF1bHRzIHRvIGB0cnVlYCkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuY3JlYXRlVG1wIENyZWF0ZSBhIGRpcmVjdG9yeSBmb3IgYG9zLnRtcGRpcigpYFxuICogICAgIChkZWZhdWx0cyB0byBgdHJ1ZWApLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEZpbGVTeXN0ZW0ob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBjb25zdCBjcmVhdGVDd2QgPSAnY3JlYXRlQ3dkJyBpbiBvcHRpb25zID8gb3B0aW9ucy5jcmVhdGVDd2QgOiB0cnVlO1xuICBjb25zdCBjcmVhdGVUbXAgPSAnY3JlYXRlVG1wJyBpbiBvcHRpb25zID8gb3B0aW9ucy5jcmVhdGVUbXAgOiB0cnVlO1xuXG4gIGNvbnN0IHJvb3QgPSBuZXcgRGlyZWN0b3J5KCk7XG5cbiAgLy8gcG9wdWxhdGUgd2l0aCBkZWZhdWx0IGRpcmVjdG9yaWVzXG4gIGNvbnN0IGRlZmF1bHRzID0gW107XG4gIGlmIChjcmVhdGVDd2QpIHtcbiAgICBkZWZhdWx0cy5wdXNoKHByb2Nlc3MuY3dkKCkpO1xuICB9XG5cbiAgaWYgKGNyZWF0ZVRtcCkge1xuICAgIGRlZmF1bHRzLnB1c2goKG9zLnRtcGRpciAmJiBvcy50bXBkaXIoKSkgfHwgb3MudG1wRGlyKCkpO1xuICB9XG5cbiAgZGVmYXVsdHMuZm9yRWFjaChmdW5jdGlvbihkaXIpIHtcbiAgICBjb25zdCBwYXJ0cyA9IGdldFBhdGhQYXJ0cyhkaXIpO1xuICAgIGxldCBkaXJlY3RvcnkgPSByb290O1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBhcnRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBwYXJ0c1tpXTtcbiAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IGRpcmVjdG9yeS5nZXRJdGVtKG5hbWUpO1xuICAgICAgaWYgKCFjYW5kaWRhdGUpIHtcbiAgICAgICAgZGlyZWN0b3J5ID0gZGlyZWN0b3J5LmFkZEl0ZW0obmFtZSwgbmV3IERpcmVjdG9yeSgpKTtcbiAgICAgIH0gZWxzZSBpZiAoY2FuZGlkYXRlIGluc3RhbmNlb2YgRGlyZWN0b3J5KSB7XG4gICAgICAgIGRpcmVjdG9yeSA9IGNhbmRpZGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBkaXJlY3Rvcnk6ICcgKyBkaXIpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJvb3QgZGlyZWN0b3J5LlxuICAgKiBAdHlwZSB7RGlyZWN0b3J5fVxuICAgKi9cbiAgdGhpcy5fcm9vdCA9IHJvb3Q7XG59XG5cbi8qKlxuICogR2V0IHRoZSByb290IGRpcmVjdG9yeS5cbiAqIEByZXR1cm4ge0RpcmVjdG9yeX0gVGhlIHJvb3QgZGlyZWN0b3J5LlxuICovXG5GaWxlU3lzdGVtLnByb3RvdHlwZS5nZXRSb290ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9yb290O1xufTtcblxuLyoqXG4gKiBHZXQgYSBmaWxlIHN5c3RlbSBpdGVtLlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVwYXRoIFBhdGggdG8gaXRlbS5cbiAqIEByZXR1cm4ge0l0ZW19IFRoZSBpdGVtIChvciBudWxsIGlmIG5vdCBmb3VuZCkuXG4gKi9cbkZpbGVTeXN0ZW0ucHJvdG90eXBlLmdldEl0ZW0gPSBmdW5jdGlvbihmaWxlcGF0aCkge1xuICBjb25zdCBwYXJ0cyA9IGdldFBhdGhQYXJ0cyhmaWxlcGF0aCk7XG4gIGNvbnN0IGN1cnJlbnRQYXJ0cyA9IGdldFBhdGhQYXJ0cyhwcm9jZXNzLmN3ZCgpKTtcbiAgbGV0IGl0ZW0gPSB0aGlzLl9yb290O1xuICBsZXQgaXRlbVBhdGggPSAnLyc7XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IHBhcnRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICBjb25zdCBuYW1lID0gcGFydHNbaV07XG4gICAgd2hpbGUgKGl0ZW0gaW5zdGFuY2VvZiBTeW1ib2xpY0xpbmspIHtcbiAgICAgIC8vIFN5bWJvbGljIGxpbmsgYmVpbmcgdHJhdmVyc2VkIGFzIGEgZGlyZWN0b3J5IC0tLSBJZiBsaW5rIHRhcmdldHNcbiAgICAgIC8vIGFub3RoZXIgc3ltYm9saWMgbGluaywgcmVzb2x2ZSB0YXJnZXQncyBwYXRoIHJlbGF0aXZlIHRvIHRoZSBvcmlnaW5hbFxuICAgICAgLy8gbGluaydzIHRhcmdldCwgb3RoZXJ3aXNlIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IGl0ZW0uXG4gICAgICBpdGVtUGF0aCA9IHBhdGgucmVzb2x2ZShwYXRoLmRpcm5hbWUoaXRlbVBhdGgpLCBpdGVtLmdldFBhdGgoKSk7XG4gICAgICBpdGVtID0gdGhpcy5nZXRJdGVtKGl0ZW1QYXRoKTtcbiAgICB9XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRGlyZWN0b3J5ICYmIG5hbWUgIT09IGN1cnJlbnRQYXJ0c1tpXSkge1xuICAgICAgICAvLyBtYWtlIHN1cmUgdHJhdmVyc2FsIGlzIGFsbG93ZWRcbiAgICAgICAgLy8gVGhpcyBmYWlscyBmb3IgV2luZG93cyBkaXJlY3RvcmllcyB3aGljaCBkbyBub3QgaGF2ZSBleGVjdXRlIHBlcm1pc3Npb24sIGJ5IGRlZmF1bHQuIEl0IG1heSBiZSBhIGdvb2QgaWRlYVxuICAgICAgICAvLyB0byBjaGFuZ2UgdGhpcyBsb2dpYyB0byB3aW5kb3dzLWZyaWVuZGx5LiBTZWUgbm90ZXMgaW4gbW9jay5jcmVhdGVEaXJlY3RvcnlJbmZvRnJvbVBhdGhzKClcbiAgICAgICAgaWYgKCFpdGVtLmNhbkV4ZWN1dGUoKSkge1xuICAgICAgICAgIHRocm93IG5ldyBGU0Vycm9yKCdFQUNDRVMnLCBmaWxlcGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PVERJUicsIGZpbGVwYXRoKTtcbiAgICAgIH1cbiAgICAgIGl0ZW0gPSBpdGVtLmdldEl0ZW0obmFtZSk7XG4gICAgfVxuICAgIGlmICghaXRlbSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGl0ZW1QYXRoID0gcGF0aC5yZXNvbHZlKGl0ZW1QYXRoLCBuYW1lKTtcbiAgfVxuICByZXR1cm4gaXRlbTtcbn07XG5cbi8qKlxuICogUG9wdWxhdGUgYSBkaXJlY3Rvcnkgd2l0aCBhbiBpdGVtLlxuICogQHBhcmFtIHtEaXJlY3Rvcnl9IGRpcmVjdG9yeSBUaGUgZGlyZWN0b3J5IHRvIHBvcHVsYXRlLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGl0ZW0uXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8ZnVuY3Rpb258T2JqZWN0fSBvYmogSW5zdHJ1Y3Rpb25zIGZvciBjcmVhdGluZyB0aGVcbiAqICAgICBpdGVtLlxuICovXG5mdW5jdGlvbiBwb3B1bGF0ZShkaXJlY3RvcnksIG5hbWUsIG9iaikge1xuICBsZXQgaXRlbTtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnIHx8IEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgLy8gY29udGVudHMgZm9yIGEgZmlsZVxuICAgIGl0ZW0gPSBuZXcgRmlsZSgpO1xuICAgIGl0ZW0uc2V0Q29udGVudChvYmopO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBpdGVtIGZhY3RvcnlcbiAgICBpdGVtID0gb2JqKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyBkaXJlY3Rvcnkgd2l0aCBtb3JlIHRvIHBvcHVsYXRlXG4gICAgaXRlbSA9IG5ldyBEaXJlY3RvcnkoKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgIHBvcHVsYXRlKGl0ZW0sIGtleSwgb2JqW2tleV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHR5cGU6ICcgKyB0eXBlb2Ygb2JqICsgJyBvZiBpdGVtICcgKyBuYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGVjaWFsIGV4Y2VwdGlvbiBmb3IgcmVkdW5kYW50IGFkZGluZyBvZiBlbXB0eSBkaXJlY3Rvcmllcy5cbiAgICovXG4gIGlmIChcbiAgICBpdGVtIGluc3RhbmNlb2YgRGlyZWN0b3J5ICYmXG4gICAgaXRlbS5saXN0KCkubGVuZ3RoID09PSAwICYmXG4gICAgZGlyZWN0b3J5LmdldEl0ZW0obmFtZSkgaW5zdGFuY2VvZiBEaXJlY3RvcnlcbiAgKSB7XG4gICAgLy8gcGFzc1xuICB9IGVsc2Uge1xuICAgIGRpcmVjdG9yeS5hZGRJdGVtKG5hbWUsIGl0ZW0pO1xuICB9XG59XG5cbi8qKlxuICogQ29uZmlndXJlIGEgbW9jayBmaWxlIHN5c3RlbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXRocyBDb25maWcgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQW55IGZpbGVzeXN0ZW0gb3B0aW9ucy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5jcmVhdGVDd2QgQ3JlYXRlIGEgZGlyZWN0b3J5IGZvciBgcHJvY2Vzcy5jd2QoKWBcbiAqICAgICAoZGVmYXVsdHMgdG8gYHRydWVgKS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5jcmVhdGVUbXAgQ3JlYXRlIGEgZGlyZWN0b3J5IGZvciBgb3MudG1wZGlyKClgXG4gKiAgICAgKGRlZmF1bHRzIHRvIGB0cnVlYCkuXG4gKiBAcmV0dXJuIHtGaWxlU3lzdGVtfSBNb2NrIGZpbGUgc3lzdGVtLlxuICovXG5GaWxlU3lzdGVtLmNyZWF0ZSA9IGZ1bmN0aW9uKHBhdGhzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHN5c3RlbSA9IG5ldyBGaWxlU3lzdGVtKG9wdGlvbnMpO1xuXG4gIGZvciAoY29uc3QgZmlsZXBhdGggaW4gcGF0aHMpIHtcbiAgICBjb25zdCBwYXJ0cyA9IGdldFBhdGhQYXJ0cyhmaWxlcGF0aCk7XG4gICAgbGV0IGRpcmVjdG9yeSA9IHN5c3RlbS5fcm9vdDtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpIDwgaWk7ICsraSkge1xuICAgICAgY29uc3QgbmFtZSA9IHBhcnRzW2ldO1xuICAgICAgY29uc3QgY2FuZGlkYXRlID0gZGlyZWN0b3J5LmdldEl0ZW0obmFtZSk7XG4gICAgICBpZiAoIWNhbmRpZGF0ZSkge1xuICAgICAgICBkaXJlY3RvcnkgPSBkaXJlY3RvcnkuYWRkSXRlbShuYW1lLCBuZXcgRGlyZWN0b3J5KCkpO1xuICAgICAgfSBlbHNlIGlmIChjYW5kaWRhdGUgaW5zdGFuY2VvZiBEaXJlY3RvcnkpIHtcbiAgICAgICAgZGlyZWN0b3J5ID0gY2FuZGlkYXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIGRpcmVjdG9yeTogJyArIGZpbGVwYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcG9wdWxhdGUoZGlyZWN0b3J5LCBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSwgcGF0aHNbZmlsZXBhdGhdKTtcbiAgfVxuXG4gIHJldHVybiBzeXN0ZW07XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgZmFjdG9yeSBmb3IgbmV3IGZpbGVzLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBGaWxlIGNvbmZpZy5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKCk6RmlsZX0gRmFjdG9yeSB0aGF0IGNyZWF0ZXMgYSBuZXcgZmlsZS5cbiAqL1xuRmlsZVN5c3RlbS5maWxlID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IGZpbGUgPSBuZXcgRmlsZSgpO1xuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoJ2NvbnRlbnQnKSkge1xuICAgICAgZmlsZS5zZXRDb250ZW50KGNvbmZpZy5jb250ZW50KTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgnbW9kZScpKSB7XG4gICAgICBmaWxlLnNldE1vZGUoY29uZmlnLm1vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaWxlLnNldE1vZGUoNDM4KTsgLy8gMDY2NlxuICAgIH1cbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCd1aWQnKSkge1xuICAgICAgZmlsZS5zZXRVaWQoY29uZmlnLnVpZCk7XG4gICAgfVxuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoJ2dpZCcpKSB7XG4gICAgICBmaWxlLnNldEdpZChjb25maWcuZ2lkKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgnYXRpbWUnKSkge1xuICAgICAgZmlsZS5zZXRBVGltZShjb25maWcuYXRpbWUpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCdjdGltZScpKSB7XG4gICAgICBmaWxlLnNldENUaW1lKGNvbmZpZy5jdGltZSk7XG4gICAgfVxuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoJ210aW1lJykpIHtcbiAgICAgIGZpbGUuc2V0TVRpbWUoY29uZmlnLm10aW1lKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgnYmlydGh0aW1lJykpIHtcbiAgICAgIGZpbGUuc2V0QmlydGh0aW1lKGNvbmZpZy5iaXJ0aHRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gZmlsZTtcbiAgfTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBmYWN0b3J5IGZvciBuZXcgc3ltYm9saWMgbGlua3MuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIEZpbGUgY29uZmlnLlxuICogQHJldHVybiB7ZnVuY3Rpb24oKTpGaWxlfSBGYWN0b3J5IHRoYXQgY3JlYXRlcyBhIG5ldyBzeW1ib2xpYyBsaW5rLlxuICovXG5GaWxlU3lzdGVtLnN5bWxpbmsgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgbGluayA9IG5ldyBTeW1ib2xpY0xpbmsoKTtcbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCdtb2RlJykpIHtcbiAgICAgIGxpbmsuc2V0TW9kZShjb25maWcubW9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmsuc2V0TW9kZSg0MzgpOyAvLyAwNjY2XG4gICAgfVxuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoJ3VpZCcpKSB7XG4gICAgICBsaW5rLnNldFVpZChjb25maWcudWlkKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgnZ2lkJykpIHtcbiAgICAgIGxpbmsuc2V0R2lkKGNvbmZpZy5naWQpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCdwYXRoJykpIHtcbiAgICAgIGxpbmsuc2V0UGF0aChjb25maWcucGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBcInBhdGhcIiBwcm9wZXJ0eScpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCdhdGltZScpKSB7XG4gICAgICBsaW5rLnNldEFUaW1lKGNvbmZpZy5hdGltZSk7XG4gICAgfVxuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoJ2N0aW1lJykpIHtcbiAgICAgIGxpbmsuc2V0Q1RpbWUoY29uZmlnLmN0aW1lKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgnbXRpbWUnKSkge1xuICAgICAgbGluay5zZXRNVGltZShjb25maWcubXRpbWUpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCdiaXJ0aHRpbWUnKSkge1xuICAgICAgbGluay5zZXRCaXJ0aHRpbWUoY29uZmlnLmJpcnRodGltZSk7XG4gICAgfVxuICAgIHJldHVybiBsaW5rO1xuICB9O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGZhY3RvcnkgZm9yIG5ldyBkaXJlY3Rvcmllcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgRmlsZSBjb25maWcuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbigpOkRpcmVjdG9yeX0gRmFjdG9yeSB0aGF0IGNyZWF0ZXMgYSBuZXcgZGlyZWN0b3J5LlxuICovXG5GaWxlU3lzdGVtLmRpcmVjdG9yeSA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICBjb25maWcgPSBjb25maWcgfHwge307XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBkaXIgPSBuZXcgRGlyZWN0b3J5KCk7XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgnbW9kZScpKSB7XG4gICAgICBkaXIuc2V0TW9kZShjb25maWcubW9kZSk7XG4gICAgfVxuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoJ3VpZCcpKSB7XG4gICAgICBkaXIuc2V0VWlkKGNvbmZpZy51aWQpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCdnaWQnKSkge1xuICAgICAgZGlyLnNldEdpZChjb25maWcuZ2lkKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgnaXRlbXMnKSkge1xuICAgICAgZm9yIChjb25zdCBuYW1lIGluIGNvbmZpZy5pdGVtcykge1xuICAgICAgICBwb3B1bGF0ZShkaXIsIG5hbWUsIGNvbmZpZy5pdGVtc1tuYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoJ2F0aW1lJykpIHtcbiAgICAgIGRpci5zZXRBVGltZShjb25maWcuYXRpbWUpO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KCdjdGltZScpKSB7XG4gICAgICBkaXIuc2V0Q1RpbWUoY29uZmlnLmN0aW1lKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5oYXNPd25Qcm9wZXJ0eSgnbXRpbWUnKSkge1xuICAgICAgZGlyLnNldE1UaW1lKGNvbmZpZy5tdGltZSk7XG4gICAgfVxuICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkoJ2JpcnRodGltZScpKSB7XG4gICAgICBkaXIuc2V0QmlydGh0aW1lKGNvbmZpZy5iaXJ0aHRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gZGlyO1xuICB9O1xufTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqL1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gRmlsZVN5c3RlbTtcbmV4cG9ydHMuZ2V0UGF0aFBhcnRzID0gZ2V0UGF0aFBhcnRzO1xuZXhwb3J0cy50b05hbWVzcGFjZWRQYXRoID0gdG9OYW1lc3BhY2VkUGF0aDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/filesystem.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mock-fs/lib/index.js":
/*!*******************************************!*\
  !*** ./node_modules/mock-fs/lib/index.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Binding = __webpack_require__(/*! ./binding */ \"(ssr)/./node_modules/mock-fs/lib/binding.js\");\nconst FSError = __webpack_require__(/*! ./error */ \"(ssr)/./node_modules/mock-fs/lib/error.js\");\nconst FileSystem = __webpack_require__(/*! ./filesystem */ \"(ssr)/./node_modules/mock-fs/lib/filesystem.js\");\nconst realBinding = process.binding('fs');\nconst path = __webpack_require__(/*! path */ \"path\");\nconst loader = __webpack_require__(/*! ./loader */ \"(ssr)/./node_modules/mock-fs/lib/loader.js\");\nconst bypass = __webpack_require__(/*! ./bypass */ \"(ssr)/./node_modules/mock-fs/lib/bypass.js\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\n\nconst toNamespacedPath = FileSystem.toNamespacedPath;\n\nconst realProcessProps = {\n  cwd: process.cwd,\n  chdir: process.chdir\n};\nconst realCreateWriteStream = fs.createWriteStream;\nconst realStats = realBinding.Stats;\nconst realStatWatcher = realBinding.StatWatcher;\n\n/**\n * Pre-patch fs binding.\n * This allows mock-fs to work properly under nodejs v10+ readFile\n * As ReadFileContext nodejs v10+ implementation traps original binding methods:\n * const { FSReqWrap, close, read } = process.binding('fs');\n * Note this patch only solves issue for readFile, as the require of\n * ReadFileContext is delayed by readFile implementation.\n * if (!ReadFileContext) ReadFileContext = require('internal/fs/read_file_context')\n *\n * @param {string} key Property name.\n */\nfunction patch(key) {\n  const existingMethod = realBinding[key];\n  realBinding[key] = function() {\n    if (this._mockedBinding) {\n      return this._mockedBinding[key].apply(this._mockedBinding, arguments);\n    } else {\n      return existingMethod.apply(this, arguments);\n    }\n  }.bind(realBinding);\n}\n\nfor (const key in Binding.prototype) {\n  if (typeof realBinding[key] === 'function') {\n    // Stats and StatWatcher are constructors\n    if (key !== 'Stats' && key !== 'StatWatcher') {\n      patch(key);\n    }\n  }\n}\n\nfunction overrideBinding(binding) {\n  realBinding._mockedBinding = binding;\n}\n\nfunction overrideProcess(cwd, chdir) {\n  process.cwd = cwd;\n  process.chdir = chdir;\n}\n\n/**\n * Have to disable write stream _writev on nodejs v10+.\n *\n * nodejs v8 lib/fs.js\n * note binding.writeBuffers will use mock-fs patched writeBuffers.\n *\n *   const binding = process.binding('fs');\n *   function writev(fd, chunks, position, callback) {\n *     // ...\n *     binding.writeBuffers(fd, chunks, position, req);\n *   }\n *\n * nodejs v10+ lib/internal/fs/streams.js\n * note it uses original writeBuffers, bypassed mock-fs patched writeBuffers.\n *\n *  const {writeBuffers} = internalBinding('fs');\n *  function writev(fd, chunks, position, callback) {\n *    // ...\n *    writeBuffers(fd, chunks, position, req);\n *  }\n *\n * Luckily _writev is an optional method on Writeable stream implementation.\n * When _writev is missing, it will fall back to make multiple _write calls.\n */\nfunction overrideCreateWriteStream() {\n  fs.createWriteStream = function(path, options) {\n    const output = realCreateWriteStream(path, options);\n    // disable _writev, this will over shadow WriteStream.prototype._writev\n    if (realBinding._mockedBinding) {\n      output._writev = undefined;\n    }\n    return output;\n  };\n}\n\nfunction restoreBinding() {\n  delete realBinding._mockedBinding;\n  realBinding.Stats = realStats;\n  realBinding.StatWatcher = realStatWatcher;\n}\n\nfunction restoreProcess() {\n  for (const key in realProcessProps) {\n    process[key] = realProcessProps[key];\n  }\n}\n\nfunction restoreCreateWriteStream() {\n  fs.createWriteStream = realCreateWriteStream;\n}\n\n/**\n * Swap out the fs bindings for a mock file system.\n * @param {Object} config Mock file system configuration.\n * @param {Object} options Any filesystem options.\n * @param {boolean} options.createCwd Create a directory for `process.cwd()`\n *     (defaults to `true`).\n * @param {boolean} options.createTmp Create a directory for `os.tmpdir()`\n *     (defaults to `true`).\n */\nexports = module.exports = function mock(config, options) {\n  const system = FileSystem.create(config, options);\n  const binding = new Binding(system);\n\n  overrideBinding(binding);\n\n  let currentPath = process.cwd();\n  overrideProcess(\n    function cwd() {\n      if (realBinding._mockedBinding) {\n        return currentPath;\n      }\n      return realProcessProps.cwd();\n    },\n    function chdir(directory) {\n      if (realBinding._mockedBinding) {\n        if (!binding.stat(toNamespacedPath(directory)).isDirectory()) {\n          throw new FSError('ENOTDIR');\n        }\n        currentPath = path.resolve(currentPath, directory);\n      } else {\n        return realProcessProps.chdir(directory);\n      }\n    }\n  );\n\n  overrideCreateWriteStream();\n};\n\n/**\n * Get hold of the mocked filesystem's 'root'\n * If fs hasn't currently been replaced, this will return an empty object\n */\nexports.getMockRoot = function() {\n  if (realBinding._mockedBinding) {\n    return realBinding._mockedBinding.getSystem().getRoot();\n  } else {\n    return {};\n  }\n};\n\n/**\n * Restore the fs bindings for the real file system.\n */\nexports.restore = function() {\n  restoreBinding();\n  restoreProcess();\n  restoreCreateWriteStream();\n};\n\n/**\n * Create a file factory.\n */\nexports.file = FileSystem.file;\n\n/**\n * Create a directory factory.\n */\nexports.directory = FileSystem.directory;\n\n/**\n * Create a symbolic link factory.\n */\nexports.symlink = FileSystem.symlink;\n\n/**\n * Automatically maps specified paths (for use with `mock()`)\n */\nexports.load = loader.load;\n\n/**\n * Perform action, bypassing mock FS\n * @example\n * // This file exists on the real FS, not on the mocked FS\n * const filePath = '/path/file.json';\n * const data = mock.bypass(() => fs.readFileSync(filePath, 'utf-8'));\n */\nexports.bypass = bypass;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMsOERBQVc7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsMERBQVM7QUFDakMsbUJBQW1CLG1CQUFPLENBQUMsb0VBQWM7QUFDekM7QUFDQSxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsZUFBZSxtQkFBTyxDQUFDLDREQUFVO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyw0REFBVTtBQUNqQyxXQUFXLG1CQUFPLENBQUMsY0FBSTs7QUFFdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHBvcnRrZXkvbmV4dC1leGFtcGxlLy4vbm9kZV9tb2R1bGVzL21vY2stZnMvbGliL2luZGV4LmpzP2QwNTkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCaW5kaW5nID0gcmVxdWlyZSgnLi9iaW5kaW5nJyk7XG5jb25zdCBGU0Vycm9yID0gcmVxdWlyZSgnLi9lcnJvcicpO1xuY29uc3QgRmlsZVN5c3RlbSA9IHJlcXVpcmUoJy4vZmlsZXN5c3RlbScpO1xuY29uc3QgcmVhbEJpbmRpbmcgPSBwcm9jZXNzLmJpbmRpbmcoJ2ZzJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgbG9hZGVyID0gcmVxdWlyZSgnLi9sb2FkZXInKTtcbmNvbnN0IGJ5cGFzcyA9IHJlcXVpcmUoJy4vYnlwYXNzJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5cbmNvbnN0IHRvTmFtZXNwYWNlZFBhdGggPSBGaWxlU3lzdGVtLnRvTmFtZXNwYWNlZFBhdGg7XG5cbmNvbnN0IHJlYWxQcm9jZXNzUHJvcHMgPSB7XG4gIGN3ZDogcHJvY2Vzcy5jd2QsXG4gIGNoZGlyOiBwcm9jZXNzLmNoZGlyXG59O1xuY29uc3QgcmVhbENyZWF0ZVdyaXRlU3RyZWFtID0gZnMuY3JlYXRlV3JpdGVTdHJlYW07XG5jb25zdCByZWFsU3RhdHMgPSByZWFsQmluZGluZy5TdGF0cztcbmNvbnN0IHJlYWxTdGF0V2F0Y2hlciA9IHJlYWxCaW5kaW5nLlN0YXRXYXRjaGVyO1xuXG4vKipcbiAqIFByZS1wYXRjaCBmcyBiaW5kaW5nLlxuICogVGhpcyBhbGxvd3MgbW9jay1mcyB0byB3b3JrIHByb3Blcmx5IHVuZGVyIG5vZGVqcyB2MTArIHJlYWRGaWxlXG4gKiBBcyBSZWFkRmlsZUNvbnRleHQgbm9kZWpzIHYxMCsgaW1wbGVtZW50YXRpb24gdHJhcHMgb3JpZ2luYWwgYmluZGluZyBtZXRob2RzOlxuICogY29uc3QgeyBGU1JlcVdyYXAsIGNsb3NlLCByZWFkIH0gPSBwcm9jZXNzLmJpbmRpbmcoJ2ZzJyk7XG4gKiBOb3RlIHRoaXMgcGF0Y2ggb25seSBzb2x2ZXMgaXNzdWUgZm9yIHJlYWRGaWxlLCBhcyB0aGUgcmVxdWlyZSBvZlxuICogUmVhZEZpbGVDb250ZXh0IGlzIGRlbGF5ZWQgYnkgcmVhZEZpbGUgaW1wbGVtZW50YXRpb24uXG4gKiBpZiAoIVJlYWRGaWxlQ29udGV4dCkgUmVhZEZpbGVDb250ZXh0ID0gcmVxdWlyZSgnaW50ZXJuYWwvZnMvcmVhZF9maWxlX2NvbnRleHQnKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgUHJvcGVydHkgbmFtZS5cbiAqL1xuZnVuY3Rpb24gcGF0Y2goa2V5KSB7XG4gIGNvbnN0IGV4aXN0aW5nTWV0aG9kID0gcmVhbEJpbmRpbmdba2V5XTtcbiAgcmVhbEJpbmRpbmdba2V5XSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9tb2NrZWRCaW5kaW5nKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbW9ja2VkQmluZGluZ1trZXldLmFwcGx5KHRoaXMuX21vY2tlZEJpbmRpbmcsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBleGlzdGluZ01ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfS5iaW5kKHJlYWxCaW5kaW5nKTtcbn1cblxuZm9yIChjb25zdCBrZXkgaW4gQmluZGluZy5wcm90b3R5cGUpIHtcbiAgaWYgKHR5cGVvZiByZWFsQmluZGluZ1trZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gU3RhdHMgYW5kIFN0YXRXYXRjaGVyIGFyZSBjb25zdHJ1Y3RvcnNcbiAgICBpZiAoa2V5ICE9PSAnU3RhdHMnICYmIGtleSAhPT0gJ1N0YXRXYXRjaGVyJykge1xuICAgICAgcGF0Y2goa2V5KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gb3ZlcnJpZGVCaW5kaW5nKGJpbmRpbmcpIHtcbiAgcmVhbEJpbmRpbmcuX21vY2tlZEJpbmRpbmcgPSBiaW5kaW5nO1xufVxuXG5mdW5jdGlvbiBvdmVycmlkZVByb2Nlc3MoY3dkLCBjaGRpcikge1xuICBwcm9jZXNzLmN3ZCA9IGN3ZDtcbiAgcHJvY2Vzcy5jaGRpciA9IGNoZGlyO1xufVxuXG4vKipcbiAqIEhhdmUgdG8gZGlzYWJsZSB3cml0ZSBzdHJlYW0gX3dyaXRldiBvbiBub2RlanMgdjEwKy5cbiAqXG4gKiBub2RlanMgdjggbGliL2ZzLmpzXG4gKiBub3RlIGJpbmRpbmcud3JpdGVCdWZmZXJzIHdpbGwgdXNlIG1vY2stZnMgcGF0Y2hlZCB3cml0ZUJ1ZmZlcnMuXG4gKlxuICogICBjb25zdCBiaW5kaW5nID0gcHJvY2Vzcy5iaW5kaW5nKCdmcycpO1xuICogICBmdW5jdGlvbiB3cml0ZXYoZmQsIGNodW5rcywgcG9zaXRpb24sIGNhbGxiYWNrKSB7XG4gKiAgICAgLy8gLi4uXG4gKiAgICAgYmluZGluZy53cml0ZUJ1ZmZlcnMoZmQsIGNodW5rcywgcG9zaXRpb24sIHJlcSk7XG4gKiAgIH1cbiAqXG4gKiBub2RlanMgdjEwKyBsaWIvaW50ZXJuYWwvZnMvc3RyZWFtcy5qc1xuICogbm90ZSBpdCB1c2VzIG9yaWdpbmFsIHdyaXRlQnVmZmVycywgYnlwYXNzZWQgbW9jay1mcyBwYXRjaGVkIHdyaXRlQnVmZmVycy5cbiAqXG4gKiAgY29uc3Qge3dyaXRlQnVmZmVyc30gPSBpbnRlcm5hbEJpbmRpbmcoJ2ZzJyk7XG4gKiAgZnVuY3Rpb24gd3JpdGV2KGZkLCBjaHVua3MsIHBvc2l0aW9uLCBjYWxsYmFjaykge1xuICogICAgLy8gLi4uXG4gKiAgICB3cml0ZUJ1ZmZlcnMoZmQsIGNodW5rcywgcG9zaXRpb24sIHJlcSk7XG4gKiAgfVxuICpcbiAqIEx1Y2tpbHkgX3dyaXRldiBpcyBhbiBvcHRpb25hbCBtZXRob2Qgb24gV3JpdGVhYmxlIHN0cmVhbSBpbXBsZW1lbnRhdGlvbi5cbiAqIFdoZW4gX3dyaXRldiBpcyBtaXNzaW5nLCBpdCB3aWxsIGZhbGwgYmFjayB0byBtYWtlIG11bHRpcGxlIF93cml0ZSBjYWxscy5cbiAqL1xuZnVuY3Rpb24gb3ZlcnJpZGVDcmVhdGVXcml0ZVN0cmVhbSgpIHtcbiAgZnMuY3JlYXRlV3JpdGVTdHJlYW0gPSBmdW5jdGlvbihwYXRoLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgb3V0cHV0ID0gcmVhbENyZWF0ZVdyaXRlU3RyZWFtKHBhdGgsIG9wdGlvbnMpO1xuICAgIC8vIGRpc2FibGUgX3dyaXRldiwgdGhpcyB3aWxsIG92ZXIgc2hhZG93IFdyaXRlU3RyZWFtLnByb3RvdHlwZS5fd3JpdGV2XG4gICAgaWYgKHJlYWxCaW5kaW5nLl9tb2NrZWRCaW5kaW5nKSB7XG4gICAgICBvdXRwdXQuX3dyaXRldiA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzdG9yZUJpbmRpbmcoKSB7XG4gIGRlbGV0ZSByZWFsQmluZGluZy5fbW9ja2VkQmluZGluZztcbiAgcmVhbEJpbmRpbmcuU3RhdHMgPSByZWFsU3RhdHM7XG4gIHJlYWxCaW5kaW5nLlN0YXRXYXRjaGVyID0gcmVhbFN0YXRXYXRjaGVyO1xufVxuXG5mdW5jdGlvbiByZXN0b3JlUHJvY2VzcygpIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gcmVhbFByb2Nlc3NQcm9wcykge1xuICAgIHByb2Nlc3Nba2V5XSA9IHJlYWxQcm9jZXNzUHJvcHNba2V5XTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN0b3JlQ3JlYXRlV3JpdGVTdHJlYW0oKSB7XG4gIGZzLmNyZWF0ZVdyaXRlU3RyZWFtID0gcmVhbENyZWF0ZVdyaXRlU3RyZWFtO1xufVxuXG4vKipcbiAqIFN3YXAgb3V0IHRoZSBmcyBiaW5kaW5ncyBmb3IgYSBtb2NrIGZpbGUgc3lzdGVtLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBNb2NrIGZpbGUgc3lzdGVtIGNvbmZpZ3VyYXRpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBbnkgZmlsZXN5c3RlbSBvcHRpb25zLlxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmNyZWF0ZUN3ZCBDcmVhdGUgYSBkaXJlY3RvcnkgZm9yIGBwcm9jZXNzLmN3ZCgpYFxuICogICAgIChkZWZhdWx0cyB0byBgdHJ1ZWApLlxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmNyZWF0ZVRtcCBDcmVhdGUgYSBkaXJlY3RvcnkgZm9yIGBvcy50bXBkaXIoKWBcbiAqICAgICAoZGVmYXVsdHMgdG8gYHRydWVgKS5cbiAqL1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbW9jayhjb25maWcsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc3lzdGVtID0gRmlsZVN5c3RlbS5jcmVhdGUoY29uZmlnLCBvcHRpb25zKTtcbiAgY29uc3QgYmluZGluZyA9IG5ldyBCaW5kaW5nKHN5c3RlbSk7XG5cbiAgb3ZlcnJpZGVCaW5kaW5nKGJpbmRpbmcpO1xuXG4gIGxldCBjdXJyZW50UGF0aCA9IHByb2Nlc3MuY3dkKCk7XG4gIG92ZXJyaWRlUHJvY2VzcyhcbiAgICBmdW5jdGlvbiBjd2QoKSB7XG4gICAgICBpZiAocmVhbEJpbmRpbmcuX21vY2tlZEJpbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlYWxQcm9jZXNzUHJvcHMuY3dkKCk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiBjaGRpcihkaXJlY3RvcnkpIHtcbiAgICAgIGlmIChyZWFsQmluZGluZy5fbW9ja2VkQmluZGluZykge1xuICAgICAgICBpZiAoIWJpbmRpbmcuc3RhdCh0b05hbWVzcGFjZWRQYXRoKGRpcmVjdG9yeSkpLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlNFcnJvcignRU5PVERJUicpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRQYXRoID0gcGF0aC5yZXNvbHZlKGN1cnJlbnRQYXRoLCBkaXJlY3RvcnkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlYWxQcm9jZXNzUHJvcHMuY2hkaXIoZGlyZWN0b3J5KTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG5cbiAgb3ZlcnJpZGVDcmVhdGVXcml0ZVN0cmVhbSgpO1xufTtcblxuLyoqXG4gKiBHZXQgaG9sZCBvZiB0aGUgbW9ja2VkIGZpbGVzeXN0ZW0ncyAncm9vdCdcbiAqIElmIGZzIGhhc24ndCBjdXJyZW50bHkgYmVlbiByZXBsYWNlZCwgdGhpcyB3aWxsIHJldHVybiBhbiBlbXB0eSBvYmplY3RcbiAqL1xuZXhwb3J0cy5nZXRNb2NrUm9vdCA9IGZ1bmN0aW9uKCkge1xuICBpZiAocmVhbEJpbmRpbmcuX21vY2tlZEJpbmRpbmcpIHtcbiAgICByZXR1cm4gcmVhbEJpbmRpbmcuX21vY2tlZEJpbmRpbmcuZ2V0U3lzdGVtKCkuZ2V0Um9vdCgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7fTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXN0b3JlIHRoZSBmcyBiaW5kaW5ncyBmb3IgdGhlIHJlYWwgZmlsZSBzeXN0ZW0uXG4gKi9cbmV4cG9ydHMucmVzdG9yZSA9IGZ1bmN0aW9uKCkge1xuICByZXN0b3JlQmluZGluZygpO1xuICByZXN0b3JlUHJvY2VzcygpO1xuICByZXN0b3JlQ3JlYXRlV3JpdGVTdHJlYW0oKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgZmlsZSBmYWN0b3J5LlxuICovXG5leHBvcnRzLmZpbGUgPSBGaWxlU3lzdGVtLmZpbGU7XG5cbi8qKlxuICogQ3JlYXRlIGEgZGlyZWN0b3J5IGZhY3RvcnkuXG4gKi9cbmV4cG9ydHMuZGlyZWN0b3J5ID0gRmlsZVN5c3RlbS5kaXJlY3Rvcnk7XG5cbi8qKlxuICogQ3JlYXRlIGEgc3ltYm9saWMgbGluayBmYWN0b3J5LlxuICovXG5leHBvcnRzLnN5bWxpbmsgPSBGaWxlU3lzdGVtLnN5bWxpbms7XG5cbi8qKlxuICogQXV0b21hdGljYWxseSBtYXBzIHNwZWNpZmllZCBwYXRocyAoZm9yIHVzZSB3aXRoIGBtb2NrKClgKVxuICovXG5leHBvcnRzLmxvYWQgPSBsb2FkZXIubG9hZDtcblxuLyoqXG4gKiBQZXJmb3JtIGFjdGlvbiwgYnlwYXNzaW5nIG1vY2sgRlNcbiAqIEBleGFtcGxlXG4gKiAvLyBUaGlzIGZpbGUgZXhpc3RzIG9uIHRoZSByZWFsIEZTLCBub3Qgb24gdGhlIG1vY2tlZCBGU1xuICogY29uc3QgZmlsZVBhdGggPSAnL3BhdGgvZmlsZS5qc29uJztcbiAqIGNvbnN0IGRhdGEgPSBtb2NrLmJ5cGFzcygoKSA9PiBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsICd1dGYtOCcpKTtcbiAqL1xuZXhwb3J0cy5ieXBhc3MgPSBieXBhc3M7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mock-fs/lib/item.js":
/*!******************************************!*\
  !*** ./node_modules/mock-fs/lib/item.js ***!
  \******************************************/
/***/ ((module, exports) => {

"use strict";
eval("\n\nlet counter = 0;\n\n/**\n * Permissions.\n * @enum {number}\n */\nconst permissions = {\n  USER_READ: 256, // 0400\n  USER_WRITE: 128, // 0200\n  USER_EXEC: 64, // 0100\n  GROUP_READ: 32, // 0040\n  GROUP_WRITE: 16, // 0020\n  GROUP_EXEC: 8, // 0010\n  OTHER_READ: 4, // 0004\n  OTHER_WRITE: 2, // 0002\n  OTHER_EXEC: 1 // 0001\n};\n\nfunction getUid() {\n  // force NaN on windows.\n  return process.getuid ? process.getuid() : NaN;\n}\n\nfunction getGid() {\n  // force NaN on windows.\n  return process.getgid ? process.getgid() : NaN;\n}\n\n/**\n * A filesystem item.\n * @constructor\n */\nfunction Item() {\n  const now = Date.now();\n\n  /**\n   * Access time.\n   * @type {Date}\n   */\n  this._atime = new Date(now);\n\n  /**\n   * Change time.\n   * @type {Date}\n   */\n  this._ctime = new Date(now);\n\n  /**\n   * Birth time.\n   * @type {Date}\n   */\n  this._birthtime = new Date(now);\n\n  /**\n   * Modification time.\n   * @type {Date}\n   */\n  this._mtime = new Date(now);\n\n  /**\n   * Permissions.\n   */\n  this._mode = 438; // 0666\n\n  /**\n   * User id.\n   * @type {number}\n   */\n  this._uid = getUid();\n\n  /**\n   * Group id.\n   * @type {number}\n   */\n  this._gid = getGid();\n\n  /**\n   * Item number.\n   * @type {number}\n   */\n  this._id = ++counter;\n\n  /**\n   * Number of links to this item.\n   */\n  this.links = 0;\n}\n\n/**\n * Add execute if read allowed\n * See notes in index.js -> mapping#addDir\n */\nItem.fixWin32Permissions = mode =>\n  process.platform !== 'win32'\n    ? mode\n    : mode |\n      (mode & permissions.USER_READ && permissions.USER_EXEC) |\n      (mode & permissions.GROUP_READ && permissions.GROUP_EXEC) |\n      (mode & permissions.OTHER_READ && permissions.OTHER_EXEC);\n\n/**\n * Determine if the current user has read permission.\n * @return {boolean} The current user can read.\n */\nItem.prototype.canRead = function() {\n  const uid = getUid();\n  const gid = getGid();\n  let can = false;\n  if (uid === 0) {\n    can = true;\n  } else if (uid === this._uid || uid !== uid) {\n    // (uid !== uid) means uid is NaN, only for windows\n    can = (permissions.USER_READ & this._mode) === permissions.USER_READ;\n  } else if (gid === this._gid) {\n    can = (permissions.GROUP_READ & this._mode) === permissions.GROUP_READ;\n  } else {\n    can = (permissions.OTHER_READ & this._mode) === permissions.OTHER_READ;\n  }\n  return can;\n};\n\n/**\n * Determine if the current user has write permission.\n * @return {boolean} The current user can write.\n */\nItem.prototype.canWrite = function() {\n  const uid = getUid();\n  const gid = getGid();\n  let can = false;\n  if (uid === 0) {\n    can = true;\n  } else if (uid === this._uid || uid !== uid) {\n    // (uid !== uid) means uid is NaN, only for windows\n    can = (permissions.USER_WRITE & this._mode) === permissions.USER_WRITE;\n  } else if (gid === this._gid) {\n    can = (permissions.GROUP_WRITE & this._mode) === permissions.GROUP_WRITE;\n  } else {\n    can = (permissions.OTHER_WRITE & this._mode) === permissions.OTHER_WRITE;\n  }\n  return can;\n};\n\n/**\n * Determine if the current user has execute permission.\n * @return {boolean} The current user can execute.\n */\nItem.prototype.canExecute = function() {\n  const uid = getUid();\n  const gid = getGid();\n  let can = false;\n  if (uid === 0) {\n    can = true;\n  } else if (uid === this._uid || isNaN(uid)) {\n    // NaN occurs on windows\n    can = (permissions.USER_EXEC & this._mode) === permissions.USER_EXEC;\n  } else if (gid === this._gid) {\n    can = (permissions.GROUP_EXEC & this._mode) === permissions.GROUP_EXEC;\n  } else {\n    can = (permissions.OTHER_EXEC & this._mode) === permissions.OTHER_EXEC;\n  }\n  return can;\n};\n\n/**\n * Get access time.\n * @return {Date} Access time.\n */\nItem.prototype.getATime = function() {\n  return this._atime;\n};\n\n/**\n * Set access time.\n * @param {Date} atime Access time.\n */\nItem.prototype.setATime = function(atime) {\n  this._atime = atime;\n};\n\n/**\n * Get change time.\n * @return {Date} Change time.\n */\nItem.prototype.getCTime = function() {\n  return this._ctime;\n};\n\n/**\n * Set change time.\n * @param {Date} ctime Change time.\n */\nItem.prototype.setCTime = function(ctime) {\n  this._ctime = ctime;\n};\n\n/**\n * Get birth time.\n * @return {Date} Birth time.\n */\nItem.prototype.getBirthtime = function() {\n  return this._birthtime;\n};\n\n/**\n * Set change time.\n * @param {Date} birthtime Birth time.\n */\nItem.prototype.setBirthtime = function(birthtime) {\n  this._birthtime = birthtime;\n};\n\n/**\n * Get modification time.\n * @return {Date} Modification time.\n */\nItem.prototype.getMTime = function() {\n  return this._mtime;\n};\n\n/**\n * Set modification time.\n * @param {Date} mtime Modification time.\n */\nItem.prototype.setMTime = function(mtime) {\n  this._mtime = mtime;\n};\n\n/**\n * Get mode (permission only, e.g 0666).\n * @return {number} Mode.\n */\nItem.prototype.getMode = function() {\n  return this._mode;\n};\n\n/**\n * Set mode (permission only, e.g 0666).\n * @param {Date} mode Mode.\n */\nItem.prototype.setMode = function(mode) {\n  this.setCTime(new Date());\n  this._mode = mode;\n};\n\n/**\n * Get user id.\n * @return {number} User id.\n */\nItem.prototype.getUid = function() {\n  return this._uid;\n};\n\n/**\n * Set user id.\n * @param {number} uid User id.\n */\nItem.prototype.setUid = function(uid) {\n  this.setCTime(new Date());\n  this._uid = uid;\n};\n\n/**\n * Get group id.\n * @return {number} Group id.\n */\nItem.prototype.getGid = function() {\n  return this._gid;\n};\n\n/**\n * Set group id.\n * @param {number} gid Group id.\n */\nItem.prototype.setGid = function(gid) {\n  this.setCTime(new Date());\n  this._gid = gid;\n};\n\n/**\n * Get item stats.\n * @return {Object} Stats properties.\n */\nItem.prototype.getStats = function() {\n  return {\n    dev: 8675309,\n    nlink: this.links,\n    uid: this.getUid(),\n    gid: this.getGid(),\n    rdev: 0,\n    blksize: 4096,\n    ino: this._id,\n    atime: this.getATime(),\n    mtime: this.getMTime(),\n    ctime: this.getCTime(),\n    birthtime: this.getBirthtime(),\n    atimeMs: +this.getATime(),\n    mtimeMs: +this.getMTime(),\n    ctimeMs: +this.getCTime(),\n    birthtimeMs: +this.getBirthtime()\n  };\n};\n\n/**\n * Get the item's string representation.\n * @return {string} String representation.\n */\nItem.prototype.toString = function() {\n  return '[' + this.constructor.name + ']';\n};\n\n/**\n * Export the constructor.\n * @type {function()}\n */\nexports = module.exports = Item;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvaXRlbS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcG9ydGtleS9uZXh0LWV4YW1wbGUvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvaXRlbS5qcz8yYTJjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubGV0IGNvdW50ZXIgPSAwO1xuXG4vKipcbiAqIFBlcm1pc3Npb25zLlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuY29uc3QgcGVybWlzc2lvbnMgPSB7XG4gIFVTRVJfUkVBRDogMjU2LCAvLyAwNDAwXG4gIFVTRVJfV1JJVEU6IDEyOCwgLy8gMDIwMFxuICBVU0VSX0VYRUM6IDY0LCAvLyAwMTAwXG4gIEdST1VQX1JFQUQ6IDMyLCAvLyAwMDQwXG4gIEdST1VQX1dSSVRFOiAxNiwgLy8gMDAyMFxuICBHUk9VUF9FWEVDOiA4LCAvLyAwMDEwXG4gIE9USEVSX1JFQUQ6IDQsIC8vIDAwMDRcbiAgT1RIRVJfV1JJVEU6IDIsIC8vIDAwMDJcbiAgT1RIRVJfRVhFQzogMSAvLyAwMDAxXG59O1xuXG5mdW5jdGlvbiBnZXRVaWQoKSB7XG4gIC8vIGZvcmNlIE5hTiBvbiB3aW5kb3dzLlxuICByZXR1cm4gcHJvY2Vzcy5nZXR1aWQgPyBwcm9jZXNzLmdldHVpZCgpIDogTmFOO1xufVxuXG5mdW5jdGlvbiBnZXRHaWQoKSB7XG4gIC8vIGZvcmNlIE5hTiBvbiB3aW5kb3dzLlxuICByZXR1cm4gcHJvY2Vzcy5nZXRnaWQgPyBwcm9jZXNzLmdldGdpZCgpIDogTmFOO1xufVxuXG4vKipcbiAqIEEgZmlsZXN5c3RlbSBpdGVtLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEl0ZW0oKSB7XG4gIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG5cbiAgLyoqXG4gICAqIEFjY2VzcyB0aW1lLlxuICAgKiBAdHlwZSB7RGF0ZX1cbiAgICovXG4gIHRoaXMuX2F0aW1lID0gbmV3IERhdGUobm93KTtcblxuICAvKipcbiAgICogQ2hhbmdlIHRpbWUuXG4gICAqIEB0eXBlIHtEYXRlfVxuICAgKi9cbiAgdGhpcy5fY3RpbWUgPSBuZXcgRGF0ZShub3cpO1xuXG4gIC8qKlxuICAgKiBCaXJ0aCB0aW1lLlxuICAgKiBAdHlwZSB7RGF0ZX1cbiAgICovXG4gIHRoaXMuX2JpcnRodGltZSA9IG5ldyBEYXRlKG5vdyk7XG5cbiAgLyoqXG4gICAqIE1vZGlmaWNhdGlvbiB0aW1lLlxuICAgKiBAdHlwZSB7RGF0ZX1cbiAgICovXG4gIHRoaXMuX210aW1lID0gbmV3IERhdGUobm93KTtcblxuICAvKipcbiAgICogUGVybWlzc2lvbnMuXG4gICAqL1xuICB0aGlzLl9tb2RlID0gNDM4OyAvLyAwNjY2XG5cbiAgLyoqXG4gICAqIFVzZXIgaWQuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLl91aWQgPSBnZXRVaWQoKTtcblxuICAvKipcbiAgICogR3JvdXAgaWQuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLl9naWQgPSBnZXRHaWQoKTtcblxuICAvKipcbiAgICogSXRlbSBudW1iZXIuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLl9pZCA9ICsrY291bnRlcjtcblxuICAvKipcbiAgICogTnVtYmVyIG9mIGxpbmtzIHRvIHRoaXMgaXRlbS5cbiAgICovXG4gIHRoaXMubGlua3MgPSAwO1xufVxuXG4vKipcbiAqIEFkZCBleGVjdXRlIGlmIHJlYWQgYWxsb3dlZFxuICogU2VlIG5vdGVzIGluIGluZGV4LmpzIC0+IG1hcHBpbmcjYWRkRGlyXG4gKi9cbkl0ZW0uZml4V2luMzJQZXJtaXNzaW9ucyA9IG1vZGUgPT5cbiAgcHJvY2Vzcy5wbGF0Zm9ybSAhPT0gJ3dpbjMyJ1xuICAgID8gbW9kZVxuICAgIDogbW9kZSB8XG4gICAgICAobW9kZSAmIHBlcm1pc3Npb25zLlVTRVJfUkVBRCAmJiBwZXJtaXNzaW9ucy5VU0VSX0VYRUMpIHxcbiAgICAgIChtb2RlICYgcGVybWlzc2lvbnMuR1JPVVBfUkVBRCAmJiBwZXJtaXNzaW9ucy5HUk9VUF9FWEVDKSB8XG4gICAgICAobW9kZSAmIHBlcm1pc3Npb25zLk9USEVSX1JFQUQgJiYgcGVybWlzc2lvbnMuT1RIRVJfRVhFQyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBjdXJyZW50IHVzZXIgaGFzIHJlYWQgcGVybWlzc2lvbi5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBjdXJyZW50IHVzZXIgY2FuIHJlYWQuXG4gKi9cbkl0ZW0ucHJvdG90eXBlLmNhblJlYWQgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgdWlkID0gZ2V0VWlkKCk7XG4gIGNvbnN0IGdpZCA9IGdldEdpZCgpO1xuICBsZXQgY2FuID0gZmFsc2U7XG4gIGlmICh1aWQgPT09IDApIHtcbiAgICBjYW4gPSB0cnVlO1xuICB9IGVsc2UgaWYgKHVpZCA9PT0gdGhpcy5fdWlkIHx8IHVpZCAhPT0gdWlkKSB7XG4gICAgLy8gKHVpZCAhPT0gdWlkKSBtZWFucyB1aWQgaXMgTmFOLCBvbmx5IGZvciB3aW5kb3dzXG4gICAgY2FuID0gKHBlcm1pc3Npb25zLlVTRVJfUkVBRCAmIHRoaXMuX21vZGUpID09PSBwZXJtaXNzaW9ucy5VU0VSX1JFQUQ7XG4gIH0gZWxzZSBpZiAoZ2lkID09PSB0aGlzLl9naWQpIHtcbiAgICBjYW4gPSAocGVybWlzc2lvbnMuR1JPVVBfUkVBRCAmIHRoaXMuX21vZGUpID09PSBwZXJtaXNzaW9ucy5HUk9VUF9SRUFEO1xuICB9IGVsc2Uge1xuICAgIGNhbiA9IChwZXJtaXNzaW9ucy5PVEhFUl9SRUFEICYgdGhpcy5fbW9kZSkgPT09IHBlcm1pc3Npb25zLk9USEVSX1JFQUQ7XG4gIH1cbiAgcmV0dXJuIGNhbjtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBjdXJyZW50IHVzZXIgaGFzIHdyaXRlIHBlcm1pc3Npb24uXG4gKiBAcmV0dXJuIHtib29sZWFufSBUaGUgY3VycmVudCB1c2VyIGNhbiB3cml0ZS5cbiAqL1xuSXRlbS5wcm90b3R5cGUuY2FuV3JpdGUgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgdWlkID0gZ2V0VWlkKCk7XG4gIGNvbnN0IGdpZCA9IGdldEdpZCgpO1xuICBsZXQgY2FuID0gZmFsc2U7XG4gIGlmICh1aWQgPT09IDApIHtcbiAgICBjYW4gPSB0cnVlO1xuICB9IGVsc2UgaWYgKHVpZCA9PT0gdGhpcy5fdWlkIHx8IHVpZCAhPT0gdWlkKSB7XG4gICAgLy8gKHVpZCAhPT0gdWlkKSBtZWFucyB1aWQgaXMgTmFOLCBvbmx5IGZvciB3aW5kb3dzXG4gICAgY2FuID0gKHBlcm1pc3Npb25zLlVTRVJfV1JJVEUgJiB0aGlzLl9tb2RlKSA9PT0gcGVybWlzc2lvbnMuVVNFUl9XUklURTtcbiAgfSBlbHNlIGlmIChnaWQgPT09IHRoaXMuX2dpZCkge1xuICAgIGNhbiA9IChwZXJtaXNzaW9ucy5HUk9VUF9XUklURSAmIHRoaXMuX21vZGUpID09PSBwZXJtaXNzaW9ucy5HUk9VUF9XUklURTtcbiAgfSBlbHNlIHtcbiAgICBjYW4gPSAocGVybWlzc2lvbnMuT1RIRVJfV1JJVEUgJiB0aGlzLl9tb2RlKSA9PT0gcGVybWlzc2lvbnMuT1RIRVJfV1JJVEU7XG4gIH1cbiAgcmV0dXJuIGNhbjtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBjdXJyZW50IHVzZXIgaGFzIGV4ZWN1dGUgcGVybWlzc2lvbi5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBjdXJyZW50IHVzZXIgY2FuIGV4ZWN1dGUuXG4gKi9cbkl0ZW0ucHJvdG90eXBlLmNhbkV4ZWN1dGUgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgdWlkID0gZ2V0VWlkKCk7XG4gIGNvbnN0IGdpZCA9IGdldEdpZCgpO1xuICBsZXQgY2FuID0gZmFsc2U7XG4gIGlmICh1aWQgPT09IDApIHtcbiAgICBjYW4gPSB0cnVlO1xuICB9IGVsc2UgaWYgKHVpZCA9PT0gdGhpcy5fdWlkIHx8IGlzTmFOKHVpZCkpIHtcbiAgICAvLyBOYU4gb2NjdXJzIG9uIHdpbmRvd3NcbiAgICBjYW4gPSAocGVybWlzc2lvbnMuVVNFUl9FWEVDICYgdGhpcy5fbW9kZSkgPT09IHBlcm1pc3Npb25zLlVTRVJfRVhFQztcbiAgfSBlbHNlIGlmIChnaWQgPT09IHRoaXMuX2dpZCkge1xuICAgIGNhbiA9IChwZXJtaXNzaW9ucy5HUk9VUF9FWEVDICYgdGhpcy5fbW9kZSkgPT09IHBlcm1pc3Npb25zLkdST1VQX0VYRUM7XG4gIH0gZWxzZSB7XG4gICAgY2FuID0gKHBlcm1pc3Npb25zLk9USEVSX0VYRUMgJiB0aGlzLl9tb2RlKSA9PT0gcGVybWlzc2lvbnMuT1RIRVJfRVhFQztcbiAgfVxuICByZXR1cm4gY2FuO1xufTtcblxuLyoqXG4gKiBHZXQgYWNjZXNzIHRpbWUuXG4gKiBAcmV0dXJuIHtEYXRlfSBBY2Nlc3MgdGltZS5cbiAqL1xuSXRlbS5wcm90b3R5cGUuZ2V0QVRpbWUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2F0aW1lO1xufTtcblxuLyoqXG4gKiBTZXQgYWNjZXNzIHRpbWUuXG4gKiBAcGFyYW0ge0RhdGV9IGF0aW1lIEFjY2VzcyB0aW1lLlxuICovXG5JdGVtLnByb3RvdHlwZS5zZXRBVGltZSA9IGZ1bmN0aW9uKGF0aW1lKSB7XG4gIHRoaXMuX2F0aW1lID0gYXRpbWU7XG59O1xuXG4vKipcbiAqIEdldCBjaGFuZ2UgdGltZS5cbiAqIEByZXR1cm4ge0RhdGV9IENoYW5nZSB0aW1lLlxuICovXG5JdGVtLnByb3RvdHlwZS5nZXRDVGltZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY3RpbWU7XG59O1xuXG4vKipcbiAqIFNldCBjaGFuZ2UgdGltZS5cbiAqIEBwYXJhbSB7RGF0ZX0gY3RpbWUgQ2hhbmdlIHRpbWUuXG4gKi9cbkl0ZW0ucHJvdG90eXBlLnNldENUaW1lID0gZnVuY3Rpb24oY3RpbWUpIHtcbiAgdGhpcy5fY3RpbWUgPSBjdGltZTtcbn07XG5cbi8qKlxuICogR2V0IGJpcnRoIHRpbWUuXG4gKiBAcmV0dXJuIHtEYXRlfSBCaXJ0aCB0aW1lLlxuICovXG5JdGVtLnByb3RvdHlwZS5nZXRCaXJ0aHRpbWUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2JpcnRodGltZTtcbn07XG5cbi8qKlxuICogU2V0IGNoYW5nZSB0aW1lLlxuICogQHBhcmFtIHtEYXRlfSBiaXJ0aHRpbWUgQmlydGggdGltZS5cbiAqL1xuSXRlbS5wcm90b3R5cGUuc2V0QmlydGh0aW1lID0gZnVuY3Rpb24oYmlydGh0aW1lKSB7XG4gIHRoaXMuX2JpcnRodGltZSA9IGJpcnRodGltZTtcbn07XG5cbi8qKlxuICogR2V0IG1vZGlmaWNhdGlvbiB0aW1lLlxuICogQHJldHVybiB7RGF0ZX0gTW9kaWZpY2F0aW9uIHRpbWUuXG4gKi9cbkl0ZW0ucHJvdG90eXBlLmdldE1UaW1lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9tdGltZTtcbn07XG5cbi8qKlxuICogU2V0IG1vZGlmaWNhdGlvbiB0aW1lLlxuICogQHBhcmFtIHtEYXRlfSBtdGltZSBNb2RpZmljYXRpb24gdGltZS5cbiAqL1xuSXRlbS5wcm90b3R5cGUuc2V0TVRpbWUgPSBmdW5jdGlvbihtdGltZSkge1xuICB0aGlzLl9tdGltZSA9IG10aW1lO1xufTtcblxuLyoqXG4gKiBHZXQgbW9kZSAocGVybWlzc2lvbiBvbmx5LCBlLmcgMDY2NikuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE1vZGUuXG4gKi9cbkl0ZW0ucHJvdG90eXBlLmdldE1vZGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX21vZGU7XG59O1xuXG4vKipcbiAqIFNldCBtb2RlIChwZXJtaXNzaW9uIG9ubHksIGUuZyAwNjY2KS5cbiAqIEBwYXJhbSB7RGF0ZX0gbW9kZSBNb2RlLlxuICovXG5JdGVtLnByb3RvdHlwZS5zZXRNb2RlID0gZnVuY3Rpb24obW9kZSkge1xuICB0aGlzLnNldENUaW1lKG5ldyBEYXRlKCkpO1xuICB0aGlzLl9tb2RlID0gbW9kZTtcbn07XG5cbi8qKlxuICogR2V0IHVzZXIgaWQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFVzZXIgaWQuXG4gKi9cbkl0ZW0ucHJvdG90eXBlLmdldFVpZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fdWlkO1xufTtcblxuLyoqXG4gKiBTZXQgdXNlciBpZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB1aWQgVXNlciBpZC5cbiAqL1xuSXRlbS5wcm90b3R5cGUuc2V0VWlkID0gZnVuY3Rpb24odWlkKSB7XG4gIHRoaXMuc2V0Q1RpbWUobmV3IERhdGUoKSk7XG4gIHRoaXMuX3VpZCA9IHVpZDtcbn07XG5cbi8qKlxuICogR2V0IGdyb3VwIGlkLlxuICogQHJldHVybiB7bnVtYmVyfSBHcm91cCBpZC5cbiAqL1xuSXRlbS5wcm90b3R5cGUuZ2V0R2lkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9naWQ7XG59O1xuXG4vKipcbiAqIFNldCBncm91cCBpZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBnaWQgR3JvdXAgaWQuXG4gKi9cbkl0ZW0ucHJvdG90eXBlLnNldEdpZCA9IGZ1bmN0aW9uKGdpZCkge1xuICB0aGlzLnNldENUaW1lKG5ldyBEYXRlKCkpO1xuICB0aGlzLl9naWQgPSBnaWQ7XG59O1xuXG4vKipcbiAqIEdldCBpdGVtIHN0YXRzLlxuICogQHJldHVybiB7T2JqZWN0fSBTdGF0cyBwcm9wZXJ0aWVzLlxuICovXG5JdGVtLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIGRldjogODY3NTMwOSxcbiAgICBubGluazogdGhpcy5saW5rcyxcbiAgICB1aWQ6IHRoaXMuZ2V0VWlkKCksXG4gICAgZ2lkOiB0aGlzLmdldEdpZCgpLFxuICAgIHJkZXY6IDAsXG4gICAgYmxrc2l6ZTogNDA5NixcbiAgICBpbm86IHRoaXMuX2lkLFxuICAgIGF0aW1lOiB0aGlzLmdldEFUaW1lKCksXG4gICAgbXRpbWU6IHRoaXMuZ2V0TVRpbWUoKSxcbiAgICBjdGltZTogdGhpcy5nZXRDVGltZSgpLFxuICAgIGJpcnRodGltZTogdGhpcy5nZXRCaXJ0aHRpbWUoKSxcbiAgICBhdGltZU1zOiArdGhpcy5nZXRBVGltZSgpLFxuICAgIG10aW1lTXM6ICt0aGlzLmdldE1UaW1lKCksXG4gICAgY3RpbWVNczogK3RoaXMuZ2V0Q1RpbWUoKSxcbiAgICBiaXJ0aHRpbWVNczogK3RoaXMuZ2V0QmlydGh0aW1lKClcbiAgfTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBpdGVtJ3Mgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gKi9cbkl0ZW0ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnWycgKyB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnXSc7XG59O1xuXG4vKipcbiAqIEV4cG9ydCB0aGUgY29uc3RydWN0b3IuXG4gKiBAdHlwZSB7ZnVuY3Rpb24oKX1cbiAqL1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gSXRlbTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/item.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mock-fs/lib/loader.js":
/*!********************************************!*\
  !*** ./node_modules/mock-fs/lib/loader.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const {fixWin32Permissions} = __webpack_require__(/*! ./item */ \"(ssr)/./node_modules/mock-fs/lib/item.js\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst FileSystem = __webpack_require__(/*! ./filesystem */ \"(ssr)/./node_modules/mock-fs/lib/filesystem.js\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst bypass = __webpack_require__(/*! ./bypass */ \"(ssr)/./node_modules/mock-fs/lib/bypass.js\");\n\nconst createContext = ({output, options = {}, target}, newContext) =>\n  Object.assign(\n    {\n      // Assign options and set defaults if needed\n      options: {\n        recursive: options.recursive !== false,\n        lazy: options.lazy !== false\n      },\n      output,\n      target\n    },\n    newContext\n  );\n\nfunction addFile(context, stats, isRoot) {\n  const {output, target} = context;\n  const {lazy} = context.options;\n\n  if (!stats.isFile()) {\n    throw new Error(`${target} is not a valid file!`);\n  }\n\n  const outputPropKey = isRoot ? target : path.basename(target);\n\n  output[outputPropKey] = () => {\n    const content = !lazy ? fs.readFileSync(target) : '';\n    const file = FileSystem.file(Object.assign({}, stats, {content}))();\n\n    if (lazy) {\n      Object.defineProperty(file, '_content', {\n        get() {\n          const res = bypass(() => fs.readFileSync(target));\n          Object.defineProperty(file, '_content', {\n            value: res,\n            writable: true\n          });\n          return res;\n        },\n        set(data) {\n          Object.defineProperty(file, '_content', {\n            value: data,\n            writable: true\n          });\n        },\n        configurable: true\n      });\n    }\n\n    return file;\n  };\n\n  return output[outputPropKey];\n}\n\nfunction addDir(context, stats, isRoot) {\n  const {target, output} = context;\n  const {recursive} = context.options;\n\n  if (!stats.isDirectory()) {\n    throw new Error(`${target} is not a valid directory!`);\n  }\n\n  stats = Object.assign({}, stats);\n  const outputPropKey = isRoot ? target : path.basename(target);\n\n  // On windows platforms, directories do not have the executable flag, which causes FileSystem.prototype.getItem\n  // to think that the directory cannot be traversed. This is a workaround, however, a better solution may be to\n  // re-think the logic in FileSystem.prototype.getItem\n  // This workaround adds executable privileges if read privileges are found\n  stats.mode = fixWin32Permissions(stats.mode);\n\n  // Create directory factory\n  const directoryItems = {};\n  output[outputPropKey] = FileSystem.directory(\n    Object.assign(stats, {items: directoryItems})\n  );\n\n  fs.readdirSync(target).forEach(p => {\n    const absPath = path.join(target, p);\n    const stats = fs.statSync(absPath);\n    const newContext = createContext(context, {\n      target: absPath,\n      output: directoryItems\n    });\n\n    if (recursive && stats.isDirectory()) {\n      addDir(newContext, stats);\n    } else if (stats.isFile()) {\n      addFile(newContext, stats);\n    }\n  });\n\n  return output[outputPropKey];\n}\n\n/**\n * Load directory or file from real FS\n */\nexports.load = function(p, options) {\n  return bypass(() => {\n    p = path.resolve(p);\n\n    const stats = fs.statSync(p);\n    const context = createContext({output: {}, options, target: p});\n\n    if (stats.isDirectory()) {\n      return addDir(context, stats, true);\n    } else if (stats.isFile()) {\n      return addFile(context, stats, true);\n    }\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvbG9hZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBLE9BQU8scUJBQXFCLEVBQUUsbUJBQU8sQ0FBQyx3REFBUTtBQUM5QyxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsbUJBQW1CLG1CQUFPLENBQUMsb0VBQWM7QUFDekMsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsZUFBZSxtQkFBTyxDQUFDLDREQUFVOztBQUVqQyx3QkFBd0Isb0JBQW9CLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLFNBQVMsZ0JBQWdCO0FBQ3pCLFNBQVMsTUFBTTs7QUFFZjtBQUNBLHVCQUF1QixRQUFRO0FBQy9COztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQsVUFBVSxRQUFROztBQUVuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxnQkFBZ0I7QUFDekIsU0FBUyxXQUFXOztBQUVwQjtBQUNBLHVCQUF1QixRQUFRO0FBQy9COztBQUVBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzQkFBc0I7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsVUFBVSxxQkFBcUI7O0FBRWxFO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL0Bwb3J0a2V5L25leHQtZXhhbXBsZS8uL25vZGVfbW9kdWxlcy9tb2NrLWZzL2xpYi9sb2FkZXIuanM/NzZjMiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7Zml4V2luMzJQZXJtaXNzaW9uc30gPSByZXF1aXJlKCcuL2l0ZW0nKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBGaWxlU3lzdGVtID0gcmVxdWlyZSgnLi9maWxlc3lzdGVtJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBieXBhc3MgPSByZXF1aXJlKCcuL2J5cGFzcycpO1xuXG5jb25zdCBjcmVhdGVDb250ZXh0ID0gKHtvdXRwdXQsIG9wdGlvbnMgPSB7fSwgdGFyZ2V0fSwgbmV3Q29udGV4dCkgPT5cbiAgT2JqZWN0LmFzc2lnbihcbiAgICB7XG4gICAgICAvLyBBc3NpZ24gb3B0aW9ucyBhbmQgc2V0IGRlZmF1bHRzIGlmIG5lZWRlZFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICByZWN1cnNpdmU6IG9wdGlvbnMucmVjdXJzaXZlICE9PSBmYWxzZSxcbiAgICAgICAgbGF6eTogb3B0aW9ucy5sYXp5ICE9PSBmYWxzZVxuICAgICAgfSxcbiAgICAgIG91dHB1dCxcbiAgICAgIHRhcmdldFxuICAgIH0sXG4gICAgbmV3Q29udGV4dFxuICApO1xuXG5mdW5jdGlvbiBhZGRGaWxlKGNvbnRleHQsIHN0YXRzLCBpc1Jvb3QpIHtcbiAgY29uc3Qge291dHB1dCwgdGFyZ2V0fSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtsYXp5fSA9IGNvbnRleHQub3B0aW9ucztcblxuICBpZiAoIXN0YXRzLmlzRmlsZSgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3RhcmdldH0gaXMgbm90IGEgdmFsaWQgZmlsZSFgKTtcbiAgfVxuXG4gIGNvbnN0IG91dHB1dFByb3BLZXkgPSBpc1Jvb3QgPyB0YXJnZXQgOiBwYXRoLmJhc2VuYW1lKHRhcmdldCk7XG5cbiAgb3V0cHV0W291dHB1dFByb3BLZXldID0gKCkgPT4ge1xuICAgIGNvbnN0IGNvbnRlbnQgPSAhbGF6eSA/IGZzLnJlYWRGaWxlU3luYyh0YXJnZXQpIDogJyc7XG4gICAgY29uc3QgZmlsZSA9IEZpbGVTeXN0ZW0uZmlsZShPYmplY3QuYXNzaWduKHt9LCBzdGF0cywge2NvbnRlbnR9KSkoKTtcblxuICAgIGlmIChsYXp5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmlsZSwgJ19jb250ZW50Jywge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgY29uc3QgcmVzID0gYnlwYXNzKCgpID0+IGZzLnJlYWRGaWxlU3luYyh0YXJnZXQpKTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmlsZSwgJ19jb250ZW50Jywge1xuICAgICAgICAgICAgdmFsdWU6IHJlcyxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KGRhdGEpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmlsZSwgJ19jb250ZW50Jywge1xuICAgICAgICAgICAgdmFsdWU6IGRhdGEsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBmaWxlO1xuICB9O1xuXG4gIHJldHVybiBvdXRwdXRbb3V0cHV0UHJvcEtleV07XG59XG5cbmZ1bmN0aW9uIGFkZERpcihjb250ZXh0LCBzdGF0cywgaXNSb290KSB7XG4gIGNvbnN0IHt0YXJnZXQsIG91dHB1dH0gPSBjb250ZXh0O1xuICBjb25zdCB7cmVjdXJzaXZlfSA9IGNvbnRleHQub3B0aW9ucztcblxuICBpZiAoIXN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGFyZ2V0fSBpcyBub3QgYSB2YWxpZCBkaXJlY3RvcnkhYCk7XG4gIH1cblxuICBzdGF0cyA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRzKTtcbiAgY29uc3Qgb3V0cHV0UHJvcEtleSA9IGlzUm9vdCA/IHRhcmdldCA6IHBhdGguYmFzZW5hbWUodGFyZ2V0KTtcblxuICAvLyBPbiB3aW5kb3dzIHBsYXRmb3JtcywgZGlyZWN0b3JpZXMgZG8gbm90IGhhdmUgdGhlIGV4ZWN1dGFibGUgZmxhZywgd2hpY2ggY2F1c2VzIEZpbGVTeXN0ZW0ucHJvdG90eXBlLmdldEl0ZW1cbiAgLy8gdG8gdGhpbmsgdGhhdCB0aGUgZGlyZWN0b3J5IGNhbm5vdCBiZSB0cmF2ZXJzZWQuIFRoaXMgaXMgYSB3b3JrYXJvdW5kLCBob3dldmVyLCBhIGJldHRlciBzb2x1dGlvbiBtYXkgYmUgdG9cbiAgLy8gcmUtdGhpbmsgdGhlIGxvZ2ljIGluIEZpbGVTeXN0ZW0ucHJvdG90eXBlLmdldEl0ZW1cbiAgLy8gVGhpcyB3b3JrYXJvdW5kIGFkZHMgZXhlY3V0YWJsZSBwcml2aWxlZ2VzIGlmIHJlYWQgcHJpdmlsZWdlcyBhcmUgZm91bmRcbiAgc3RhdHMubW9kZSA9IGZpeFdpbjMyUGVybWlzc2lvbnMoc3RhdHMubW9kZSk7XG5cbiAgLy8gQ3JlYXRlIGRpcmVjdG9yeSBmYWN0b3J5XG4gIGNvbnN0IGRpcmVjdG9yeUl0ZW1zID0ge307XG4gIG91dHB1dFtvdXRwdXRQcm9wS2V5XSA9IEZpbGVTeXN0ZW0uZGlyZWN0b3J5KFxuICAgIE9iamVjdC5hc3NpZ24oc3RhdHMsIHtpdGVtczogZGlyZWN0b3J5SXRlbXN9KVxuICApO1xuXG4gIGZzLnJlYWRkaXJTeW5jKHRhcmdldCkuZm9yRWFjaChwID0+IHtcbiAgICBjb25zdCBhYnNQYXRoID0gcGF0aC5qb2luKHRhcmdldCwgcCk7XG4gICAgY29uc3Qgc3RhdHMgPSBmcy5zdGF0U3luYyhhYnNQYXRoKTtcbiAgICBjb25zdCBuZXdDb250ZXh0ID0gY3JlYXRlQ29udGV4dChjb250ZXh0LCB7XG4gICAgICB0YXJnZXQ6IGFic1BhdGgsXG4gICAgICBvdXRwdXQ6IGRpcmVjdG9yeUl0ZW1zXG4gICAgfSk7XG5cbiAgICBpZiAocmVjdXJzaXZlICYmIHN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIGFkZERpcihuZXdDb250ZXh0LCBzdGF0cyk7XG4gICAgfSBlbHNlIGlmIChzdGF0cy5pc0ZpbGUoKSkge1xuICAgICAgYWRkRmlsZShuZXdDb250ZXh0LCBzdGF0cyk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gb3V0cHV0W291dHB1dFByb3BLZXldO1xufVxuXG4vKipcbiAqIExvYWQgZGlyZWN0b3J5IG9yIGZpbGUgZnJvbSByZWFsIEZTXG4gKi9cbmV4cG9ydHMubG9hZCA9IGZ1bmN0aW9uKHAsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGJ5cGFzcygoKSA9PiB7XG4gICAgcCA9IHBhdGgucmVzb2x2ZShwKTtcblxuICAgIGNvbnN0IHN0YXRzID0gZnMuc3RhdFN5bmMocCk7XG4gICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe291dHB1dDoge30sIG9wdGlvbnMsIHRhcmdldDogcH0pO1xuXG4gICAgaWYgKHN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIHJldHVybiBhZGREaXIoY29udGV4dCwgc3RhdHMsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdHMuaXNGaWxlKCkpIHtcbiAgICAgIHJldHVybiBhZGRGaWxlKGNvbnRleHQsIHN0YXRzLCB0cnVlKTtcbiAgICB9XG4gIH0pO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/loader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/mock-fs/lib/symlink.js":
/*!*********************************************!*\
  !*** ./node_modules/mock-fs/lib/symlink.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst util = __webpack_require__(/*! util */ \"util\");\n\nconst Item = __webpack_require__(/*! ./item */ \"(ssr)/./node_modules/mock-fs/lib/item.js\");\n\nconst constants = __webpack_require__(/*! constants */ \"constants\");\n\n/**\n * A directory.\n * @constructor\n */\nfunction SymbolicLink() {\n  Item.call(this);\n\n  /**\n   * Relative path to source.\n   * @type {string}\n   */\n  this._path = undefined;\n}\nutil.inherits(SymbolicLink, Item);\n\n/**\n * Set the path to the source.\n * @param {string} pathname Path to source.\n */\nSymbolicLink.prototype.setPath = function(pathname) {\n  this._path = pathname;\n};\n\n/**\n * Get the path to the source.\n * @return {string} Path to source.\n */\nSymbolicLink.prototype.getPath = function() {\n  return this._path;\n};\n\n/**\n * Get symbolic link stats.\n * @return {Object} Stats properties.\n */\nSymbolicLink.prototype.getStats = function() {\n  const size = this._path.length;\n  const stats = Item.prototype.getStats.call(this);\n  stats.mode = this.getMode() | constants.S_IFLNK;\n  stats.size = size;\n  stats.blocks = Math.ceil(size / 512);\n  return stats;\n};\n\n/**\n * Export the constructor.\n * @type {function()}\n */\nexports = module.exports = SymbolicLink;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvc3ltbGluay5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCLGFBQWEsbUJBQU8sQ0FBQyx3REFBUTs7QUFFN0Isa0JBQWtCLG1CQUFPLENBQUMsNEJBQVc7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcG9ydGtleS9uZXh0LWV4YW1wbGUvLi9ub2RlX21vZHVsZXMvbW9jay1mcy9saWIvc3ltbGluay5qcz9lNWIzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuY29uc3QgSXRlbSA9IHJlcXVpcmUoJy4vaXRlbScpO1xuXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCdjb25zdGFudHMnKTtcblxuLyoqXG4gKiBBIGRpcmVjdG9yeS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBTeW1ib2xpY0xpbmsoKSB7XG4gIEl0ZW0uY2FsbCh0aGlzKTtcblxuICAvKipcbiAgICogUmVsYXRpdmUgcGF0aCB0byBzb3VyY2UuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0aGlzLl9wYXRoID0gdW5kZWZpbmVkO1xufVxudXRpbC5pbmhlcml0cyhTeW1ib2xpY0xpbmssIEl0ZW0pO1xuXG4vKipcbiAqIFNldCB0aGUgcGF0aCB0byB0aGUgc291cmNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhuYW1lIFBhdGggdG8gc291cmNlLlxuICovXG5TeW1ib2xpY0xpbmsucHJvdG90eXBlLnNldFBhdGggPSBmdW5jdGlvbihwYXRobmFtZSkge1xuICB0aGlzLl9wYXRoID0gcGF0aG5hbWU7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgcGF0aCB0byB0aGUgc291cmNlLlxuICogQHJldHVybiB7c3RyaW5nfSBQYXRoIHRvIHNvdXJjZS5cbiAqL1xuU3ltYm9saWNMaW5rLnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9wYXRoO1xufTtcblxuLyoqXG4gKiBHZXQgc3ltYm9saWMgbGluayBzdGF0cy5cbiAqIEByZXR1cm4ge09iamVjdH0gU3RhdHMgcHJvcGVydGllcy5cbiAqL1xuU3ltYm9saWNMaW5rLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBzaXplID0gdGhpcy5fcGF0aC5sZW5ndGg7XG4gIGNvbnN0IHN0YXRzID0gSXRlbS5wcm90b3R5cGUuZ2V0U3RhdHMuY2FsbCh0aGlzKTtcbiAgc3RhdHMubW9kZSA9IHRoaXMuZ2V0TW9kZSgpIHwgY29uc3RhbnRzLlNfSUZMTks7XG4gIHN0YXRzLnNpemUgPSBzaXplO1xuICBzdGF0cy5ibG9ja3MgPSBNYXRoLmNlaWwoc2l6ZSAvIDUxMik7XG4gIHJldHVybiBzdGF0cztcbn07XG5cbi8qKlxuICogRXhwb3J0IHRoZSBjb25zdHJ1Y3Rvci5cbiAqIEB0eXBlIHtmdW5jdGlvbigpfVxuICovXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBTeW1ib2xpY0xpbms7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mock-fs/lib/symlink.js\n");

/***/ })

};
;